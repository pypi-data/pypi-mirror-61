# This file is part of the Reproducible and Reusable Data Analysis Workflow
# Server (flowServ).
#
# Copyright (C) [2019-2020] NYU.
#
# flowServ is free software; you can redistribute it and/or modify it under the
# terms of the MIT License; see LICENSE file for more details.

"""Collection of helper functions to retrieve and manipulate workflow run
states.
"""

import os

from flowserv.model.workflow.resource import FSObject

import flowserv.model.workflow.state as state


# -- State loader -------------------------------------------------------------

def get_run_state(con, run_id, state_id, created_at, started_at, ended_at, basedir):
    """Get an instance of the workflow state for the given run.

    Parameters
    ----------
    con: DB-API 2.0 database connection
        Connection to underlying database
    run_id: string
        Unique run identifier
    state_id: string
        Unique state identifier
    created_at: datetime.datetime
        Run creation dtimestampate
    started_at: datetime.datetime
        Run start timestamp (None for pending runs)
    ended_at: datetime.datetime
        Run end timestamp (None for active runs)
    basedir: string
        Path to the base directory for run files
    Returns
    -------
    flowserv.model.workflow.state.WorkflowState
    """
    if state_id == state.STATE_PENDING:
        return state.StatePending(created_at=created_at)
    elif state_id == state.STATE_RUNNING:
        return state.StateRunning(
            created_at=created_at,
            started_at=started_at
        )
    elif state_id in [state.STATE_CANCELED, state.STATE_ERROR]:
        # Read error messages from the database
        messages = list()
        sql = 'SELECT * FROM run_error_log WHERE run_id = ? ORDER BY pos'
        for msg in con.execute(sql, (run_id,)).fetchall():
            messages.append(msg['message'])
        if state_id == state.STATE_CANCELED:
            return state.StateCanceled(
                created_at=created_at,
                started_at=started_at,
                stopped_at=ended_at,
                messages=messages
            )
        else:
            return state.StateError(
                created_at=created_at,
                started_at=started_at,
                stopped_at=ended_at,
                messages=messages
            )
    else:  # state_id == state.STATE_SUCCESS:
        # Read file resources that were generated by the run
        resources = list()
        sql = (
            'SELECT resource_id, resource_name '
            'FROM run_result_file '
            'WHERE run_id = ?'
        )
        for f in con.execute(sql, (run_id,)).fetchall():
            resource_name = f['resource_name']
            f = FSObject(
                identifier=f['resource_id'],
                name=resource_name,
                filename=os.path.join(basedir, resource_name)
            )
            resources.append(f)
        return state.StateSuccess(
            created_at=created_at,
            started_at=started_at,
            finished_at=ended_at,
            resources=resources
        )


# -- State setter -------------------------------------------------------------

def set_error(con, run_id, started_at, stopped_at, messages, is_canceled=False):
    """Set the state of the given run to an error state. If the canceled flag
    is True the state will be CANCELED and ERROR otherwise.

    Parameters
    ----------
    con: DB-API 2.0 database connection
        Connection to underlying database
    run_id: string
        Unique run identifier
    started_at: datetime.datetime
        Run start timestamp
    stopped_at: datetime.datetime
        Run end timestamp
    messages: list(string)
        List of error messages
    is_canceled: bool, optional
        Set run into CANCELED state if True
    """
    # Update the run state record
    sql = (
        'UPDATE workflow_run '
        'SET state = ?, started_at = ?, ended_at = ? '
        'WHERE run_id = ?'
    )
    args = (
        state.STATE_CANCELED if is_canceled else state.STATE_ERROR,
        started_at.isoformat(),
        stopped_at.isoformat(),
        run_id
    )
    con.execute(sql, args)
    # Insert error messages
    sql = 'INSERT INTO run_error_log(run_id, message, pos) VALUES(?, ?, ?)'
    for i in range(len(messages)):
        con.execute(sql, (run_id, messages[i], i))


def set_running(con, run_id, started_at):
    """Set the state of the given workflow run to RUNNING.

    Parameters
    ----------
    con: DB-API 2.0 database connection
        Connection to underlying database
    run_id: string
        Unique run identifier
    started_at: datetime.datetime
        Run start timestamp
    """
    sql = 'UPDATE workflow_run SET state = ?, started_at = ? WHERE run_id = ?'
    con.execute(sql, (state.STATE_RUNNING, started_at.isoformat(), run_id))


def set_success(con, run_id, started_at, finished_at, resources):
    """Set the state of the given workflow run to SUCCESS.

    Parameters
    ----------
    con: DB-API 2.0 database connection
        Connection to underlying database
    run_id: string
        Unique run identifier
    started_at: datetime.datetime
        Run start timestamp
    finished_at: datetime.datetime
        Run finish timestamp
    resources: flowserv.model.workflow.resource.ResourceSet
        Resources that were generated by the workflow run
    """
    # Update the run state record
    sql = (
        'UPDATE workflow_run '
        'SET state = ?, started_at = ?, ended_at = ? '
        'WHERE run_id = ?'
    )
    args = (
        state.STATE_SUCCESS,
        started_at.isoformat(),
        finished_at.isoformat(),
        run_id
    )
    con.execute(sql, args)
    # Insert information about generated resource files
    sql = (
        'INSERT INTO run_result_file'
        '(run_id, resource_id, resource_name) '
        'VALUES(?, ?, ?)'
    )
    for r in resources:
        con.execute(sql, (run_id, r.identifier, r.name))
