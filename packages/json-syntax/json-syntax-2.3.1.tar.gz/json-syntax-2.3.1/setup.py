# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['json_syntax', 'json_syntax.extras']

package_data = \
{'': ['*']}

extras_require = \
{':python_version < "3.5"': ['typing>=3.7,<4.0'],
 ':python_version < "3.7"': ['python-dateutil>=2.7,<3.0']}

setup_kwargs = {
    'name': 'json-syntax',
    'version': '2.3.1',
    'description': 'Generates functions to convert Python classes to JSON dumpable objects.',
    'long_description': '[![CircleCI](https://circleci.com/gh/UnitedIncome/json-syntax/tree/master.svg?style=svg)](https://circleci.com/gh/UnitedIncome/json-syntax/tree/master)\n\n# json-syntax\n\nA Python library to translate between JSON compatible structures and native Python\nclasses using customizable rules.\n\n## Use case\n\nIf you\'re like the authors, you tried writing a encoding function that attempted to\nencode and decode by interrogating the types at runtime, maybe calling some method like\n`asdict`. This works fine for generating JSON, but it gets sketchy<sup\nid="a1">[1](#f1)</sup> when trying to decode the same JSON.\n\nFurther, we have annotations in Python 3! Even if you\'re not using a type checker, just\nlabeling the types of fields makes complex data structures far more comprehensible.\n\nThis library is aimed at projects that have a complex JSON schema that they\'re trying to\nstructure using libraries like [attrs][].\n\n * It exploits [gradual typing][] via annotations, [typing][] and [dataclasses][]\n * It expects classes to be *statically* described using types\n    * But a fallback can be provided to handle data described at runtime\n    * It provides hooks to normalize legacy inputs\n * It makes it trivial to extend the library with your own rules\n    * Actions and Rules are simply functions\n    * Encoders and decoders can be pickled\n * The library has no dependencies of its own on python 3.7+\n    * It does not actually read or write JSON\n\n### Supported types\n\n * Atoms including `None`, `bool`, `int`, `float`, `str`.\n    * Floats may optionally be represented as strings.\n * The `decimal.Decimal` class, represented as itself or in string form.\n * The `datetime.date` and `datetime.datetime` classes, represented in ISO8601 form.\n * Preliminary support for `datetime.timedelta` as ISO8601 time durations.\n * Subclasses of `enum.Enum`, represented by the string names.\n    * Also, a `faux_enums` rule will accept an Enum type if you just use strings in your\n      code.\n * The `typing.Optional[E]` type allows a JSON `null` to be substituted for a value.\n * Collections including `typing.List[E]`, `typing.Tuple[E, ...]`, `typing.Set[E]` and\n   `typing.FrozenSet[E]`.\n    * The `...` is [literal][ellipsis] and indicates a homogenous tuple, essentially a\n      frozen list.\n * The `typing.Dict[K, V]` type allows a JSON object to represent a homogenous `dict`.\n    * Restriction: the keys must be strings, ints, enums or dates.\n * **New**: The `typing.TypedDict` type allows a JSON object to represent a `dict` with specific\n   keys.\n * Python classes implemented using `attrs.attrs`, `dataclasses.dataclass` are\n   represented as JSON dicts and\n * Named tuples via `typing.NamedTuple` and heterogenous tuples via `typing.Tuple`.\n    * Though, you should consider converting these to `dataclass`.\n * The `typing.Union[A, B, C]` rule will recognize alternate types by inspection.\n\nIn addition, `dataclass` and `attrs` classes support hooks to let you completely customize\ntheir JSON representation.\n\n### Extras\n\nThese were originally intended as examples for how to use the package, but they\'re potentially\nuseful in their own right.\n\n * [A ruleset][extras ddb] for use with AWS DynamoDB is included with basic facilities.\n   * Restriction: No general support for `typing.Union`, only `Optional`.\n   * Restriction: No general support for `Set`, only the special cases that are native to DynamoDB.\n * [A `Flag` psuedo-type][extras flag] allows you to use regular strings directly as flags.\n * [A rule][extras loose] that will accept a complete `datetime` and return a `date` by truncating the timestamp.\n\n## Usage\n\nThis example is also implemented in unit tests. First, let\'s declare some classes.\n\n```python\nimport json_syntax as syn\nfrom dataclasses import dataclass  # attrs works too\nfrom decimal import Decimal\nfrom datetime import date\nfrom enum import Enum\n\n@dataclass\nclass Account:\n    user: str\n    transactions: List[\'Trans\']  # Forward references work!\n    balance: Decimal = Decimal()\n\nclass TransType(Enum):\n    withdraw = 0\n    deposit = 1\n\n@dataclass\nclass Trans:\n    type: TransType\n    amount: Decimal\n    stamp: date\n```\n\nWe\'ll next set up a RuleSet and use it to construct an encoder. The `std_ruleset`\nfunction is a one-liner with some reasonable overrides. Here, we\'ve decided that because\nsome intermediate services don\'t reliably retain decimal values, we\'re going to\nrepresent them in JSON as strings.\n\n```python\n>>> rules = syn.std_ruleset(decimals=syn.decimals_as_str)\n>>> encode_account = rules.python_to_json(typ=Account)\n>>> decode_account = rules.json_to_python(typ=Account)\n```\n\nThe RuleSet examines the type and verb, searches its list of Rules, and then uses the\nfirst one that handles that type and verb to produce an Action.\n\nFor example, `attrs_classes` is a Rule that recognizes the verbs `python_to_json` and\n`json_to_python` and will accept any class decorated with `@attr.s` or `@dataclass`.\n\nIt will scan the fields and ask the RuleSet how to encode them. So when it sees\n`Account.user`, the `atoms` rule will match and report that converting a `str` to JSON\ncan be accomplished by simply calling `str` on it. The action it returns will literally\nbe the `str` builtin.\n\nThus `attrs_classes` will build a list of attributes on `Account` and actions to convert\nthem, and constructs an action to represent them.\n\n```python\n>>> sample_value = Account(\n...     \'bob\', [\n...         Trans(TransType.withdraw, Decimal(\'523.33\'), date(2019, 4, 4))\n...     ], Decimal(\'77.00\')\n... )\n\n>>> encode_account(sample_value)\n{\n  \'user\': \'bob\',\n  \'transactions\': [\n    {\n      \'type\': \'withdraw\',\n      \'amount\': \'523.33\',\n      \'stamp\': \'2019-04-04\'\n    }\n  ], \'balance\': \'77.00\'\n}\n```\n\n#### Encoding and decoding\n\nThe aim of all this is to enable reliable usage with your preferred JSON library:\n\n```python\nwith open(\'myfile.json\', \'r\') as fh:\n    my_account = decode_account(json.load(fh))\n\nwith open(\'myfile.json\', \'w\') as fh:\n    json.dump(encode_account(my_account))\n```\n\n### Using generic types\n\nGenerally, the [typing][] module simple provides capital letter type names that obviously\ncorrespond to the internal types. [See TYPES for a more thorough introduction][types].\n\nAnd you specify the type of the contents as a parameter in square brackets.\n\nThus we have:\n\n * `list` and `List[E]`\n * `set` and `Set[E]`\n * `tuple` and `Tuple[E, ...]` is a special case!\n * `frozenset` and `FrozenSet[E]`\n * `dict` and `Dict[K, V]`\n\nTuple is a special case. In Python, they\'re often used to mean "frozenlist", so\n`Tuple[E, ...]` (the `...` is [the Ellipsis object][ellipsis]) indicates all elements have\nthe type `E`.\n\nThey\'re also used to represent an unnamed record. In this case, you can use\n`Tuple[A, B, C, D]` or however many types. It\'s generally better to use a `dataclass`.\n\nThe standard rules don\'t support:\n\n 1. Using abstract types like `Iterable` or `Mapping`.\n 2. Using type variables.\n 3. Any kind of callable, coroutine, file handle, etc.\n\n#### Support for deriving from Generic\n\nThere is experimental support for deriving from `typing.Generic`. An `attrs` or `dataclass`\nmay declare itself a generic class. If another class invokes it as `YourGeneric[Param,\nParam]`, those `Param` types will be substituted into the fields during encoding. This is\nuseful to construct parameterized container types. Example:\n\n    @attr.s(auto_attribs=True)\n    class Wrapper(Generic[T, M]):\n        body: T\n        count: int\n        messages: List[M]\n\n    @attr.s(auto_attribs=True)\n    class Message:\n        first: Wrapper[str, str]\n        second: Wrapper[Dict[str, str], int]\n\n#### Unions\n\nA union type lets you present alternate types that the converters will attempt in\nsequence, e.g. `typing.Union[MyType, int, MyEnum]`.\n\nThis is implemented in the `unions` rule as a so-called<sup id="a2">[2](#f2)</sup>\nundiscriminated union. It means the module won\'t add any additional information to the\nvalue such as some kind of explicit tag.\n\nWhen converting from Python to JSON, the checks are generally just using `isinstance`,\nbut when converting from JSON to Python, the check may be examining strings and `dict`\nfields.\n\nThus, ambiguous values, especially JSON representations, may confuse the decoder.\nSee the section on [sharp edges][sharp] for more details.\n\n### Hooks\n\nWe\'ll first examine decode and encode hooks. These let us entirely rewrite the JSON\nrepresentation before the normal logic is applied.\n\nLet\'s suppose our `Account` class used to named the `balance` field `bal` and we need to\nsupport legacy users.\n\n```python\n@dataclass\nclass Account:\n    @classmethod\n    def __json_pre_decode__(cls, value):\n        if \'bal\' in value:\n            value = dict(value)\n            value[\'balance\'] = value.pop(\'bal\')\n        return value\n\n    def __json_post_encode__(self, value):\n        return dict(value, bal=value[\'balance\'])\n\n    ...\n```\n\nWhen we decode the value, the following sequence of steps takes place:\n\n 1. `__json_pre_decode__` is called with `{\'user\': \'bob\', \'bal\': \'77.0\', ...}` and it\n    returns `{\'user\': \'bob\', \'balance\': \'77.0\', ...}`\n 2. Decoders are called against `user` and `balance` and the other fields\n 3. The resulting dictionary is passed to `Account(**result)` to construct the instance.\n\nDuring encoding, the reverse sequence takes place:\n\n 1. The instance\'s fields are read and passed to encoders.\n 2. The values are combined into a `dict`.\n 3. `__json_post_encode__` is called with `{\'user\': \'bob\', \'balance\': \'77.0\', ...}` and\n    can adjust the field name to `bal`.\n\n#### JSON type check hook\n\nType checks are only used in _json-syntax_ to support `typing.Union`; in a nutshell, the\n`unions` rule will inspect some JSON to see which variant is present.\n\nIf a type-check hook is not defined, `__json_pre_decode__` will be called before the\nstandard check is completed. (The standard check attempts to determine if required\nfields are present and have the correct type.)\n\nIf you have information that can determine the type faster, a check hook can help.\n\nGoing back to our Account example, suppose we decide to support multiple account types\nthrough a special ``class`` field. This is faster and more robust.\n\n```python\nclass AbstractAccount:\n    @classmethod\n    def __json_check__(cls, value):\n        return isinstance(value, dict) and value.get(\'class\') == cls.__name__\n\n@dataclass\nclass AccountA(AbstractAccount):\n    ...\n\nencode_account = rules.lookup(typ=Union[AccountA, AccountB, AccountC],\n                              verb=\'python_to_json\')\n```\n\n### Adding custom rules\n\nSee [the extras][] for details on custom rules, but generally a rule is just a\nfunction. Say, for instance, your type has class methods that encode and decode, this\nwould be sufficient for many cases:\n\n```python\ndef my_rule(verb, typ, ctx):\n    if issubclass(typ, MyType):\n        if verb == \'json_to_python\':\n            return typ.decoder\n        elif verb == \'python_to_json\':\n            return typ.encoder\n```\n\nIf your rule needs an encoder or decoder for a standard type, it can call\n`ctx.lookup(verb=verb, typ=subtype)`. The helper functions defined in `json_syntax.action_v1`\nare intended to stay the same so that custom rules can reuse them.\n\n### Debugging amibguous structures\n\n(May need more docs and some test cases.)\n\nAs _json-syntax_ tries to directly translate your Python types to JSON, it is possible\nto write ambiguous structures. To avoid this, there is a handy `is_ambiguous` method:\n\n```python\n# This is true because both are represented as an array of numbers in JSON.\nrules.is_ambiguous(typ=Union[List[int], Set[int]])\n\n@dataclass\nclass Account:\n    user: str\n    address: str\n\n# This is true because such a dictionary would always match the contents of the account.\nrules.is_ambiguous(typ=Union[Dict[str, str], Account])\n```\n\nThe aim of this is to let you put a check in your unit tests to make sure data can be\nreliably expressed given your particular case.\n\nInternally, this is using the `PATTERN` verb to represent the JSON pattern, so this may\nbe helpful in understanding how _json-syntax_ is trying to represent your data:\n\n```python\nprint(rules.lookup(typ=MyAmbiguousClass, verb=\'show_pattern\'))\n```\n\n### Sharp edges\n\n_The RuleSet caches encoders._ Construct a new ruleset if you want to change settings.\n\n_Encoders and decoders do very little checking._ Especially, if you\'re translating\nPython to JSON, it\'s assumed that your Python classes are correct. The encoders and\ndecoders may mask subtle issues as they are calling constructors like `str` and `int`\nfor you. And, by design, if you\'re translating from JSON to Python, it\'s assumed you\nwant to be tolerant of extra data.\n\n_Everything to do with typing._ It\'s a bit magical and sort of wasn\'t designed for this.\n[We have a guide to it to try and help][types].\n\n_Union types._ You can use `typing.Union` to allow a member to be one of some number of\nalternates, but there are some caveats. You should use the `.is_ambiguous()` method of\nRuleSet to warn you of these.\n\n_Atom rules accept specific types._ At present, the rules for atomic types (`int`,\n `str`, `bool`, `date`, `float`, `Decimal`) must be declared as exactly those types. With\nmultiple inheritance, it\'s not clear which rule should apply\n\n_Checks are stricter than converters._ For example, a check for `int` will check whether\nthe value is an integer, whereas the converter simply calls `int` on it. Thus there are\ninputs for where `MyType` would pass but `Union[MyType, Dummy]` will fail. (Note\nthat `Optional` is special cased to look for `None` and doesn\'t have this problem.)\n\n_Numbers are hard._ See the rules named `floats`, `floats_nan_str`, `decimals`,\n`decimals_as_str` for details on how to get numbers to transmit reliably. There is no rule for\nfractions or complex numbers as there\'s no canonical way to transmit them via JSON.\n\n## Maintenance\n\nThis package is maintained via the [poetry][] tool. Some useful commands:\n\n 1. Setup: `poetry install`\n 2. Run tests: `poetry run pytest tests/`\n 3. Reformat: `black json_syntax/ tests/`\n 4. Generate setup.py: `dephell deps convert -e setup`\n 5. Generate requirements.txt: `dephell deps convert -e req`\n\n### Running tests via docker\n\nThe environments for 3.4 through 3.9 are in `pyproject.toml`, so just run:\n\n    dephell deps convert -e req  # Create requirements.txt\n    dephell docker run -e test34 pip install -r requirements.txt\n    dephell docker run -e test34 pytest tests/\n    dephell docker shell -e test34 pytest tests/\n    dephell docker destroy -e test34\n\n### Notes\n\n<b id="f1">1</b>: Writing the encoder is deceptively easy because the instances in\nPython have complete information. The standard `json` module provides a hook to let\nyou encode an object, and another hook to recognize `dict`s that have some special\nattribute. This can work quite well, but you\'ll have to encode *all* non-JSON types\nwith dict-wrappers for the process to work in reverse. [↩](#a1)\n\n<b id="f2">2</b>: A discriminated union has a tag that identifies the variant, such as\nstatus codes that indicate success and a payload, or some error. Strictly, all unions\nmust be discriminated in some way if different code paths are executed. In the `unions`\nrule, the discriminant is the class information in Python, and the structure of the JSON\ndata. A less flattering description would be that this is a "poorly" discriminated\nunion. [↩](#a2)\n\n[poetry]: https://poetry.eustace.io/docs/#installation\n[gradual typing]: https://www.python.org/dev/peps/pep-0483/#summary-of-gradual-typing\n[the extras]: https://github.com/UnitedIncome/json-syntax/tree/master/json_syntax/extras\n[typing]: https://docs.python.org/3/library/typing.html\n[types]: https://github.com/UnitedIncome/json-syntax/blob/master/TYPES.md\n[attrs]: https://attrs.readthedocs.io/en/stable/\n[dataclasses]: https://docs.python.org/3/library/dataclasses.html\n[sharp]: https://github.com/UnitedIncome/json-syntax/blob/master/README.md#sharp-edges\n[ellipsis]: https://docs.python.org/3/library/stdtypes.html#the-ellipsis-object\n[extras ddb]: https://github.com/UnitedIncome/json-syntax/tree/master/json_syntax/extras/dynamodb.py\n[extras flag]: https://github.com/UnitedIncome/json-syntax/tree/master/json_syntax/extras/flags.py\n[extras loose]: https://github.com/UnitedIncome/json-syntax/tree/master/json_syntax/extras/loose_dates.py\n',
    'author': 'Ben Samuel',
    'author_email': 'bsamuel@unitedincome.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/UnitedIncome/json-syntax',
    'packages': packages,
    'package_data': package_data,
    'extras_require': extras_require,
    'python_requires': '>=3.4,<4.0',
}


setup(**setup_kwargs)
