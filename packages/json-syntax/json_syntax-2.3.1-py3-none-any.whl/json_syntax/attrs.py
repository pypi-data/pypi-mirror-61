from .helpers import JSON2PY, PY2JSON, INSP_JSON, INSP_PY, PATTERN, has_origin, identity
from .action_v1 import (
    check_dict,
    check_isinst,
    check_tuple_as_list,
    convert_attrs_to_dict,
    convert_dict_to_dict,
    convert_dict_to_attrs,
    convert_tuple_as_list,
)
from . import pattern as pat
from .product import build_attribute_map, build_named_tuple_map, build_typed_dict_map
from .types import is_generic, get_origin, get_argument_map

from functools import partial

_SUPPORTED_VERBS = (JSON2PY, PY2JSON, INSP_PY, INSP_JSON, PATTERN)


def attrs_classes(
    verb,
    typ,
    ctx,
    pre_hook="__json_pre_decode__",
    post_hook="__json_post_encode__",
    check="__json_check__",
):
    """
    Handle an ``@attr.s`` or ``@dataclass`` decorated class.

    This rule also implements several hooks to handle complex cases, especially to
    manage backwards compatibility. Hooks should be resilient against invalid data,
    and should not mutate their inputs.

    `__json_pre_decode__` is used by decoders constructed by `RuleSet.json_to_python`.
    It will be called before decoding with the JSON object and may adjust them to fit
    the expected structure, which must be a `dict` with the necessary fields.

    The checker generated by `inspect_json` will also call `__json_pre_decode__` before
    inspecting the value generated.

    `__json_post_encode__` is used by encoders constructed by `RuleSet.python_to_json`.
    It will be called after encoding with the JSON object and may adjust it as
    necessary.

    `__json_check__` may be used to completely override the `inspect_json` check generated
    for this class.
    """
    if verb not in _SUPPORTED_VERBS:
        return
    if is_generic(typ):
        typ_args = get_argument_map(typ)
        typ = get_origin(typ)
    else:
        typ_args = None

    inner_map = build_attribute_map(verb, typ, ctx, typ_args)
    if inner_map is None:
        return

    if verb == INSP_PY:
        return partial(check_isinst, typ=typ)

    if verb == JSON2PY:
        pre_hook_method = getattr(typ, pre_hook, identity)
        return partial(
            convert_dict_to_attrs,
            pre_hook=pre_hook_method,
            inner_map=inner_map,
            con=typ,
        )
    elif verb == PY2JSON:
        post_hook = post_hook if hasattr(typ, post_hook) else None
        return partial(convert_attrs_to_dict, post_hook=post_hook, inner_map=inner_map)
    elif verb == INSP_JSON:
        check = getattr(typ, check, None)
        if check:
            return check
        pre_hook_method = getattr(typ, pre_hook, identity)
        return partial(check_dict, inner_map=inner_map, pre_hook=pre_hook_method)
    elif verb == PATTERN:
        return pat.Object.exact(
            (pat.String.exact(attr.name), attr.inner or pat.Unkown)
            for attr in inner_map
            if attr.is_required
        )


def named_tuples(verb, typ, ctx):
    """
    Handle a ``NamedTuple(name, [('field', type), ('field', type)])`` type.

    Also handles a ``collections.namedtuple`` if you have a fallback handler.

    Warning: there's no clear runtime marker that something is a namedtuple; it's just
    a subclass of ``tuple`` that has some special fields.
    """
    if verb not in _SUPPORTED_VERBS:
        return

    inner_map = build_named_tuple_map(verb, typ, ctx)
    if inner_map is None:
        return

    if verb == INSP_PY:
        return partial(check_isinst, typ=typ)
    elif verb == JSON2PY:
        return partial(
            convert_dict_to_attrs, pre_hook=identity, inner_map=inner_map, con=typ
        )
    elif verb == PY2JSON:
        return partial(convert_attrs_to_dict, post_hook=None, inner_map=inner_map)
    elif verb == INSP_JSON:
        return partial(check_dict, pre_hook=identity, inner_map=inner_map)
    elif verb == PATTERN:
        return pat.Object.exact(
            (pat.String.exact(attr.name), attr.inner)
            for attr in inner_map
            if attr.is_required
        )


def typed_dicts(verb, typ, ctx):
    """
    Handle the TypedDict product type. This allows you to construct a dict with specific
    (string) keys, which is often how people really use dicts.

    Both the class form and the functional form,
    ``TypedDict('Name', {'field': type, 'field': type})`` are supported.
    """
    if verb not in _SUPPORTED_VERBS:
        return

    inner_map = build_typed_dict_map(verb, typ, ctx)
    if inner_map is None:
        return

    # Note: we pass `dict` as the typ here because it's the correct constructor.
    if verb in (JSON2PY, PY2JSON):
        return partial(convert_dict_to_dict, inner_map=inner_map, con=typ)
    elif verb in (INSP_JSON, INSP_PY):
        return partial(check_dict, pre_hook=identity, inner_map=inner_map)
    elif verb == PATTERN:
        return pat.Object.exact(
            (pat.String.exact(attr.name), attr.inner)
            for attr in inner_map
            if attr.is_required
        )


def tuples(verb, typ, ctx):
    """
    Handle a ``Tuple[type, type, type]`` product type. Use a ``NamedTuple`` if you don't
    want a list. Though, if possible, prefer ``attrs`` or ``dataclass``.
    """
    if verb not in _SUPPORTED_VERBS or not has_origin(typ, tuple):
        return

    args = typ.__args__
    if Ellipsis in args:
        # This is a homogeneous tuple, use the lists rule.
        return
    inner = [ctx.lookup(verb=verb, typ=arg) for arg in args]
    if verb == JSON2PY:
        return partial(convert_tuple_as_list, inner=inner, con=tuple)
    elif verb == PY2JSON:
        return partial(convert_tuple_as_list, inner=inner, con=list)
    elif verb == INSP_PY:
        return partial(check_tuple_as_list, inner=inner, con=tuple)
    elif verb == INSP_JSON:
        return partial(check_tuple_as_list, inner=inner, con=list)
    elif verb == PATTERN:
        return pat.Array.exact(inner)
