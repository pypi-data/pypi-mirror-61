<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
  <head>
    <title>AdvancedQuery</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>

  <body>
    <h1>AdvancedQuery</h1>

<h2>Introduction</h2>
<p><code>AdvancedQuery</code> is a Zope product extending Zope's search
engine <code>ZCatalog</code> with the following key features:

<ul>
 <li>flexible and intuitive construction of query objects

 <li>support for arbitrary "and", "or" and "not" combinations of queries

 <li>flexible multi-level sort support; incremental sorting

 <li>ranking support

 <li>new elementary searches (such as "glob" and "regexp" searches)

 <li>support for incremental filtering

 <li>functional and/or efficiency gains via Zope "(subscription) adapter"s
 for indexes

 <li>optional integration with
   <a href="https://pypi.org/project/dm.incrementalsearch">dm.incrementalsearch</a>,
   a low level incremental search engine
   aiming to reduce the number of ZODB loads for searching
</ul>

<h2>Query Objects</h2>
<p>Queries are specified by (full blown) Python objects.
They are constructed in the following way:</p>

<table cellpadding=4 border=1>
<tr><th>Expression</th><th>printed as<th>Meaning</th></tr>
<tr>
  <td><code>Eq(<var>index</var>, <var>value</var>, <var>filter</var>=False)</code></td>
  <td><code><var>index</var> = <var>value</var></code></td>
  <td>the documents indexed by <var>index</var> under <var>value</var></td>
</tr>
<tr>
  <td><code>Le(<var>index</var>, <var>value</var>, <var>filter</var>=False)</code></td>
  <td><code><var>index</var> &lt;= <var>value</var></code></td>
  <td>the documents indexed by <var>index</var> under a value less or equal <var>value</var></td>
</tr>
<tr>
  <td><code>Ge(<var>index</var>, <var>value</var>, <var>filter</var>=False)</code></td>
  <td><code><var>index</var> >= <var>value</var></code></td>
  <td>the documents indexed by <var>index</var> under a value greater or equal <var>value</var></td>
</tr>
<tr>
  <td><code>Between(<var>index</var>, <var>min</var>, <var>max</var>, <var>filter</var>=False)</code></td>
  <td><code><var>min</var> &lt;= <var>index</var> <= <var>max</var></code></td>
  <td>the documents indexed by <var>index</var> under a value between
  <var>min</var> and <var>max</var></td>
</tr>
<tr>
  <td><code>In(<var>index</var>, <var>sequence</var>, <var>filter</var>=False)</code></td>
  <td><code><var>index</var> in <var>sequence</var></code></td>
  <td>the documents indexed by <var>index</var> under a value in
  <var>sequence</var></td>
</tr>
<tr>
  <td><code>Generic(<var>index</var>, <var>value</var>, <var>filter</var>=False)</code></td>
  <td><code><var>index</var> ~~ <var>value</var></code></td>
  <td>this query type is used to pass any search expression to
  <var>index</var> as understood by it. Such search expressions
  usually take the form of a dictionary with <code>query</code>
  as the most essential key. <code>Generic</code> is necessary
  to use the full power of specialized indexes, such as the
  <code>level</code> argument for PathIndex searches.</td>
</tr>
<tr>
  <td><code>Indexed(<var>index</var>)</code></td>
  <td><code>Indexed(<var>index</var>)</code></td>
  <td>the documents that are indexed by <var>index</var>. This does not
  work for all index types.</td>
</tr>
<tr>
  <td><code>MatchGlob(<var>index</var>, <var>pattern</var>, <var>filter</var>=False)</code></td>
  <td><code><var>index</var> =~ <var>pattern</var></code></td>
  <td>the documents indexed by <var>index</var> under a value matching the glob <var>pattern</var>. A glob pattern can contain wildcards <code>*</code> (matches any sequence of characters) and <code>?</code> (matches any single character).<br />
  This query type is only supported for indexes which can be
  adapted to <code>IKeyedIndex</code>. In addition, the index
  must index text values.
  </td>
</tr>
<tr>
  <td><code>MatchRegexp(<var>index</var>, <var>regexp</var>, <var>filter</var>=False)</code></td>
  <td><code><var>index</var> =~~ <var>regexp</var></code></td>
  <td>the documents indexed by <var>index</var> under a value matching
  the regular expression <var>regexp</var>.
  See the <code>re</code> module documentation in the Python Library Reference,
  for a description of regular expressions.<br />
  This query type is only supported for indexes which can be
  adapted to <code>IKeyedIndex</code>. In addition, the index
  must index text values.
  </td>
</tr>
<tr>
  <td><code>Filter(<var>index</var>, <var>filter</var>)</code></td>
  <td><code>Filtered(<var>index</var>, <var>filter</var>)</code></td>
  <td>filter out documents not accepted by <var>filter</var>.<br />
   <var>filter</var> is called with the document's indexed value;
   if it returns a true value, the document is accepted and rejected otherwise.
   Note that you must precisely know how <var>index</var>
   determines a document's indexed value to use this properly.</td>
<tr>
  <td><code>LiteralResultSet(<var>set</var>)</code></td>
  <td><code>LiteralResultSet(<var>set</var>)</code></td>
  <td>the documents specified by <var>set</var>.<br />
  <var>set</var> must be an <code>IISet</code>, <code>IITreeSet</code>
  or sequence of catalog "data_record_id_"s.<br />
  This can e.g. be used to further restrict the document set previously
  obtained through a query (e.g. for "facetting").
</tr>
<tr>
  <td><code>~ query</code></td>
  <td><code>~ query</code></td>
  <td>Not: the documents that do not satisfy <var>query</var></td>
</tr>
<tr>
  <td><code><var>query1</var> &amp; <var>query2</var></code></td>
  <td><code>(<var>query1</var> &amp; <var>query2</var>)</code></td>
  <td>And: the documents satisfying both <var>query1</var> and <var>query2</var></td>
</tr>
<tr>
  <td><code>And(*<var>queries</var>)</code></td>
  <td><code>(<var>query1</var> &amp; ... &amp; <var>queryn</var>)</code></td>
  <td>And: the documents satisfying all <var>queries</var>; if <var>queries</var> is empty, any document satisfies this <code>And</code> query</td>
</tr>
<tr>
  <td><code><var>query1</var> | <var>query2</var></code></td>
  <td><code>(<var>query1</var> | <var>query2</var>)</code></td>
  <td>Or: the documents satisfying either <var>query1</var> or <var>query2</var> (or both)</td>
</tr>
<tr>
  <td><code>Or(*<var>queries</var>)</code></td>
  <td><code>(<var>query1</var> | ... | <var>queryn</var>)</code></td>
  <td>Or: the documents satisfying (at least) one of <var>queries</var>; if <var>queries</var> is empty, no document satisfies this <code>Or</code> query</td>
</tr>

</table>

<p>A true <var>filter</var> value calls for
<a href="#incremental_filtering">incremental filtering</a>.
It is supported only for indexes which can be adapted to
<code>IFilterIndex</code>.</p>

<p><code>And</code> and <code>Or</code> queries are so called
<em>CompositeQuery</em>s. They possess a method
<code>addSubquery(<var>query</var>)</code> to add an additional subquery.</p>

<p>The constructors are imported from <code>Products.AdvancedQuery</code>.</p>

<p><code>AdvancedQuery</code> uses so called <em>Monkey Patching</em>
to give <code>ZCatalog</code> the new method
<code>makeAdvancedQuery(<var>catalogSearchSpec</var>)</code>.
A <var>catalogSearchSpec</var> is a search specification as
described in the Zope Book for <code>ZCatalog</code> searches
(essentially a dictionary mapping index names to search specifications).
<code>makeAdvancedQuery</code> returns the equivalent
<code>AdvancedQuery</code> search object.</p>


<h2>Query evaluation</h2>
<p><code>AdvancedQuery</code> uses so called <em>Monkey Patching</em>
to give <code>ZCatalog</code> the new methods
<code>evalAdvancedQuery(<var>query</var>, <var>sortSpecs</var>=(), <var>withSortValues</var>=_notPassed, **<var>kw</var>)</code>
and
<code>_unrestrictedEvalAdvancedQuery(<var>query</var>, <var>sortSpecs</var>=(), <var>withSortValues</var>=_notPassed, <var>restricted</var>=False, **<var>kw</var>)</code>.</p>

<p>
<code>evalAdvancedQuery</code> evaluates <var>query</var> and then
sorts the document result set according to <var>sortSpecs</var>.<br />
If <var>withSortValues</var> is not passed in, it is set to <code>True</code>
if <var>sortSpecs</var> contains a ranking specification (as you
are probably interested in the rank) and to <code>False</code> otherwise.<br />
If <var>withSortValues</var>, then the <code>data_record_score_</code>
attribute of the returned proxies is abused to hold the sort value.
It is a tuple with one component per component in <var>sortSpecs</var>.
The attribute <code>data_record_normalized_score_</code> is set to
<code>None</code>.
</p>

<p>Classes derived from <code>ZCatalog</code> can by default automatically
restrict queries. For example, <code>Products.CMFCore.CatalogTool.CatalogTool</code>
retricts queries automatically to those documents for which the current
user has <code>View</code> rights and which are "active".
<code>_unrestrictedEvalAdvancedQuery</code> allows to avoid
this automatic restriction.</p>


<h2>Sorting</h2>
<p><code>AdvancedQuery</code> supports incremental multi-level
lexicographic sorting via field index like indexes.
If an index used for sorting is not
field index like (i.e. does not index an object under at most one value),
you may get funny (and partly non determistic) results.</p>

<p>Sorting is specified by a sequence of sort specifications, each for
a single level. Such a specification is either an index name,
a pair index name and direction or a ranking specification (see below).
A direction is
<code>'asc'</code> (ascending) or <code>'desc'</code> (descending);
if the direction is not specified, <code>'asc'</code> is assumed.</p>

<p>When the result contains documents not indexed by a sorting index,
such documents are delivered after indexed documents.
This happens always, independant of search direction.</p>

<h2><a name="incremental_filtering">Incremental Filtering</a></h2>
<p>From version 1.1 on, <code>AdvancedQuery</code> supports incremental
filtering. Incremental filtering can be very promissing for an
unspecific subquery inside an otherwise specific And query,
especially for large <code>Le</code>, <code>Ge</code>,
<code>Between</code> and range subqueries. If we use the index in the normal
way a huge Or query is constructed for such subqueries. Even
<code>dm.incrementalsearch</code> cannot fully optimize the search against
this huge Or query. Whith incremental filtering the index is not used
in the normal way. Instead, the remaining And subqueries are
used to produce a set of document candidates. These are then
filtered by the filtering subquery, discarding documents not matching
the subquery. Provided that the other And subqueries already have
reduced the document set sufficiently, incremental filtering can
save a lot of time.</p>

<p>You request incremental filtering for an (elementary) subquery
with the <code>filter</code> keyword argument. Usually,
you use it only for some subqueries of specific And queries.
Otherwise, incremental filtering may not reduce but increase the
query time (even considerably).</p>

<p>If you have more than a single filtering subquery in an
And query, their order might be relevant for efficiency.
You should put filtering subqueries that are likely to reduce
the document set more before other filtering subqueries.</p>

<p>Incremental filtering requires that the affected index
can be adapted to <code>IFilterIndex</code>; otherwise,
the <var>filter</var> argument is ignored.
In addition, you should consider the use of
<code>dm.incrementalsearch</code> when you make significant
use of incremental filtering. <code>dm.incrementalsearch</code>
can globally optimize incremental filtering while otherwise
only a local optimization is possible.</p>

<h2>Ranking</h2>
<p>From version 2.0 on, <code>AdvancedQuery</code> supports
incremental ranking. Ranking is a form of sorting.
Therefore, you specify it as a sort spec. Ranking can be
combined with other sort specs in the usual way (leading to multi-level
sorting).</p>

<p>Like sorting in general, ranking is performed incrementally -- just
as far as you have looked at the result. Therefore, although ranking
in general is very expensive, its effect can be small if you only
look at the first few (hundred) result objects (rather than the several
hundred thousands).

<p>Currently, the ranking specifications <code>RankByQueries_Sum</code>,
and <code>RankByQueries_Max</code> are supported.
In both cases, you call the constructors with one
or more pairs (<var>q</var>,
<var>v<sub>q</sub></var>), i.e. with a sequence of weighted queries.<br />
The rank of a document is the sum or the maximum of the
weights for queries matching the document, respectively.
<br />
Note that the runtime
behaviour for <code>RankByQueries_Sum</code> is exponential, that
of <code>RankByQueries_Max</code> linear in the number of queries
involved in the ranking.<br />
Note that you probably want to normalize the document ranks.
The ranking classes above have methods <code>getQueryValueSum()</code>
and <code>getQueryValueMax()</code>, respectively, that can help with
this.
</p>


<h2>Examples</h2>

<pre class="python-code">
from Products.AdvancedQuery import Eq, Between, Le

# search for objects below 'a/b/c' with ids between 'a' and 'z~'
query = Eq('path','a/b/c') &amp; Between('id', 'a', 'z~')

# evaluate and sort descending by 'modified' and ascending by 'Creator'
context.Catalog.evalAdvancedQuery(query, (('modified','desc'), 'Creator',))

# search 'News' not yet archived and 'File's not yet expired.
now = context.ZopeTime()
query = Eq('portal_type', 'News') &amp; ~ Le('ArchivalDate', now)
	| Eq('portal_type', 'File') &amp; ~ Le('expires', now)
context.Catalog.evalAdvancedQuery(query)

# search 'News' containing 'AdvancedQuery' and filter out
# not yet effective or still expired documents.
query = Eq('portal_type', 'News') &amp; Eq('SearchableText', 'AdvancedQuery') \
  &amp; Ge('expires', now, filter=True) &amp; Le('effective', now, filter=True)
context.Catalog.evalAdvancedQuery(query)

# search for 'ranking' in 'SearchableText' and rank very high
# when the term is in 'Subject' and high when it is in 'Title'.
# print the id and the normalized rank
from Products.AdvancedQuery import RankByQueries_Sum
term = 'ranking'
rs = RankByQueries_Sum((Eq('Subject', term),16), (Eq('Title', term),8))
norm = 1 + rs.getQueryValueSum()
for r in context.Catalog.evalAdvancedQuery(
    Eq('SearchableText', term), (rs,)
    ):
    print r.getId, (1 + r.data_record_score_) / norm
</pre>

<h2>Important note about caching</h2>
<p>You must not cache the result of an <code>AdvancedQuery</code>
unless you have ensured that sorting has finished (e.g. by
accessing the last element in the result). This is because
<code>AdvancedQuery</code> uses incremental sorting with
<code>BTrees</code> iterators. Like any iterator, they do not
like when the base object changes during iteration. Nasty types
of (apparently) non-deterministic errors can happen when
the index changes during sorting.</p>

<h2>Download and installation</h2>
<p>The current version supports Zope 4 (and above), is maintained on
<a href="https://pypi.org/project/Products.AdvancedQuery">PyPI</a> and can
be <code>pip</code> installed. To use it, its <code>configure.zcml</code> must
be "executed" at startup (which typically happens automatically).</p>

<p>For the use in Plone (version 5.2+),
the companion package <code>dm.plone.advancedquery</code>
must be installed and its <code>configure.zcml</code> "executed" at startup.</p>


<h2>License</h2>
<p>This software is open source and licensed under a BSD style license.
See the license file in the distribution for details.</p>


<h2>Optimizations</h2>
<p>Former versions relied entirely on <code>dm.incrementalsearch</code>
for optimizations. To get the full potential,
the indexes should have known about <code>dm.incrementalsearch</code> as well
and used it for their lookup; likely only <code>Products.ManagableIndex</code>
indexes did this. From version 4 on, optimizations no longer
rely on <code>dm.incrementalsearch</code> (even though this
is still used, if installed). Optimizations now rely on
(conditional) adapters. In fact, (almost) the complete query
evaluation is controlled via adapters -- and by overriding
the package's adapters, you could (in principle) take over complete
control over the query evaluation. Likely, you will not do this
but maybe register additional adapters to provide optimizations for
new indexes.</p>

<h3>Query evaluation</h3>
<p>Query evaluation proceeds in the following steps:</p>

<ol>
<li>The query is "optimized" on the query level. For example,
"and" subqueries in an "and" query are dissolved by moving their
subqueries to the enclosing query; nested empty queries are eliminated;
<code>Generic</code> queries are transformed into specific queries (if possible).<br />
You could e.g. define an adapter for this step to make the
optimizations of <code>CompositeIndex</code> available.

<li>The query is transformed into an evaluation tree. The leaves of
those trees are "Set"s, "Lookup"s or "Filter"s, the inner nodes correspond
to "and", "or" and "not" combinations of the subtrees.
To get the subtree corresponding to an index query (i.e. an elementary
query with a parameter <var>index</var>), an adapter for the index
and the query is looked up. If the index supports the query, then
such an adapter (based on
<code>Products.PluginIndexes.interfaces.IPluggableIndex</code>) is
available. By defining a more specific adapter, the index's lookup
can be "white boxed" by specifying how the lookup result is combined
from more elementary lookups via "and", "or", "not" (and potentially "filter").
This allows for more optimizations over the case that the index
is treated as a "black box".

<li>The evaluation tree is optimized -- using elementary
properties of "and", "or" and "not".

<li>The evaluation tree is evaluated into a set of document ids --
the result set of the query.

<li>The result set is optionally sorted.
</ol>

<h3>Supporting a new index</h3>
<p><code>AdvancedQuery</code> should be able to
work with any index implementing
<code>Products.PluginIndexes.interfaces.IPluggableIndex</code>
out of the box. No index specific configuration should be necessary
for search features also supported by <code>ZCatalog</code>.</p>

<p>If <code>AdvancedQuery</code> extensions should be supported
for the new index (e.g. filtering or matching) or if searches
involving the index should benefit from index specific optimizations,
then it might become necessary to register corresponding adapters 
for the new index. Those adapters
would typically have as "provided" interface
<code>IQueryNodeOptimizer</code>,
<code>IQueryConverter</code>,
<code>IFilterIndex</code>,
<code>IIndexedValue</code>,
<code>IMultiplicityAware</code>,
<code>ITermValueMatch</code>,
<code>IIndexed</code>,
<code>IKeyedIndex</code>,
<code>IKeyNormalizingIndex</code>,
<code>ILookupIndex</code>,
or
<code>ILookupTreeIndex</code>,
all defined in <code>Products.AdvancedQuery.eval.interfaces</code>.
It is typically not necessary to define adapters for all those
interfaces. For example, the <code>IQueryNodeOptimizer</code> adapter
is necessary only when the index wants to perform optimizations
on the query level (as e.g. <code>CompositeIndex</code> does). 
<code>IFilterIndex</code>, <code>IIndexedValue</code>,
<code>IMultiplicityAware</code> and <code>ITermValueMatch</code>
may be relevant for filtering.
<code>IMultiplicityAware</code> is used in the optimization
of <code>not</code>, if available. <code>IIndexed</code> is required
for an index, when the <code>Indexed</code> query should be supported
for this index. <code>IKeyedIndex</code> is typically required for
the matching queries; and used for optimized convertions of
<code>Le</code>, <code>Ge</code> and <code>between</code> queries.
If the new index normalizes its search terms and you
define an <code>IKeyedIndex</code> or <code>IFilterIndex</code> adapter,
then likely an <code>IKeyNormalizingIndex</code> adapter is
required. The "Lookup" and <code>IQueryConverter</code> adapters
are always optional and used for optimizations; typically, at most
one of those would be defined for an index.</p>

<p>There are roughly two cases:</p>
<ol>
<li>The index is fairly simple. Then there is a good change, that
all <code>AdvancedQuery</code> extensions can be supported.
One would register adapters for the "provided" interfaces
<code>IFilterIndex</code>,
<code>IIndexedValue</code>,
<code>IMultiplicityAware</code>,
<code>IIndexed</code>,
<code>IKeyedIndex</code>,
<code>IKeyNormalizingIndex</code>
and optionally for <code>ILookupIndex</code> or
<code>ILookupTreeIndex</code>. Many of those adapters could be
taken over from those for <code>UnIndex</code>. Examples
are in <code>Products.AdvancedQuery.eval.adatper.*index</code>.
<li>The index is fairly complex. In this case, one would likely
do without <code>AdvancedQuery</code> extensions (such as filtering,
<code>Indexed</code> queries, ...) and either define no adapter at all
or define one or several <code>IQueryConverter</code> adapters
for this index. Examples are in <code>Products.AdvancedQuery.eval.adapter.query.converter.*index</code>.
</ol>


<h3>Conditional adaptation</h3>
<p>Whereever this documentation speaks of adaptation, it actually
means "conditional adaptation". A <dfn>conditional adapter</dfn>
is a <code>zope.interface</code>
"subscription adapter" usually with an associated condition. 
<code>Products.AdvancedQuery.eval.adapter</code> contains functions
to define and look up conditional adapters as well as typical
conditions.</p>

<p>The new concept "conditional adapter" is necessary because
Zope's standard adapter concept makes assumptions not valid
in our context.
For example, an adapter defined for an index <var>I</var>
would be considered adequate for any index
<var>J</var> inheriting from <var>I</var>
unless this adapter was overridden by another adapter registered for index
<var>K</var> inheriting from <var>I</var> and either <var>J</var> is
<var>K</var> or inherits from it. The adapters employed by
<code>AdvancedQuery</code> for an index <var>I</var> are typically
not adequate for all indexes <var>J</var> inheriting from <code>I</var>.
If <code>AdvancedQuery</code> would use "normal" adapters,
then such an index <var>J</var> would require the registration
of an adequate overriding adapter for <var>J</var>, otherwise
search results involving <var>J</var> could be wrong. As
Zope's index system is open (flexibly extendable), the risk would
be too great. Therefore,
<code>AdvancedQuery</code> uses conditional adapters with a
condition typically of the form "applicable to index <var>I</var>
and derived indexes provided they do not override any of the following
methods". A conditional adatper is looked up like a "normal" adapter
with the exception that non applicable adapters
are skipped. This makes it possible that a more general adapter
can override a more specific one -- provided that the latter is
not applicable.</p>



    <hr>
    <address><a href="mailto:dieter@handshake.de">Dieter Maurer</a></address>
<!-- Created: Wed May 12 19:27:07 CEST 2004 -->
<!-- hhmts start -->
Last modified: Mon Apr 22 07:50:26 CEST 2019
<!-- hhmts end -->
  </body>
</html>
