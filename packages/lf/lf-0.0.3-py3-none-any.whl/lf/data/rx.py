""" Provides the LFData class and load_rx_data function

LFData holds all data reported by the LF AWESOME receiver and includes several
preprocessing operations.
data_loader provides a quick way of converting the .mat files provided by the
LF AWESOME receiver to a python dictionary.
"""

from datetime import datetime
import numpy as np
from scipy.io import loadmat


class LFData(object):
    """ Manage VLF data for a single transmit-receive path.

    Attributes
    ----------
    latitude : float
        Latitude of the receiver
    longitude : float
        Longitude of the receiver
    altitude : float
        Altitude of the receiver
    Fs : int
        Sampling rate of the data
    gps_quality : int
        Quality of gps signal
    adc_channel_number : int
        Analog->Digital converter channel
    adc_sn : int
        ADC serial number
    adc_type : int
        ADC type
    antenna_bearings : int
        Horizontal angle between antenna and true North
    antenna_description : int
        Antenna Description
    cal_factor : float
        Calibration factor
    computer_sn : int
        Computer serial number
    gps_sn : int
        GPS unit serial number
    hardware_description : str
        Name of receiver unit (generally LF Receiver)
    is_broadband : bool
        True if data is broadband (for single path, expect narrow band)
    station_description : int
        Description of receiver station
    station_name : str
        Name of receiver station
    VERSION : str
        Version number of receiver software/hardware
    is_msk : bool
        Is the incoming signal using msk modulation
    Fc : int
        Carrier frequency of transmitter
    call_sign : str
        Transmitter call sign
    filter_taps : np.array
        Filter coefficients for filtering measured data
    start_time : datetime
        Time at beginning of data recording
    amp_lin : np.array
        Amplitude measurement as a linear value (default)
    amp_db : np.array
        Amplitude measurment in decibels
    phase_deg : np.array
        Phase measurement in degrees (default)
    phase_rad : np.array
        Phase measurement in radians (default)
    data_cx : np.array
        Amplitude-Phase measurements in complex form (x+jy)
    data_real : np.array
        Real part of amplitude-phase measurements
    data_imag : np.array
        Imaginary part of amplitude-phase measurements

    Methods
    -------
    load_mats(mat_files)
        Load 2 .mat files into LFData
    load_dicts(data_dicts)
        Load 2 dictionaries generated by load_rx_data into LFData
    combine_data(data_dicts)
        Combine a set of amplitude-phase data into a single object
    to_real_imag(remove_amp_phase=False)
        Convert class data into real and imaginary components
    to_amp_phase(remove_cx=False, deg=True)
        Convert class data into amplitude and phase components
    to_db(remove_lin=False)
        Convert amplitude data to decibels
    to_lin(remove_db=False)
        Convert amplitude data to linear scale
    to_rad(remove_deg=False)
        Convert phase data to radians
    to_deg(remove_rad=False)
        Convert phase data to degrees

    """

    def __init__(self, mat_files=None, data_dicts=None):
        """ Load in either .mat files or data dictionaries for a single path

        Parameters
        ----------
        mat_files : list of strings, optional
            Two mat files correseponding to amplitude and phase of a path
        data_dicts : list of dictionaries, optional
            Two dictionaries corresponding to amplitude and phase of a path
        """
        if mat_files is not None:
            if data_dicts is not None:
                print(
                    "Both mat_files and data_dicts reported, using mat_files."
                )
            self.load_mats(mat_files)
        elif data_dicts is not None:
            self.load_dicts(data_dicts)

    def load_mats(self, mat_files):
        """ Load .mat files into the LFData object

        Parameters
        ----------
        mat_files : list of strings, optional
            Two mat files correseponding to amplitude and phase of a path

        Returns
        -------
        None

        """
        if len(mat_files) != 2:
            raise ValueError("Only two mat_files are accepted.")
        data = [load_rx_data(mat_files[0]), load_rx_data(mat_files[1])]
        self.combine_data(data)

    def load_dicts(self, data_dicts):
        """ Load data dictionaries into LFData object

        Parameters
        ----------
        data_dicts : list of dictionaries, optional
            Two dictionaries corresponding to amplitude and phase of a path

        Returns
        -------
        None

        """
        if len(data_dicts) != 2:
            raise ValueError("Only two data_dicts are accepted.")
        self.combine_data(data_dicts)

    def combine_data(self, data_list):
        """ Combine amplitude and phase data into a single data structure

        Parameters
        ----------
        data_list : list of dicts
            Two dictionaries containing amplitude and phase data

        Returns
        -------
        None

        """
        # Check whether the two pieces of data are from the same path
        matched_keys = [
            "latitude",
            "longitude",
            "altitude",
            "Fs",
            "gps_quality",
            "adc_channel_number",
            "adc_sn",
            "adc_type",
            "antenna_bearings",
            "antenna_description",
            "cal_factor",
            "computer_sn",
            "gps_sn",
            "hardware_description",
            "is_broadband",
            "station_description",
            "station_name",
            "VERSION",
            "is_msk",
            "Fc",
            "call_sign",
        ]
        for key in matched_keys:
            try:
                if data_list[0][key] != data_list[1][key]:
                    raise ValueError(f"Data differs in {key}")
            except KeyError:
                print(f"Unable to verify {key} values due to missing key")
        try:
            if data_list[0]["is_amp"] == data_list[1]["is_amp"]:
                raise ValueError(
                    f"Duplicate {'amplitude' if data_list[0]['is_amp'] else 'phase'}."
                )
        except KeyError:
            print(
                "Unable to verify duplicate amplitude or phase values due to missing key"
            )

        # Setup class variables for each entry in dictionary
        for key, value in data_list[0].items():
            if key == "data":
                # Split data into amplitude and phase data
                setattr(
                    self,
                    "amp_lin",
                    np.array(value).squeeze()
                    if data_list[0]["is_amp"]
                    else np.array(data_list[1]["data"]).squeeze(),
                )
                setattr(
                    self,
                    "phase_deg",
                    np.array(value).squeeze()
                    if data_list[1]["is_amp"]
                    else np.array(data_list[1]["data"]).squeeze(),
                )
            elif key == "is_amp":
                # Skip is_amp key
                continue
            else:
                setattr(self, key, value)

    def to_real_imag(self, remove_amp_phase=False):
        """ Calculates the real and imaginary components of the data

        Parameters
        ---------
        remove_amp_phase : bool, optinal
            Option to remove the amplitude-phase version of the data to save space

        Returns
        -------
        None

        """
        if hasattr(self, "data_cx"):
            print("Data is already in real and imaginary components")
        else:
            self.data_cx = self.to_lin() * np.exp(1j * self.to_rad())
            self.data_real = np.real(self.data_cx)
            self.data_imag = np.imag(self.data_cx)
        if remove_amp_phase:
            for attr in ["amp_lin", "amp_db", "phase_deg", "phase_rad"]:
                try:
                    delattr(self, attr)
                except AttributeError:
                    continue

    def to_amp_phase(self, remove_cx=False, deg=True):
        """ Calculates the amplitude and phase components of the data

        Paramters
        ---------
        remove_cx : bool, optinal
            Option to remove the real-imaginary version of the data to save space
        deg : bool, optional
            Option to save the data as degrees

        Returns
        -------
        None

        """
        if hasattr(self, "data_cx"):
            self.amp_lin = np.abs(self.data_cx)
            if deg:
                self.phase_deg = np.angle(self.data_cx, deg=True)
            else:
                self.phase_rad = np.angle(self.data_cx)
        elif hasattr(self, "data_real") and hasattr(self, "data_imag"):
            cx = self.data_real + 1j * self.data_imag
            self.amp_lin = np.abs(cx)
            if deg:
                self.phase_deg = np.angle(cx, deg=True)
            else:
                self.phase_rad = np.angle(cx)
        elif hasattr(self, "amp_lin") or hasattr(self, "amp_db"):
            print("Data is already in amplitude and phase")
        else:
            raise AttributeError(
                "You have not loaded any data into this object!"
            )
        if remove_cx:
            for attr in ["data_cx", "data_real", "data_imag"]:
                try:
                    delattr(self, attr)
                except AttributeError:
                    continue

    def to_db(self, remove_lin=False):
        """ Calculates the amplitude in dB

        Paramters
        ---------
        remove_lin : bool, optinal
            Option to remove the linear version of the data to save space

        Returns
        -------
        numpy array or None:
            returns None if data is in real/imag or amp_db otherwise

        """
        if hasattr(self, "amp_lin"):
            self.amp_db = 20 * np.log10(self.amp_lin)
            if remove_lin:
                delattr(self, "amp_lin")
        elif hasattr(self, "amp_db"):
            print("Data is already in dB.")
        elif hasattr(self, "data_cx"):
            print("Data is in real and imaginary components")
            return None
        else:
            raise AttributeError(
                "You have not loaded any data into this object!"
            )
        return self.amp_db

    def to_lin(self, remove_db=False):
        """ Calculates the linear amplitude

        Paramters
        ---------
        remove_db : bool, optinal
            Option to remove the db version of the data to save space

        Returns
        -------
        np.array or None:
            returns None if data is in real/imag or amp_lin otherwise

        """
        if hasattr(self, "amp_db"):
            self.amp_lin = 10 ** (self.amp_db / 20)
            if remove_db:
                delattr(self, "amp_db")
        elif hasattr(self, "amp_lin"):
            print("Data is already in linear.")
        elif hasattr(self, "data_cx"):
            print("Data is in real and imaginary components")
            return None
        else:
            raise AttributeError(
                "You have not loaded any data into this object!"
            )
        return self.amp_lin

    def to_rad(self, remove_deg=False):
        """ Calculates the angle in radians

        Paramters
        ---------
        remove_deg : bool, optinal
            Option to remove the degrees version of the data to save space

        Returns
        -------
        np.array or None:
            returns None if data is in real/imag or phase_rad otherwise

        """
        if hasattr(self, "phase_deg"):
            self.phase_rad = np.deg2rad(self.phase_deg)
            if remove_deg:
                delattr(self, "phase_deg")
        elif hasattr(self, "phase_rad"):
            print("Data is already in radians.")
        elif hasattr(self, "data_cx"):
            print("Data is in real and imaginary components")
            return None
        else:
            raise AttributeError(
                "You have not loaded any data into this object!"
            )
        return self.phase_rad

    def to_deg(self, remove_rad=False):
        """ Calculates the angle in degrees

        Parameters
        ----------
        remove_rad : bool, optional
            Option to remove the radian version of the data to save space

        Returns
        -------
        np.array or None:
            returns None if data is in real/imag or phase_deg otherwise

        """
        if hasattr(self, "phase_rad"):
            self.phase_rad = np.rad2deg(self.phase_deg)
            if remove_rad:
                delattr(self, "phase_rad")
        elif hasattr(self, "phase_deg"):
            print("Data is already in degrees.")
        elif hasattr(self, "data_cx"):
            print("Data is in real and imaginary components")
            return None
        else:
            raise AttributeError(
                "You have not loaded any data into this object!"
            )
        return self.phase_deg


def load_rx_data(mat_file, variables=None, file_check=True):
    """ Properly format an LF AWESOME receiver's output mat file

    Parameters
    ----------
    mat_file : string
        File path to a specific .mat file
    variables : list of strings, optional
        List of variables to be extracted from the .mat file
    file_check : boolean, optional
        Flag to check whether the input mat_file and variables are valid

    Returns
    -------
    dict
        dictionary containing formatted LF Data

    See Also
    --------
    LFData : Data management class
    """
    if file_check:
        validity = check_mat(mat_file, variables)
        if not validity["mat_file"]:
            raise ValueError("Input .mat file is not a valid data file.")
        elif not validity["variables"]:
            raise ValueError(
                "One or more variables are not contained in the .mat file."
            )
    data = loadmat(mat_file, mat_dtype=True, variable_names=variables)
    for key in data:
        if key in [
            "start_year",
            "start_month",
            "start_day",
            "start_hour",
            "start_minute",
            "start_second",
            "Fs",
            "adc_channel_number",
            "antenna_description",
        ]:
            # Should be integers, but aren't by default
            data[key] = int(data[key][0][0])
        elif key in [
            "latitude",
            "longitude",
            "altitude",
            "gps_quality",
            "adc_sn",
            "adc_type",
            "antenna_bearings",
            "cal_factor",
            "computer_sn",
            "gps_sn",
            "station_description",
            "Fc",
        ]:
            # Correct type, but in array
            data[key] = data[key][0][0]
        elif key in ["is_amp", "is_msk", "is_broadband"]:
            # Should be boolean
            data[key] = bool(data[key][0][0])
        elif key in [
            "hardware_description",
            "station_name",
            "call_sign",
            "VERSION",
        ]:
            # Should be strings, but are in array of ascii
            data[key] = "".join(chr(char) for char in data[key])
    time_vals = [
        "start_year",
        "start_month",
        "start_day",
        "start_hour",
        "start_minute",
        "start_second",
    ]
    # If all of the time data is loaded, create a datetime object
    if (variables is None) or all(elem in variables for elem in time_vals):
        data["start_time"] = datetime(
            data.pop("start_year"),
            data.pop("start_month"),
            data.pop("start_day"),
            data.pop("start_hour"),
            data.pop("start_minute"),
            data.pop("start_second"),
        )

    return data


def check_mat(mat_file, variables=None):
    """ Check if a .mat file is a valid LF data mat file

    Parameters
    ----------
    mat_file : string
        Path to .mat file
    variables : list of str, optional
        List of variables of interest

    Returns
    -------
    Dict
        Dictionary of booleans for the validity of the mat_file and variables

    """
    data = loadmat(mat_file)
    expected_keys = [
        "latitude",
        "longitude",
        "altitude",
        "Fs",
        "gps_quality",
        "adc_channel_number",
        "adc_sn",
        "adc_type",
        "antenna_bearings",
        "antenna_description",
        "cal_factor",
        "computer_sn",
        "gps_sn",
        "hardware_description",
        "is_broadband",
        "station_description",
        "station_name",
        "VERSION",
        "is_amp",
        "is_msk",
        "Fc",
        "call_sign",
        "filter_taps",
        "data",
        "start_second",
        "start_minute",
        "start_hour",
        "start_day",
        "start_month",
        "start_year",
    ]
    validity = {}
    validity["mat_file"] = True
    validity["variables"] = True
    if set(data.keys()) != set(expected_keys):
        validity["mat_file"] = False
    if variables is not None:
        if not all(elem in expected_keys for elem in variables):
            validity["variables"] = False
    return validity
