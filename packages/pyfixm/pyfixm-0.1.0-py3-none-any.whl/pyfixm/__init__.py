#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sun Feb  9 08:33:58 2020 by generateDS.py version 2.35.12.
# Python 3.8.1 (default, Dec 30 2019, 15:43:37)  [GCC 9.2.0]
#
# Command line options:
#   ('-o', '/pyfixm/__init__.py')
#   ('-s', '/pyfixm/subs.py')
#
# Command line arguments:
#   /xsd/base_schema.xsd
#
# Command line:
#   /usr/bin/generateDS -o "/pyfixm/__init__.py" -s "/pyfixm/subs.py" /xsd/base_schema.xsd
#
# Current working directory (os.getcwd()):
#   pyfixm
#

from six.moves import zip_longest
import os
import sys
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ImportError:

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return ('%0.10f' % input_data).rstrip('0')
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class AbrogationReasonCodeType(Enum):
    """.Abrogation Reason: If the Coordination Status is abrogated, indicating
    coordination
    is abolished by authoritative action, the reason the coordination was
    terminated."""
    TFL='TFL'
    ROUTE='ROUTE'
    CANCELLATION='CANCELLATION'
    DELAY='DELAY'
    HOLD='HOLD'


class AdvisoryTypeType(Enum):
    """.Traffic Flow Management Advisory Number: Advisory number issued by
    traffic flow
    management.
    .Traffic Flow Management Advisory Type: The type for the advisory issued by
    traffic
    flow management."""
    GDP='GDP' # Ground Delay Program Advisory
    AFP='AFP' # Airspace Flow Program Advisory
    GDP_CANCEL='GDP_CANCEL' # Ground Delay Program cancellation Advisory
    AFP_CANCEL='AFP_CANCEL' # Airspace Flow Program Cancellation Advisory
    GS='GS' # Ground Stop Program Advisory
    GS_CANCEL='GS_CANCEL' # Ground Stop Program cancellation Advisory
    REROUTE='REROUTE' # Reroute Advisory
    CTOP='CTOP' # Collaborative Trajectory Options Program Advisory
    CTOP_CANCEL='CTOP_CANCEL' # Collaborative Trajectory Options Program cancellation Advisory


class AirTrafficTypeType(Enum):
    """The type of flight value associated with the point. It is associated
    with the first
    point on the route and any subsequent point where the type of flight value
    changes."""
    OAT='OAT' # Operational Air Traffic: Military and State operations not subject to civil ATC procedures but are ICAO recognized operations.
    GAT='GAT' # General Air Traffic: ICAO civil type operations.


class AirborneHoldIndicatorType(Enum):
    """.Hold State - Airborne Indicator: Specifies whether or not the aircraft
    is in an
    airborne hold."""
    AIRBORNE_HOLD='AIRBORNE_HOLD'
    NOT_AIRBORNE_HOLD='NOT_AIRBORNE_HOLD'


class AircraftDangerousGoodsLimitationType(Enum):
    """.Aircraft Dangerous Goods Limitation: Describes whether the shipment is
    packed to
    comply with the limitations prescribed for passenger and cargo aircraft or
    the limitations
    for cargo aircraft only."""
    PASSENGER_AND_CARGO_AIRCRAFT='PASSENGER_AND_CARGO_AIRCRAFT' # Specified that the shipment is packed to comply with the limitations prescribed for passenger and cargo aircraft.
    CARGO_AIRCRAFT_ONLY='CARGO_AIRCRAFT_ONLY' # Specified that the shipment is packed to comply with the limitations prescribed for the limitations for cargo aircraft only.


class AircraftPerformanceCategoryType(Enum):
    """.Aircraft Performance Category: A coded category assigned to the
    aircraft based on
    a speed directly proportional to its stall speed, which functions as a
    standardized
    basis for relating aircraft manoeuvrability to specific instrument approach
    procedures."""
    A='A'
    B='B'
    C='C'
    D='D'
    E='E'
    H='H'


class AirfileIndicatorType(Enum):
    """.Airfile Indicator: An indication the information about this flight was
    filed from
    the air."""
    AIRFILE='AIRFILE'


class AirspaceTypeType(Enum):
    """Indicates the type of airspsace."""
    SECTOR='SECTOR'
    FIR='FIR'


class AirspeedMeasureType(Enum):
    """Provides units of measure for airspeeds."""
    KILOMETRES_PER_HOUR='KILOMETRES_PER_HOUR' # Indicates airspeed measured in kilometers per hour.
    KNOTS='KNOTS' # Indicates airspeed measured in knots.
    MACH='MACH' # Indicates airspeed measured using Mach number.


class AltitudeMeasureType(Enum):
    """Unit of measurement for altitudes"""
    FEET='FEET' # Unit of measurement for altitudes
    METRES='METRES' # Unit of measurement for altitudes


class AltitudeQualifierType(Enum):
    """Specifies that the altitude specified in the ClimbToLevelConstraint is
    not a maximum
    altitude, and aircraft may climb to a higher level."""
    AT_OR_ABOVE_ALTITUDE='AT_OR_ABOVE_ALTITUDE' # Specifies that the altitude specified in the ClimbToLevelConstraint is not a maximum altitude, and aircraft may climb to a higher level


class AltitudeReferenceType(Enum):
    """Reference point for altitude measurement."""
    MEAN_SEA_LEVEL='MEAN_SEA_LEVEL' # Reference point for altitude measurement.
    FLIGHT_LEVEL='FLIGHT_LEVEL' # Reference point for altitude measurement.


class AngleMeasureType(Enum):
    """Units of measure for the Angle type."""
    DEGREES='DEGREES'


class AssignedIndicatorType(Enum):
    """.Ranked 4D Trajectory Assignment Status: An indication whether the
    Ranked 4D trajectory
    has been assigned by the Air Navigation Service Provider (ANSP)."""
    ASSIGNED='ASSIGNED'


class BoundaryCrossingConditionType(Enum):
    """.Boundary Crossing Condition: Indicator of whether an aircraft will
    cross an associated
    boundary crossing point at or above, or at or below the altitude specified
    by the
    Boundary Crossing Level - Transition."""
    AT_OR_ABOVE='AT_OR_ABOVE' # Indicates that the transition altitude is at or above the specified.
    AT_OR_BELOW='AT_OR_BELOW' # Indicates that the transition altitude is at or below the specified.


class ClassifiedSpeedIndicatorType(Enum):
    """.Classified Speed Indicator: The indication that the speed for this
    flight is classified
    and is not to be recorded."""
    CLASSIFIED='CLASSIFIED'


class ClearanceLimitIndicatorType(Enum):
    """.Clearance Limit: The point to which an aircraft is granted an air
    traffic control
    clearance."""
    CLEARANCE_LIMIT='CLEARANCE_LIMIT'


class CmsAccuracyTypeType(Enum):
    """.Performance-Based Navigation Category: This is an enumeration
    indicating whether
    the accuracy measure in Performance-Based Navigation Accuracy is measuring
    Area Navigation
    (RNAV) or Required Navigation Performance (RNP)."""
    RNV='RNV'
    RNP='RNP'


class CommunicationCodeType(Enum):
    """Describes the aircraft communication code."""
    E_1='E1'
    E_2='E2'
    E_3='E3'
    H='H'
    M_1='M1'
    M_2='M2'
    M_3='M3'
    P_1='P1'
    P_2='P2'
    P_3='P3'
    P_4='P4'
    P_5='P5'
    P_6='P6'
    P_7='P7'
    P_8='P8'
    P_9='P9'
    U='U'
    V='V'
    Y='Y'


class ConstraintOrPreferenceCategoryType(Enum):
    """.Constraint Category: Specifies the category (implying a relative
    importance) of
    the constraint associated with a point in the route or expanded route."""
    EXECUTIVE_CONTROL='EXECUTIVE_CONTROL'
    CONTROLLER_TACTICAL_PLANNING='CONTROLLER_TACTICAL_PLANNING'
    NETWORK_STRATEGIC='NETWORK_STRATEGIC'
    OPERATOR_CONSTRAINT='OPERATOR_CONSTRAINT'
    FLIGHT_PLAN_EXPECTATION='FLIGHT_PLAN_EXPECTATION'


class CoordinationStatusCodeType(Enum):
    """.Coordination Status: The status of Coordination and Transfer of Control
    between
    the currently Controlling Air Traffic Service Unit (ATSU) to the downstream
    to be
    Controlling ATSU."""
    NOTIFIED='NOTIFIED'
    OFFERED='OFFERED'
    RENEGOTIATE_REQUESTED='RENEGOTIATE_REQUESTED'
    RENEGOTIATE_REJECTED='RENEGOTIATE_REJECTED'
    COORDINATED='COORDINATED'
    REJECTED='REJECTED'
    REQUESTED_ON_FREQUENCY='REQUESTED_ON_FREQUENCY'
    ASSUMED='ASSUMED'
    BACKWARD_COORDINATING='BACKWARD_COORDINATING'
    BACKWARD_COORDINATING_REJECTED='BACKWARD_COORDINATING_REJECTED'
    BACKWARD_COORDINATING_ACCEPTED='BACKWARD_COORDINATING_ACCEPTED'
    ABROGATED='ABROGATED'
    ATSU_SKIPPED='ATSU_SKIPPED'
    FREQUENCY_CHANGED='FREQUENCY_CHANGED'
    RELEASE_REQUESTED='RELEASE_REQUESTED'
    RELEASE_REJECTED='RELEASE_REJECTED'
    RELEASED='RELEASED'
    MANUALLY_REFERRED='MANUALLY_REFERRED'


class CoordinationTimeTypeType(Enum):
    """.Coordination Time Type: The indicator for the type of Coordination Time
    ."""
    P='P' # Proposed flight plan preparing for departure
    D='D' # Flight plan has departed from the departure airport
    E='E' # Active flight plan, aircraft is flying.


class CpdlcConnectionStatusType(Enum):
    """.CPDLC Connection Status: Provides the aircraft s Controller Pilot Data
    Link Communications
    (CPDLC) Connection status and optional frequency information."""
    NO_CONNECTION='NO_CONNECTION'
    CONNECTION_FAILED='CONNECTION_FAILED'
    CONNECTION_ESTABLISHED='CONNECTION_ESTABLISHED'


class CpdlcStartRequestIndicatorType(Enum):
    """.CPDLC Start Request Indicator: For a flight crossing the boundary from
    one facility
    to the next, notifies the data link equipped unit it can send a CPDLC Start
    Request
    to the aircraft, because the aircraft is authorized to accept a CPDLC
    connection
    request from the receiving unit."""
    SEND_CPDLC_START_REQUEST='SEND_CPDLC_START_REQUEST'


class DataLinkCodeType(Enum):
    """.Data Link Communication Capabilities: The serviceable equipment and
    capabilities
    available on the aircraft at the time of flight that may be used to
    communicate data
    to and from the aircraft."""
    J_1='J1'
    J_2='J2'
    J_3='J3'
    J_4='J4'
    J_5='J5'
    J_6='J6'
    J_7='J7'


class DeicingIntentType(Enum):
    """.Deicing Intent: Indicates the intent for the flight to be deiced."""
    DEICE='DEICE' # .Deicing Intent: Indicates the intent for the flight to be deiced.
    NO_DEICE='NO_DEICE' # .Deicing Intent: Indicates the intent for the flight to be deiced.


class DelegatedUnitIndicatorType(Enum):
    """.Delegated Unit Indicator: Indicates whether or not the controlling unit
    has been
    delegated authority for the flight based on agreement with the unit in
    whose Area
    of Responsibility (AOR) the flight is currently located"""
    AUTHORITY_DELEGATED='AUTHORITY_DELEGATED' # If present, indicates that the controlling unit has been delegated authority for the flight.


class DinghyColourCodeType(Enum):
    """.Dinghy Color: The color of the dinghies carried by the aircraft."""
    RED='RED'
    ORANGE='ORANGE'
    YELLOW='YELLOW'
    GREEN='GREEN'
    BLUE='BLUE'
    VIOLET='VIOLET'
    BLACK='BLACK'
    WHITE='WHITE'
    GRAY='GRAY'
    SILVER='SILVER'


class DinghyCoverType(Enum):
    """.Dinghy Cover Status: Indication of the covered/uncovered nature of the
    dinghies
    carried by the aircraft."""
    COVERED='COVERED'


class DirectionReferenceType(Enum):
    """Indicates direction relative to True North or Magnetic North"""
    TRUE='TRUE' # This value indicates that the direction is relative to True North.
    MAGNETIC='MAGNETIC' # This value indicates that the direction is relative to Magnetic North.


class DistanceMeasureType(Enum):
    """Indicates the units of measures for a Distance."""
    NAUTICAL_MILES='NAUTICAL_MILES' # Indicates distance is measured in nautical miles.
    MILES='MILES' # Indicates distance is measured in miles.
    KILOMETERS='KILOMETERS' # Indicates distance is measured in kilometers.


class EmergencyPhaseType(Enum):
    """.Emergency Phase: Stage of emergency the flight is currently under or an
    indication
    the emergency has been cancelled, as designated by an ATS unit."""
    INCERFA='INCERFA'
    ALERFA='ALERFA'
    DETRESFA='DETRESFA'
    CANCELLED='CANCELLED'


class EmergencyRadioCodeType(Enum):
    """.Emergency Radio Transmitter Type: The type of serviceable communication
    devices
    available on the aircraft that are able to transmit an emergency radio
    signal."""
    ULTRA_HIGH_FREQUENCY='ULTRA_HIGH_FREQUENCY'
    VERY_HIGH_FREQUENCY='VERY_HIGH_FREQUENCY'
    EMERGENCY_LOCATOR_TRANSMITTER='EMERGENCY_LOCATOR_TRANSMITTER'


class EngineTypeType(Enum):
    """.Engine Type: The category of the aircraft engine."""
    PISTON='PISTON'
    TURBO_PROP='TURBO_PROP'
    TURBO_SHAFT='TURBO_SHAFT'
    TURBO_JET='TURBO_JET'
    TURBO_FAN='TURBO_FAN'
    PROP_FAN='PROP_FAN'


class FissileExceptedType(Enum):
    """.Fissile Excepted Indicator: An indicator of whether the restrictions
    for fissile
    material are excepted for a particular package."""
    EXCEPTED='EXCEPTED' # Indicates the restrictions for fissile material are excepted for a particular package.


class FlightAcceptedIndicatorType(Enum):
    """.Flight Plan Accepted: An indicator of acceptance of the flight plan by
    the appropriate
    ATS authority.
    .Flight Plan Accepted Indicator: An indicator of acceptance of the flight
    plan by
    the appropriate ATS authority."""
    ACCEPTED='ACCEPTED'


class FlightCycleType(Enum):
    """Flight Cycle is contains a mutually exclusive set of values representing
    stages of
    flight.
    .Flight Completed Indicator: An indicator that the flight was airborne and
    is now
    completed.
    .Flight Cancelled Indicator: Indication the flight has been cancelled after
    Flight
    Object creation.
    .Flight Filed Indicator: An indicator that flight information was filed to
    the appropriate
    Air Traffic Services authority.
    .Airborne Indicator: An indication of whether the flight is airborne or
    not.
    .Flight Scheduled Indicator: An indicator a flight has been created in the
    Air Traffic
    Services system and is expected to operate."""
    FILED='FILED'
    SCHEDULED='SCHEDULED'
    AIRBORNE='AIRBORNE'
    COMPLETED='COMPLETED'
    CANCELLED='CANCELLED'


class FlightRulesType(Enum):
    """The regulation, or combination of regulations, that governs all aspects
    of operations
    under which the pilot plans to fly."""
    IFR='IFR' # Instrument Flight Rules
    VFR='VFR' # Visual Flight Rules


class FlightSuspendedIndicatorType(Enum):
    """.Flight Suspended Indicator: An indicator a flight has been suspended in
    the Air
    Traffic Services system."""
    SUSPENDED='SUSPENDED'
    NOT_SUSPENDED='NOT_SUSPENDED'


class FrequencyMeasureType(Enum):
    """Radio frequency unit of measure. Either kHz OR MHz."""
    MEGAHERTZ='MEGAHERTZ' # Indicates this radio frequency is measured in MHz.
    KILOHERTZ='KILOHERTZ' # Indicates this radio frequency is measured in kHz.


class FrequencyUsageType(Enum):
    """.Frequency Usage: The usage of the frequency."""
    VOICE='VOICE'
    CPDLC='CPDLC'


class GroundspeedMeasureType(Enum):
    """Qualifies the Groundspeed type with metric or imperial units of
    measure."""
    KILOMETRES_PER_HOUR='KILOMETRES_PER_HOUR' # Indicates groundspeed is measured in kilometers per hour.
    KNOTS='KNOTS' # Indicates groundspeed is measured in knots.


class HoldIntentType(Enum):
    """.Airport Movement Area Holding Intent - Departure: Indicates the intent
    for a departing
    flight to hold in the airport movement area when surface departure metering
    or other
    Traffic Management Initiatives are in effect.
    .Airport Movement Area Holding Intent - Arrival: Indicates the intent for
    an arriving
    flight to hold in the airport movement area due to unavailability of a
    parking stand
    or ramp access."""
    HOLD='HOLD' # Indicates the intent is to hold .Airport Movement Area Holding Intent - Arrival: Indicates the intent for an arriving flight to hold in the airport movement area due to unavailability of a parking stand or ramp access. .Airport Movement Area Holding Intent - Departure : Indicates the intent for a departing flight to hold in the airport movement area when surface departure metering or other Traffic Management Initiatives are in effect.
    NO_HOLD='NO_HOLD' # Indicates the intent is not to hold .Airport Movement Area Holding Intent - Arrival: Indicates the intent for an arriving flight to hold in the airport movement area due to unavailability of a parking stand or ramp access. .Airport Movement Area Holding Intent - Departure : Indicates the intent for a departing flight to hold in the airport movement area when surface departure metering or other Traffic Management Initiatives are in effect.


class InvalidIndicatorType(Enum):
    """Indicates whether target altitude is invalid."""
    INVALID='INVALID'


class LandingLimitsType(Enum):
    """.Landing Limits: The landing qualification of the flight, considering
    crew and equipment."""
    I='I'
    II='II'
    III='III'
    IIIA='IIIA'
    IIIB='IIIB'
    IIIC='IIIC'


class LengthMeasureType(Enum):
    """Provides units of measure for length (and height, width)."""
    FEET='FEET' # Indicates length is measured in feet.
    INCHES='INCHES' # Indicates length is measured in inches.
    METRES='METRES' # Indicates length is measured in meters.
    CENTIMETRES='CENTIMETRES' # Indicates length is measured in centimeters.
    MILLIMETRES='MILLIMETRES' # Indicates length is measured in millimeters.


class LifeJacketCodeType(Enum):
    """.Life Jacket Type: The type of life jackets available on board the
    aircraft."""
    FLUORESCEIN='FLUORESCEIN'
    VERY_HIGH_FREQUENCY='VERY_HIGH_FREQUENCY'
    LIGHTS='LIGHTS'
    ULTRA_HIGH_FREQUENCY='ULTRA_HIGH_FREQUENCY'


class ManualOverrideIndicatorType(Enum):
    """.Trajectory Manual Override Status: An indication whether a trajectory
    was either
    selected manually by a traffic manager from the available trajectory
    options or was
    entered manually by a traffic manager."""
    MANUAL_OVERRRIDE='MANUAL_OVERRRIDE'


class MarinePollutantIndicatorType(Enum):
    """.Marine Pollutant Indicator: An indicator if the transported dangerous
    goods have
    marine pollutant content."""
    MARINE_POLLUTANT='MARINE_POLLUTANT' # Indicates the transported dangerous goods have marine pollutant content.


class MaterialDispersabilityType(Enum):
    """.Low Dispersible Material Indicator: An indicator the dangerous good is
    a low dispersible
    radioactive material, a solid radioactive material or a solid radioactive
    material
    in a sealed capsule, which has limited dispersibility and is not in powder
    form."""
    LOW_DISPERSIBLE='LOW_DISPERSIBLE' # Indicates that the dangerous good is either (1) a low dispersible radioactive material, (2) a solid radioactive material, or (3) a solid radioactive material in a sealed capsule which has limited dispersibility and is not in powder form.


class MissedApproachIndicatorType(Enum):
    """.Missed Approach Indicator: An indicator that a flight executed a missed
    approach."""
    MISSED_APPROACH='MISSED_APPROACH'


class NasAirborneEquipmentQualifierType(Enum):
    """.Airborne Equipment Qualifier: A value assigned to the aircraft, based
    on its navigational
    equipment, whether or not it has a transponder, and if it has a
    transponder, whether
    the transponder supports Mode C."""
    X='X' # No RVSM, No DME, No transponder
    T='T' # No RVSM, No DME, Transponder with no mode C
    U='U' # No RVSM, No DME: Transponder with mode C
    D='D' # DME: No transponder
    B='B' # DME: Transponder with no mode C
    A='A' # DME: Transponder with mode C
    M='M' # TACAN ONLY: No transponder
    N='N' # TACAN ONLY: Transponder with no mode C
    P='P' # TACAN ONLY: Transponder with mode C
    Y='Y' # LORAN,VORDME,INS,RNAV: No transponder
    C='C' # LORAN,VORDME,INS,RNAV: Transponder with no mode C
    I='I' # LORAN,VORDME,INSRNAV: Transponder with mode C
    H='H' # RVSM, Failed transponder or Failed Mode C capability
    S='S' # ADVANCED RNAV, TRANSPONDER, MODE C: FMS with DMEDME position updating
    G='G' # ADVANCED RNAV, TRANSPONDER, MODE C: Global Navigation Satellite System (GNSS), including GPS or Wide Area Augmentation System (WAAS), with en?route and terminal capability.
    V='V' # ADVANCED RNAV, TRANSPONDER, MODE C: Required Navigational Performance (RNP). The aircraft meets the RNP type prescribed for the route segments, routes and/or area concerned
    Z='Z' # REDUCED VERTICAL SEPARATION MINIMUM (RVSM): E with RVSM
    L='L' # REDUCED VERTICAL SEPARATION MINIMUM (RVSM): G with RVSM
    W='W' # REDUCED VERTICAL SEPARATION MINIMUM (RVSM): RVSM


class NasCoastIndicatorType(Enum):
    """.Coast Indicator: An indicator the aircraft was unexpectedly not
    detected by radar
    (after a period of tracking)."""
    COASTING='COASTING'


class NasFlightClassType(Enum):
    """.Flight Class: Denotes the flight class of the aircraft which is
    determined by the
    aircraft call sign that is in the Aircraft Situation Display to Industry
    (ASDI) feed."""
    GA='GA' # General Aviation
    LIFEGUARD='LIFEGUARD' # air ambulance services or other flights involving the safety of life
    TAXI='TAXI' # taxi flights
    CANADIAN_GA='CANADIAN_GA' # Canadian General Aviation
    MILITARY='MILITARY' # Military flight


class NasFlightRulesType(Enum):
    """.Flight Rules - NAS: The regulation, or combination of regulations, that
    governs
    all aspects of operations under which the pilot plans to fly in the NAS."""
    IFR='IFR' # Instrument Flight Rules
    VFR='VFR' # Visual Flight Rules
    DVFR='DVFR' # Defense Visual Flight Rules


class NasHandoffEventType(Enum):
    """.Handoff Event Category: Characterizes a handoff in terms of its
    status."""
    INITIATION='INITIATION'
    ACCEPTANCE='ACCEPTANCE'
    RETRACTION='RETRACTION'
    TAKE_CONTROL='TAKE_CONTROL'
    UPDATE='UPDATE'
    FAILURE='FAILURE'


class NasPerformanceBasedNavigationPhaseType(Enum):
    """.Performance-Based Navigation Phase: The phase of flight for which
    navigation performance
    is being recorded."""
    DEPARTURE='DEPARTURE'
    ARRIVAL='ARRIVAL'
    ENROUTE='ENROUTE'
    OCEANIC='OCEANIC'
    SPARE__1='SPARE_1'
    SPARE__2='SPARE_2'


class NasSpecialAircraftQualifierType(Enum):
    """.Special Aircraft Qualifier: Indicates the flight is a heavy jet, B757
    or, if not
    present, a large jet and if the flight is either equipped or not with TCAS.
    This
    indicator is used for output purposes such as strip printing and message
    transfers
    to other facilities such as Automated Radar Terminal System (ARTS)."""
    HEAVY_JET='HEAVY_JET' # Capable of takeoff weights of 300,000 pounds or more
    TCAS='TCAS' # Traffic collision avoidance system or traffic alert and collision avoidance system
    B_757='B757' # Controllers are required to apply the special wake turbulence separation criteria for the Boeing 757.
    B_757_TCAS='B757_TCAS' # Boeing 757 with traffic collision avoidance system
    HEAVY_JET_AND_TCAS='HEAVY_JET_AND_TCAS' # Capable of takeoff weights of 300,000 pounds or more and traffic collision avoidance system.


class NavigationCodeType(Enum):
    """Describes the aircraft navigation code."""
    A='A'
    B='B'
    C='C'
    D='D'
    F='F'
    G='G'
    I='I'
    K='K'
    L='L'
    O='O'
    T='T'
    W='W'
    X='X'


class NonStandardCoordinationReasonType(Enum):
    """.Reason for Non-Standard Coordination: In case of non-standard
    coordination, the
    reason for non-standard coordination is indicated."""
    LATE_ACTIVATION='LATE_ACTIVATION'
    LATERAL_DEVIATION='LATERAL_DEVIATION'
    LATE_REVISION='LATE_REVISION'
    NON_STANDARD_TFL='NON_STANDARD_TFL'
    NON_STANDARD_EQUIPMENT='NON_STANDARD_EQUIPMENT'
    NON_STANDARD_SSR_CODE='NON_STANDARD_SSR_CODE'
    TRANSITION_POINT='TRANSITION_POINT'


class OfftrackDirectionType(Enum):
    """Specifies the direction of the lateral offset offset."""
    LEFT='LEFT'
    RIGHT='RIGHT'


class OfftrackReasonType(Enum):
    """The reason for boundary crossing offset deviation."""
    OFFSET='OFFSET' # Indicates that the reason for offtrack is offset.
    DEVIATION='DEVIATION' # Indicates that the reason for offtrack is DEVIATION. For example, a likely reason for deviation is weather.


class OperatorCategoryType(Enum):
    """.Flight Operator Category: The category of the flight operator operating
    the flight."""
    AIR_CARRIER='AIR_CARRIER'
    FREIGHT_CARGO_CARRIER='FREIGHT_CARGO_CARRIER'
    GENERAL_AVIATION='GENERAL_AVIATION'
    MILITARY='MILITARY'
    AIR_TAXI='AIR_TAXI'
    OTHER='OTHER'


class OverpackIndicatorType(Enum):
    """.Overpack Indicator: An indicator that individual packages are assembled
    into a single
    unit for handling."""
    OVERPACK_USED='OVERPACK_USED' # Indicates that individual packages are assembled into a single unit for handling.


class PackingGroupType(Enum):
    """.Packing Group: A code that indicates the relative degree of danger
    presented by
    various articles and substances within a Class or Division."""
    I='I' # Represents high danger.
    II='II' # Represents medium danger.
    III='III' # Represents low danger.


class PerformanceBasedCodeType(Enum):
    """.Performance-Based Navigation Capabilities: A coded category denoting
    which Required
    Navigation Performance (RNP) and Area Navigation (RNAV) requirements can be
    met by
    the aircraft while operating in the context of a particular airspace when
    supported
    by the appropriate navigation infrastructure."""
    A_1='A1'
    B_1='B1'
    B_2='B2'
    B_3='B3'
    B_4='B4'
    B_5='B5'
    B_6='B6'
    C_1='C1'
    C_2='C2'
    C_3='C3'
    C_4='C4'
    D_1='D1'
    D_2='D2'
    D_3='D3'
    D_4='D4'
    L_1='L1'
    O_1='O1'
    O_2='O2'
    O_3='O3'
    O_4='O4'
    S_1='S1'
    S_2='S2'
    T_1='T1'
    T_2='T2'


class PositionQualifierType(Enum):
    """Qualifies the position associated with the constraint."""
    AT_OR_BEFORE_POINT='AT_OR_BEFORE_POINT'
    AT_POINT='AT_POINT'
    AT_OR_AFTER_POINT='AT_OR_AFTER_POINT'


class PositionReportSourceType(Enum):
    """.Current Position Report Source: The source of the current position
    report information."""
    PROGRESS_REPORT='PROGRESS_REPORT'
    SURVEILLANCE='SURVEILLANCE'


class PressureMeasureType(Enum):
    """Units of measurement for the pressure value."""
    ATMOSPHERES='ATMOSPHERES' # Atmosphere.
    BAR='BAR' # Bar.
    HECTOPASCAL='HECTOPASCAL' # Hectopascal.
    PASCAL='PASCAL' # Pascal.
    POUNDS_PER_SQUARE_INCH='POUNDS_PER_SQUARE_INCH' # Pounds per square inch.
    TORR='TORR' # Torr.
    MILLIBAR='MILLIBAR' # Millibar.
    INCHES_OF_MERCURY='INCHES_OF_MERCURY' # Inches of mercury


class RVSMFlightIndicatorType(Enum):
    """Current and Future RVSM Flight Compliance
    .Future RVSM Flight Compliance: Indicates if the flight will beReduced
    Vertical Separation
    Minimum (RVSM) compliant when it reaches the RVSM airspace as determined by
    the Traffic
    Flow Management System (TFMS).
    .Current RVSM Flight Compliance: Indicates if the flight is currently
    Reduced Vertical
    Separation Minimum (RVSM) compliant in RVSM airspace, as determined by the
    Traffic
    Flow Management System."""
    COMPLIANT='COMPLIANT' # Indicates that the Flight is RVSM compliant.


class RadioactiveMaterialCategoryType(Enum):
    """.Radioactive Material Category: A category used for radioactive
    materials in a package,
    overpack or freight container, based on their maximum radiation level."""
    I_WHITE='I_WHITE' # .Surface radiation &lt;0.5 millirem/hr, 1 meter radiation: N/A
    II_YELLOW='II_YELLOW' # .Surface radiation &lt;50 millirem/hr, 1 meter radiation &lt;1 millirem/hr
    III_YELLOW='III_YELLOW' # .Surface radiation &gt;50 millirem/hr, 1 meter radiation &gt;1 millirem/hr


class RadioactivityMeasureType(Enum):
    """Units of measure of for RadioactiveMaterialActivity."""
    GRAMS='GRAMS' # NOT a valid measure of a material's radioactivity, but included here to keep in line with the Data Dictionary.
    BECQUERELS='BECQUERELS' # The SI unit of radioactive activity (replaces "curie").


class ReleaseConditionsType(Enum):
    """.Release Conditions: When the flight is released from the agreed
    transfer conditions,
    contains the Release conditions specified by the transferring ATSUs. The
    Release
    conditions indicate the type of manoeuvres the flight is released to
    perform."""
    CLIMB='CLIMB'
    DESCENT='DESCENT'
    TURNS='TURNS'
    FULL='FULL'


class RerouteInclusionIndicatorType(Enum):
    """.Traffic Flow Management System Reroute Inclusion Indicator: Indicates
    whether the
    flight is included or proposed to be included in the traffic management
    reroute initiative."""
    INCLUDED='INCLUDED' # Indicates whether the flight is included or proposed to be included in the traffic management reroute initiative.


class RerouteTypeType(Enum):
    """.Traffic Flow Management System Reroute Identifier: Traffic Flow
    Management System
    generated unique identifier for the reroute.
    .Traffic Flow Management System Reroute Name: Traffic Flow Management
    System assigned
    name for the reroute.
    .Traffic Flow Management System Reroute Type: Route type of the assigned
    reroute."""
    BLANK='BLANK' # blank entry (for EXPLICIT selection)
    CDR_RTE='CDR_RTE' # Coded Departure Route (retrieved from the CDR db)
    REROUTE='REROUTE' # Reroute (manually updated reroute)
    UPT_RTE='UPT_RTE' # User Preferred Trajectory Route (user submitted early intent route)
    UNKNOWN='UNKNOWN' # Unknown Route


class SfdpsFlightStatusType(Enum):
    """Represents the current status of the flight as specified by the SWIM
    SFDPS.
    .SFDPS Flight Status: Identification of the current aspect of the flight
    life cycle
    as determined by the SWIM Flight Data Publication Service (SFDPS)."""
    PROPOSED='PROPOSED' # There is at least one non-cancelled flight plan in place and the flight has not yet become airborne.
    ACTIVE='ACTIVE' # Flight is airborne and updates are still being generated for the flight.
    COMPLETED='COMPLETED' # Flight has landed at its destination.
    CANCELLED='CANCELLED' # There are only cancelled flight plans for the flight and it was never airborne.
    DROPPED='DROPPED' # Data updates terminated before the flight landed. It is unknown whether the flight is still airborne or not. This could be a flight that has left FAA airspace or a flight that has switched to Visual Flight Rules.


class ShipmentTypeType(Enum):
    """.Shipment Type: An indicator used for dangerous cargo of whether the
    package is radioactive
    or not."""
    RADIOACTIVE='RADIOACTIVE' # When present, indicates cargo is radioactive.


class ShipmentUseType(Enum):
    """.Exclusive Use Shipment Indicator: An indicator of sole use, by a single
    shipper,
    of an aircraft or of a large freight container, of which all initial,
    intermediate
    and final loading and unloading is carried out in accordance with the
    directions
    of the shipper or consignee."""
    EXCLUSIVE='EXCLUSIVE' # Indicates of sole use, by a single shipper, of an aircraft or of a large freight container, of which all initial, intermediate and final loading and unloading is carried out in accordance with the directions of the shipper or consignee.


class SlotHoldStatusType(Enum):
    """.Slot Hold Status: If a flight is controlled and cancelled [e.g., has a
    Controlled
    Time of Departure (CTD), Controlled Time of Arrival (CTA), and Arrival Slot
    (ASLOT)],
    the slot hold status indicates whether the slot associated with this flight
    is being
    held, or would be held, by the Airspace User for the next full
    compression."""
    HOLD='HOLD'
    RELEASE='RELEASE'


class SlotYieldedIndicatorType(Enum):
    """.Yielded Slot Indicator: Indicates the slot currently specified in
    Runway Arrival
    Time - Controlled is to be given up by the Airspace User in return for a
    later
    slot."""
    SLOT_YIELDED='SLOT_YIELDED' # .Yielded Slot Indicator : Indicates the slot currently specified in "Runway Arrival Time - Controlled" is to be given up by the Airspace User in return for a later slot.


class SpecialFormType(Enum):
    """.Special Form Indicator: A notation that the material is 'special form'
    and cannot
    produce radioactive contamination."""
    SPECIAL_FORM='SPECIAL_FORM' # Indicates that the material is 'special form' and cannot produce radioactive contamination.


class SpecialHandlingCodeType(Enum):
    """.Special Handling Reason: A property of the flight that requires ATS
    units to give
    it special consideration."""
    ALTRV='ALTRV'
    ATFMX='ATFMX'
    FFR='FFR'
    FLTCK='FLTCK'
    HAZMAT='HAZMAT'
    HEAD='HEAD'
    HOSP='HOSP'
    HUM='HUM'
    MARSA='MARSA'
    MEDEVAC='MEDEVAC'
    NONRVSM='NONRVSM'
    SAR='SAR'
    STATE='STATE'


class SpeedConditionType(Enum):
    """The speed condition indicates whether the aircraft will be maintaining,
    exceeding,
    or flying more slowly than the assigned speed."""
    AT_OR_LESS='AT_OR_LESS' # Indicates that the aircraft will be flying at or slower than the assigned boundary crossing speed.
    AT_OR_GREATER='AT_OR_GREATER' # Indicates that the aircraft will be flying at or faster than the assigned boundary crossing speed.
    AT='AT' # Indicates that the aircraft will be flying at the assigned boundary crossing speed.


class SsrModeType(Enum):
    """Represents the enumeration of Secondary Surveillance Radar (SSR) Modes:
    * A - Transponder-Mode A (4 digits-4,096 codes)
    * C - Transponder-Mode A (4 digits-4,096 codes) and Mode C
    * S - Transponder-Mode S, including both pressure-altitude and aircraft
    identification
    transmission"""
    A='A' # Indicates Secondary Surveillance Radar (SSR) is operating in Transponder-Mode A.
    C='C' # Indicates Secondary Surveillance Radar (SSR) Transponder-Mode A and Mode C.
    S='S' # Indicates Secondary Surveillance Radar (SSR) Transponder-Mode S.


class StandReturnIntentType(Enum):
    """.Stand Return Intent: Indicates the intent for the flight to return to
    the stand."""
    RETURN='RETURN' # .Stand Return Intent: Indicates the intent for the flight to return to the stand.
    NO_RETURN='NO_RETURN' # .Stand Return Intent: Indicates the intent for the flight to return to the stand.


class StandardCapabilitiesIndicatorType(Enum):
    """.Standard Capabilities Indicator: This element indicates the aircraft
    carries the
    set of capabilities considered standard by the appropriate authority."""
    STANDARD='STANDARD'


class SurveillanceCodeType(Enum):
    """Describes the aircraft surveillance code."""
    A='A'
    B_1='B1'
    B_2='B2'
    C='C'
    D_1='D1'
    E='E'
    G_1='G1'
    H='H'
    I='I'
    L='L'
    P='P'
    S='S'
    U_1='U1'
    U_2='U2'
    V_1='V1'
    V_2='V2'
    X='X'


class SurvivalEquipmentCodeType(Enum):
    """.Survival Equipment Type: The type of equipment carried on board the
    aircraft that
    can be used by the crew and passengers to assist survival in harsh
    environments in
    case of emergency."""
    POLAR='POLAR'
    DESERT='DESERT'
    MARITIME='MARITIME'
    JUNGLE='JUNGLE'


class TemperatureMeasureType(Enum):
    """Provides units of measure for Temperature."""
    FARENHEIT='FARENHEIT' # Indicates temperature is measured in degrees Fahrenheit.
    CELSIUS='CELSIUS' # Indicates temperature is measured in degrees Celsius.
    KELVIN='KELVIN' # Indicates temperature is measured in degrees Kelvin.


class TfmsFlightStatusType(Enum):
    """.Traffic Flow Management System Flight Status: Indicates the current
    status of the
    flight, as determined by Traffic Flow Management System (TFMS)."""
    SCHEDULED='SCHEDULED'
    CONTROLLED='CONTROLLED'
    FILED='FILED'
    ACTIVE='ACTIVE'
    ASCENDING='ASCENDING'
    CRUISING='CRUISING'
    DESCENDING='DESCENDING'
    COMPLETED='COMPLETED'
    CANCELLED='CANCELLED'
    DECONTROLLED='DECONTROLLED'
    UNKNOWN='UNKNOWN'
    NONE='NONE'
    ERROR='ERROR'
    OTHER='OTHER'


class TimeQualifierType(Enum):
    """Qualifies the time associated with the constraint."""
    AT_OR_BEFORE_TIME='AT_OR_BEFORE_TIME'
    AT_TIME='AT_TIME'
    AT_OR_AFTER_TIME='AT_OR_AFTER_TIME'
    UNTIL_TIME='UNTIL_TIME'


class TrajectoryChangePointTypeType(Enum):
    """Trajectory Change Point - Type: Identifies the type(s) of trajectory
    change point
    being described by the associated 4D Point.
    .Trajectory Change Point - Type: Identifies the type(s) of trajectory
    change point
    being described by the associated 4D Point."""
    START_OF_CLIMB='START_OF_CLIMB'
    TOP_OF_CLIMB='TOP_OF_CLIMB'
    START_OF_DESCENT='START_OF_DESCENT'
    END_OF_DESCENT='END_OF_DESCENT'
    LEVEL_OFF='LEVEL_OFF'
    CROSSOVER_ALTITUDE='CROSSOVER_ALTITUDE'
    TRANSITION_ALTITUDE='TRANSITION_ALTITUDE'
    SPEED_CHANGE='SPEED_CHANGE'
    UNNAMED_FIX='UNNAMED_FIX'
    RUNWAY='RUNWAY'
    ENTRY_SPECIAL_ACTIVITY_AIRSPACE='ENTRY_SPECIAL_ACTIVITY_AIRSPACE'
    EXIT_SPECIAL_ACTIVITY_AIRSPACE='EXIT_SPECIAL_ACTIVITY_AIRSPACE'
    CROSSING_CONSTRAINED_AIRSPACE='CROSSING_CONSTRAINED_AIRSPACE'
    ENTER_HOLD='ENTER_HOLD'
    INITIAL_PREDICTION='INITIAL_PREDICTION'
    EXIT_HOLD='EXIT_HOLD'


class TypeOfFlightType(Enum):
    """.Flight Type: Indication of the rule under which an air traffic
    controller provides
    categorical handling of a flight."""
    MILITARY='MILITARY'
    GENERAL='GENERAL'
    NON_SCHEDULED='NON_SCHEDULED'
    SCHEDULED='SCHEDULED'
    OTHER='OTHER'


class UnitBoundaryIndicatorType(Enum):
    """.Unit Boundary Indicator: An indicator of the status of the boundary
    crossing in
    the Unit Boundary List as a past crossing, the current or next crossing, or
    a future
    crossing."""
    PAST='PAST' # Indicates a past traversed Air Traffic Control Unit.
    CURRENT='CURRENT' # Indicates a Current Air Traffic Control Unit.
    FUTURE='FUTURE' # Indicates a future Air Traffic control unit.


class VerticalRateMeasureType(Enum):
    """Qualifies VerticalRate as ft/min (if [(-3000)-3000] ) or m/s (if
    [(-15)-15] )."""
    FEET_PER_MINUTE='FEET_PER_MINUTE' # Indicates VerticalRate is in ft/min ([(-3000)-3000]).
    METRES_PER_SECOND='METRES_PER_SECOND' # Indicates VerticalRate is in m/s (if [(-15)-15] ).


class VolumeMeasureType(Enum):
    """Provides units of measure for Volume."""
    LITRES='LITRES' # Indicates volume is measured in liters.
    GALLONS='GALLONS' # Indicates volume is measured in gallons.


class WakeTurbulenceCategoryExtendedType(Enum):
    """.Wake Turbulence Category - NAS: NAS classification of the aircraft wake
    turbulence,
    based on wingspan and Maximum Takeoff Weight (MTOW)."""
    A='A' # Aircraft capable of MTOW of 300,000 pounds or more and a wingspan greater than 245 feet.
    B='B' # Aircraft capable of MTOW of 300,000 pounds or more and a wingspan greater than 175 feet and less than or equal to 245 feet.
    C='C' # Aircraft capable of a MTOW of 300,000 pounds or more and a wingspan greater than 125 feet and less than or equal to 175 feet.
    D='D' # Aircraft capable of a MTOW of less than 300,000 pounds and a wingspan greater than 125 feet and less than or equal to 175 feet, or aircraft with a wingspan greater than 90 feet and less than or equal to 125 feet.
    E='E' # Aircraft capable of a MTOW greater than 41,000 pounds with a wingspan greater than 65 feet and less than or equal to 90 feet.
    F='F' # Aircraft capable of a MTOW of less than 41,000 pounds and a wingspan less than or equal to 125 feet, or aircraft capable of a MTOW less than 15,500 pounds regardless of wingspan, or a powered sailplane.


class WakeTurbulenceCategoryType(Enum):
    """.Wake Turbulence Category: ICAO classification of the aircraft wake
    turbulence, based
    on the maximum certified take off mass."""
    L='L'
    M='M'
    H='H'
    J='J'


class WeightMeasureType(Enum):
    """Provides units of measure for Weight."""
    KILOGRAMS='KILOGRAMS' # Indicates weight is measured in kilograms.
    POUNDS='POUNDS' # Indicates weight is measured in pounds.


class WindSpeedMeasureType(Enum):
    """Indicates the units of measure for Wind Speed."""
    MILES_PER_HOUR='MILES_PER_HOUR'
    KILOMETRES_PER_HOUR='KILOMETRES_PER_HOUR'
    KNOTS='KNOTS'
    METERS_PER_SECOND='METERS_PER_SECOND'


class AerodromeReferenceType(GeneratedsSuper):
    """Aerodromes may be identified by:
    * their ICAO codes ("KDFW"), OR
    * (for unlisted aerodromes) their names ("Dallas Fort Worth") PLUS
    significant point
    * The aerodrome name can also include a 3 character IATA Alternate
    Identifier such
    as "DFW" """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AerodromeReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AerodromeReferenceType.subclass:
            return AerodromeReferenceType.subclass(*args_, **kwargs_)
        else:
            return AerodromeReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='AerodromeReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AerodromeReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AerodromeReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AerodromeReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='AerodromeReferenceType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='AerodromeReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AerodromeReferenceType


class IcaoAerodromeReferenceType(AerodromeReferenceType):
    """Aerodrome identified by standard ICAO identifier code
    Aerodrome's ICAO code. e.g. "KDFW" """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AerodromeReferenceType
    def __init__(self, code=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IcaoAerodromeReferenceType, self).__init__( **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IcaoAerodromeReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IcaoAerodromeReferenceType.subclass:
            return IcaoAerodromeReferenceType.subclass(*args_, **kwargs_)
        else:
            return IcaoAerodromeReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def validate_AerodromeIcaoCodeType(self, value):
        # Validate type ff:AerodromeIcaoCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_AerodromeIcaoCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AerodromeIcaoCodeType_patterns_, ))
    validate_AerodromeIcaoCodeType_patterns_ = [['^([A-Z]{4})$']]
    def hasContent_(self):
        if (
            super(IcaoAerodromeReferenceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='IcaoAerodromeReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IcaoAerodromeReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IcaoAerodromeReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IcaoAerodromeReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='IcaoAerodromeReferenceType'):
        super(IcaoAerodromeReferenceType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IcaoAerodromeReferenceType')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='IcaoAerodromeReferenceType', fromsubclass_=False, pretty_print=True):
        super(IcaoAerodromeReferenceType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_AerodromeIcaoCodeType(self.code)    # validate type AerodromeIcaoCodeType
        super(IcaoAerodromeReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IcaoAerodromeReferenceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IcaoAerodromeReferenceType


class RunwayPositionAndTimeType(GeneratedsSuper):
    """Reference to an airport runway for arrival, departure, or surface
    movement.
    Name associated with the runway"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, runwayName=None, runwayTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.runwayName = _cast(None, runwayName)
        self.runwayName_nsprefix_ = None
        self.runwayTime = runwayTime
        self.runwayTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RunwayPositionAndTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RunwayPositionAndTimeType.subclass:
            return RunwayPositionAndTimeType.subclass(*args_, **kwargs_)
        else:
            return RunwayPositionAndTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_runwayTime(self):
        return self.runwayTime
    def set_runwayTime(self, runwayTime):
        self.runwayTime = runwayTime
    def get_runwayName(self):
        return self.runwayName
    def set_runwayName(self, runwayName):
        self.runwayName = runwayName
    def validate_RunwayNameType(self, value):
        # Validate type ff:RunwayNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_RunwayNameType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RunwayNameType_patterns_, ))
    validate_RunwayNameType_patterns_ = [['^((0[1-9]|[12][0-9]|3[0-6])[LRC]{0,1})$']]
    def hasContent_(self):
        if (
            self.runwayTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='RunwayPositionAndTimeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RunwayPositionAndTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RunwayPositionAndTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RunwayPositionAndTimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='RunwayPositionAndTimeType'):
        if self.runwayName is not None and 'runwayName' not in already_processed:
            already_processed.add('runwayName')
            outfile.write(' runwayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.runwayName), input_name='runwayName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='RunwayPositionAndTimeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.runwayTime is not None:
            namespaceprefix_ = self.runwayTime_nsprefix_ + ':' if (UseCapturedNS_ and self.runwayTime_nsprefix_) else ''
            self.runwayTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='runwayTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('runwayName', node)
        if value is not None and 'runwayName' not in already_processed:
            already_processed.add('runwayName')
            self.runwayName = value
            self.validate_RunwayNameType(self.runwayName)    # validate type RunwayNameType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'runwayTime':
            obj_ = ExtendedMultiTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.runwayTime = obj_
            obj_.original_tagname_ = 'runwayTime'
# end class RunwayPositionAndTimeType


class StandPositionAndTimeType(GeneratedsSuper):
    """Reference to an airport stand that an aircraft can arrive at, depart
    from, or traverse
    during arrival, departure, or surface movement.
    Name of the traversed stand.
    Name of the traversed terminal."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, standName=None, terminalName=None, standTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.standName = _cast(None, standName)
        self.standName_nsprefix_ = None
        self.terminalName = _cast(None, terminalName)
        self.terminalName_nsprefix_ = None
        self.standTime = standTime
        self.standTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StandPositionAndTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StandPositionAndTimeType.subclass:
            return StandPositionAndTimeType.subclass(*args_, **kwargs_)
        else:
            return StandPositionAndTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_standTime(self):
        return self.standTime
    def set_standTime(self, standTime):
        self.standTime = standTime
    def get_standName(self):
        return self.standName
    def set_standName(self, standName):
        self.standName = standName
    def get_terminalName(self):
        return self.terminalName
    def set_terminalName(self, terminalName):
        self.terminalName = terminalName
    def validate_StandNameType(self, value):
        # Validate type ff:StandNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_TerminalNameType(self, value):
        # Validate type ff:TerminalNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.standTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='StandPositionAndTimeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StandPositionAndTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StandPositionAndTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StandPositionAndTimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='StandPositionAndTimeType'):
        if self.standName is not None and 'standName' not in already_processed:
            already_processed.add('standName')
            outfile.write(' standName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.standName), input_name='standName')), ))
        if self.terminalName is not None and 'terminalName' not in already_processed:
            already_processed.add('terminalName')
            outfile.write(' terminalName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.terminalName), input_name='terminalName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='StandPositionAndTimeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standTime is not None:
            namespaceprefix_ = self.standTime_nsprefix_ + ':' if (UseCapturedNS_ and self.standTime_nsprefix_) else ''
            self.standTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='standTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('standName', node)
        if value is not None and 'standName' not in already_processed:
            already_processed.add('standName')
            self.standName = value
            self.validate_StandNameType(self.standName)    # validate type StandNameType
        value = find_attr_value_('terminalName', node)
        if value is not None and 'terminalName' not in already_processed:
            already_processed.add('terminalName')
            self.terminalName = value
            self.validate_TerminalNameType(self.terminalName)    # validate type TerminalNameType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'standTime':
            obj_ = ExtendedMultiTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.standTime = obj_
            obj_.original_tagname_ = 'standTime'
# end class StandPositionAndTimeType


class UnlistedAerodromeReferenceType(AerodromeReferenceType):
    """Identifies an aerodrome (that does not possess a listed ICAO code) by
    specifying
    both
    * its aerodrome name ("Dallas Fort Worth") AND
    * a significant point consisting of
    * its geographic location (latitude and longitude) OR
    * the first significant point of a flight route OR
    * fix/radial/offset from a known waypoint.
    Aerodrome's name. e.g. "Dallas Fort Worth". * The e name can also include a
    3 character
    IATA Alternate Identifier such as "DFW" """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AerodromeReferenceType
    def __init__(self, name=None, point=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(UnlistedAerodromeReferenceType, self).__init__( **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.point = point
        self.point_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnlistedAerodromeReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnlistedAerodromeReferenceType.subclass:
            return UnlistedAerodromeReferenceType.subclass(*args_, **kwargs_)
        else:
            return UnlistedAerodromeReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_point(self):
        return self.point
    def set_point(self, point):
        self.point = point
    def set_point_with_type(self, value):
        self.point = value
        value.original_tagname_ = 'point'
        value.extensiontype_ = value.__class__.__name__
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def validate_AerodromeNameType(self, value):
        # Validate type ff:AerodromeNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.point is not None or
            super(UnlistedAerodromeReferenceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='UnlistedAerodromeReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnlistedAerodromeReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnlistedAerodromeReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UnlistedAerodromeReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='UnlistedAerodromeReferenceType'):
        super(UnlistedAerodromeReferenceType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnlistedAerodromeReferenceType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='UnlistedAerodromeReferenceType', fromsubclass_=False, pretty_print=True):
        super(UnlistedAerodromeReferenceType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.point is not None:
            self.point.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_AerodromeNameType(self.name)    # validate type AerodromeNameType
        super(UnlistedAerodromeReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'point':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <point> element')
            self.point = obj_
            obj_.original_tagname_ = 'point'
        super(UnlistedAerodromeReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class UnlistedAerodromeReferenceType


class SignificantPointType(GeneratedsSuper):
    """A location type restricted to lat/long location, fix (waypoint)
    location, or FRD
    (radial distance offset)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignificantPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignificantPointType.subclass:
            return SignificantPointType.subclass(*args_, **kwargs_)
        else:
            return SignificantPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='SignificantPointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignificantPointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignificantPointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignificantPointType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='SignificantPointType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='SignificantPointType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SignificantPointType


class ContactInformationType(GeneratedsSuper):
    """Information required to enable contact with the responsible person
    and/or organisation.
    This model is derived from ISO19115-2003:Geographic Information- Metadata.
    The official name of the contact. In case of the organization use, it is
    the name
    of the person within the organization who is the contact point.
    If the usage of ContactInformation is associated with a person, this field
    should
    not be used, insead, the Person class' name should be used instead.
    The official title of the contact."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, title=None, address=None, onlineContact=None, phoneFax=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.address = address
        self.address_nsprefix_ = None
        self.onlineContact = onlineContact
        self.onlineContact_nsprefix_ = None
        self.phoneFax = phoneFax
        self.phoneFax_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactInformationType.subclass:
            return ContactInformationType.subclass(*args_, **kwargs_)
        else:
            return ContactInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    def get_onlineContact(self):
        return self.onlineContact
    def set_onlineContact(self, onlineContact):
        self.onlineContact = onlineContact
    def get_phoneFax(self):
        return self.phoneFax
    def set_phoneFax(self, phoneFax):
        self.phoneFax = phoneFax
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_TextNameType(self, value):
        # Validate type ff:TextNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.address is not None or
            self.onlineContact is not None or
            self.phoneFax is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='ContactInformationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContactInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContactInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContactInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='ContactInformationType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='ContactInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.address is not None:
            namespaceprefix_ = self.address_nsprefix_ + ':' if (UseCapturedNS_ and self.address_nsprefix_) else ''
            self.address.export(outfile, level, namespaceprefix_, namespacedef_='', name_='address', pretty_print=pretty_print)
        if self.onlineContact is not None:
            namespaceprefix_ = self.onlineContact_nsprefix_ + ':' if (UseCapturedNS_ and self.onlineContact_nsprefix_) else ''
            self.onlineContact.export(outfile, level, namespaceprefix_, namespacedef_='', name_='onlineContact', pretty_print=pretty_print)
        if self.phoneFax is not None:
            namespaceprefix_ = self.phoneFax_nsprefix_ + ':' if (UseCapturedNS_ and self.phoneFax_nsprefix_) else ''
            self.phoneFax.export(outfile, level, namespaceprefix_, namespacedef_='', name_='phoneFax', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_TextNameType(self.name)    # validate type TextNameType
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
            self.validate_TextNameType(self.title)    # validate type TextNameType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'address':
            obj_ = PostalAddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.address = obj_
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'onlineContact':
            obj_ = OnlineContactType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.onlineContact = obj_
            obj_.original_tagname_ = 'onlineContact'
        elif nodeName_ == 'phoneFax':
            obj_ = TelephoneContactType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.phoneFax = obj_
            obj_.original_tagname_ = 'phoneFax'
# end class ContactInformationType


class OnlineContactType(GeneratedsSuper):
    """On-line or Network information that can be used to contact the
    individual or organisation,
    including eMail address and web site page.
    The address of the electronic mailbox of the responsible organisation or
    individual."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, email=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.email = _cast(None, email)
        self.email_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OnlineContactType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnlineContactType.subclass:
            return OnlineContactType.subclass(*args_, **kwargs_)
        else:
            return OnlineContactType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def validate_TextAddressType(self, value):
        # Validate type ff:TextAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='OnlineContactType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OnlineContactType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OnlineContactType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OnlineContactType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='OnlineContactType'):
        if self.email is not None and 'email' not in already_processed:
            already_processed.add('email')
            outfile.write(' email=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.email), input_name='email')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='OnlineContactType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('email', node)
        if value is not None and 'email' not in already_processed:
            already_processed.add('email')
            self.email = value
            self.validate_TextAddressType(self.email)    # validate type TextAddressType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class OnlineContactType


class PostalAddressType(GeneratedsSuper):
    """Physical address at which the organization or individual may be
    contacted. Derived
    from ISO19115-2003
    The state or province of the location or organisation.
    The city of the location or organisation.
    The country of the physical address for the location or organisation. ISO
    3166 abbreviations.
    The country of the physical address for the location or organisation. Full
    name,
    not ISO 3166 abbreviations.
    The street address line for the location. More than one address line may be
    used.
    The ZIP or other postal code for the location or organisation."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, administrativeArea=None, city=None, countryCode=None, countryName=None, deliveryPoint=None, postalCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.administrativeArea = _cast(None, administrativeArea)
        self.administrativeArea_nsprefix_ = None
        self.city = _cast(None, city)
        self.city_nsprefix_ = None
        self.countryCode = _cast(None, countryCode)
        self.countryCode_nsprefix_ = None
        self.countryName = _cast(None, countryName)
        self.countryName_nsprefix_ = None
        self.deliveryPoint = _cast(None, deliveryPoint)
        self.deliveryPoint_nsprefix_ = None
        self.postalCode = _cast(None, postalCode)
        self.postalCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PostalAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PostalAddressType.subclass:
            return PostalAddressType.subclass(*args_, **kwargs_)
        else:
            return PostalAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_administrativeArea(self):
        return self.administrativeArea
    def set_administrativeArea(self, administrativeArea):
        self.administrativeArea = administrativeArea
    def get_city(self):
        return self.city
    def set_city(self, city):
        self.city = city
    def get_countryCode(self):
        return self.countryCode
    def set_countryCode(self, countryCode):
        self.countryCode = countryCode
    def get_countryName(self):
        return self.countryName
    def set_countryName(self, countryName):
        self.countryName = countryName
    def get_deliveryPoint(self):
        return self.deliveryPoint
    def set_deliveryPoint(self, deliveryPoint):
        self.deliveryPoint = deliveryPoint
    def get_postalCode(self):
        return self.postalCode
    def set_postalCode(self, postalCode):
        self.postalCode = postalCode
    def validate_TextNameType(self, value):
        # Validate type ff:TextNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_TextCityType(self, value):
        # Validate type ff:TextCityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_TextCountryCodeType(self, value):
        # Validate type ff:TextCountryCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TextCountryCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TextCountryCodeType_patterns_, ))
    validate_TextCountryCodeType_patterns_ = [['^([A-Z]{2})$']]
    def validate_TextCountryNameType(self, value):
        # Validate type ff:TextCountryNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_TextAddressType(self, value):
        # Validate type ff:TextAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='PostalAddressType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PostalAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PostalAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PostalAddressType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='PostalAddressType'):
        if self.administrativeArea is not None and 'administrativeArea' not in already_processed:
            already_processed.add('administrativeArea')
            outfile.write(' administrativeArea=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.administrativeArea), input_name='administrativeArea')), ))
        if self.city is not None and 'city' not in already_processed:
            already_processed.add('city')
            outfile.write(' city=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.city), input_name='city')), ))
        if self.countryCode is not None and 'countryCode' not in already_processed:
            already_processed.add('countryCode')
            outfile.write(' countryCode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.countryCode), input_name='countryCode')), ))
        if self.countryName is not None and 'countryName' not in already_processed:
            already_processed.add('countryName')
            outfile.write(' countryName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.countryName), input_name='countryName')), ))
        if self.deliveryPoint is not None and 'deliveryPoint' not in already_processed:
            already_processed.add('deliveryPoint')
            outfile.write(' deliveryPoint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.deliveryPoint), input_name='deliveryPoint')), ))
        if self.postalCode is not None and 'postalCode' not in already_processed:
            already_processed.add('postalCode')
            outfile.write(' postalCode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.postalCode), input_name='postalCode')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='PostalAddressType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('administrativeArea', node)
        if value is not None and 'administrativeArea' not in already_processed:
            already_processed.add('administrativeArea')
            self.administrativeArea = value
            self.validate_TextNameType(self.administrativeArea)    # validate type TextNameType
        value = find_attr_value_('city', node)
        if value is not None and 'city' not in already_processed:
            already_processed.add('city')
            self.city = value
            self.validate_TextCityType(self.city)    # validate type TextCityType
        value = find_attr_value_('countryCode', node)
        if value is not None and 'countryCode' not in already_processed:
            already_processed.add('countryCode')
            self.countryCode = value
            self.validate_TextCountryCodeType(self.countryCode)    # validate type TextCountryCodeType
        value = find_attr_value_('countryName', node)
        if value is not None and 'countryName' not in already_processed:
            already_processed.add('countryName')
            self.countryName = value
            self.validate_TextCountryNameType(self.countryName)    # validate type TextCountryNameType
        value = find_attr_value_('deliveryPoint', node)
        if value is not None and 'deliveryPoint' not in already_processed:
            already_processed.add('deliveryPoint')
            self.deliveryPoint = value
            self.validate_TextAddressType(self.deliveryPoint)    # validate type TextAddressType
        value = find_attr_value_('postalCode', node)
        if value is not None and 'postalCode' not in already_processed:
            already_processed.add('postalCode')
            self.postalCode = value
            self.validate_TextNameType(self.postalCode)    # validate type TextNameType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PostalAddressType


class TelephoneContactType(GeneratedsSuper):
    """Telephone numbers at which the organisation or individual may be
    contacted. From
    ISO19115-2003
    The telephone number of a facsimile machine for the responsible
    organisation or individual.
    The telephone number by which individuals can speak to the responsible
    organisation
    or individual."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, facimile=None, voice=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.facimile = _cast(None, facimile)
        self.facimile_nsprefix_ = None
        self.voice = _cast(None, voice)
        self.voice_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TelephoneContactType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TelephoneContactType.subclass:
            return TelephoneContactType.subclass(*args_, **kwargs_)
        else:
            return TelephoneContactType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_facimile(self):
        return self.facimile
    def set_facimile(self, facimile):
        self.facimile = facimile
    def get_voice(self):
        return self.voice
    def set_voice(self, voice):
        self.voice = voice
    def validate_TextPhoneType(self, value):
        # Validate type ff:TextPhoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='TelephoneContactType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TelephoneContactType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TelephoneContactType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TelephoneContactType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='TelephoneContactType'):
        if self.facimile is not None and 'facimile' not in already_processed:
            already_processed.add('facimile')
            outfile.write(' facimile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.facimile), input_name='facimile')), ))
        if self.voice is not None and 'voice' not in already_processed:
            already_processed.add('voice')
            outfile.write(' voice=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.voice), input_name='voice')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='TelephoneContactType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('facimile', node)
        if value is not None and 'facimile' not in already_processed:
            already_processed.add('facimile')
            self.facimile = value
            self.validate_TextPhoneType(self.facimile)    # validate type TextPhoneType
        value = find_attr_value_('voice', node)
        if value is not None and 'voice' not in already_processed:
            already_processed.add('voice')
            self.voice = value
            self.validate_TextPhoneType(self.voice)    # validate type TextPhoneType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TelephoneContactType


class UnitSectorAirspaceType(GeneratedsSuper):
    """A subdivision of the airspace.
    Indicates the type of airspace."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, airspaceType=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.airspaceType = _cast(None, airspaceType)
        self.airspaceType_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitSectorAirspaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitSectorAirspaceType.subclass:
            return UnitSectorAirspaceType.subclass(*args_, **kwargs_)
        else:
            return UnitSectorAirspaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_airspaceType(self):
        return self.airspaceType
    def set_airspaceType(self, airspaceType):
        self.airspaceType = airspaceType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AirspaceTypeType(self, value):
        # Validate type ff:AirspaceTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SECTOR', 'FIR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AirspaceTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='UnitSectorAirspaceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnitSectorAirspaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnitSectorAirspaceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UnitSectorAirspaceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='UnitSectorAirspaceType'):
        if self.airspaceType is not None and 'airspaceType' not in already_processed:
            already_processed.add('airspaceType')
            outfile.write(' airspaceType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.airspaceType), input_name='airspaceType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='UnitSectorAirspaceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('airspaceType', node)
        if value is not None and 'airspaceType' not in already_processed:
            already_processed.add('airspaceType')
            self.airspaceType = value
            self.validate_AirspaceTypeType(self.airspaceType)    # validate type AirspaceTypeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class UnitSectorAirspaceType


class AltitudeType(GeneratedsSuper):
    """Simple altitude type: single measurement above specified reference
    point.
    A required AltitudeReference.
    A required AltitudeMeasure."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ref=None, uom=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ref = _cast(None, ref)
        self.ref_nsprefix_ = None
        self.uom = _cast(None, uom)
        self.uom_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AltitudeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AltitudeType.subclass:
            return AltitudeType.subclass(*args_, **kwargs_)
        else:
            return AltitudeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_AltitudeReferenceType(self, value):
        # Validate type ff:AltitudeReferenceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MEAN_SEA_LEVEL', 'FLIGHT_LEVEL']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AltitudeReferenceType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_AltitudeMeasureType(self, value):
        # Validate type ff:AltitudeMeasureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['FEET', 'METRES']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AltitudeMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='AltitudeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AltitudeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AltitudeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AltitudeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='AltitudeType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='AltitudeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
            self.validate_AltitudeReferenceType(self.ref)    # validate type AltitudeReferenceType
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
            self.validate_AltitudeMeasureType(self.uom)    # validate type AltitudeMeasureType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AltitudeType


class VerticalRateType(GeneratedsSuper):
    """.Vertical Rate: An expression of an aircraft's vertical rate of change
    (climb if
    positive, descent if negative) expressed as a float [(-3000)-3000] if
    expressed in
    ft/min, [(-15)-15] if expressed in m/s.
    Required VerticalRateMeasure."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.uom = _cast(None, uom)
        self.uom_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalRateType.subclass:
            return VerticalRateType.subclass(*args_, **kwargs_)
        else:
            return VerticalRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_VerticalRateMeasureType(self, value):
        # Validate type ff:VerticalRateMeasureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['FEET_PER_MINUTE', 'METRES_PER_SECOND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on VerticalRateMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='VerticalRateType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VerticalRateType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VerticalRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VerticalRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='VerticalRateType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='VerticalRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
            self.validate_VerticalRateMeasureType(self.uom)    # validate type VerticalRateMeasureType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class VerticalRateType


class AirspeedInIasOrMachType(GeneratedsSuper):
    """The Airspeed type represents any airspeed measurement, in metric.
    imperial, or Mach
    units, as
    specified by the "uom" attribute.
    Attribute of IndicatedAirspeed indicating measurement, in metric. imperial,
    or Mach
    units."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.uom = _cast(None, uom)
        self.uom_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AirspeedInIasOrMachType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AirspeedInIasOrMachType.subclass:
            return AirspeedInIasOrMachType.subclass(*args_, **kwargs_)
        else:
            return AirspeedInIasOrMachType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_AirspeedMeasureType(self, value):
        # Validate type ff:AirspeedMeasureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['KILOMETRES_PER_HOUR', 'KNOTS', 'MACH']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AirspeedMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='AirspeedInIasOrMachType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AirspeedInIasOrMachType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AirspeedInIasOrMachType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AirspeedInIasOrMachType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='AirspeedInIasOrMachType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='AirspeedInIasOrMachType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
            self.validate_AirspeedMeasureType(self.uom)    # validate type AirspeedMeasureType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AirspeedInIasOrMachType


class AngleType(GeneratedsSuper):
    """This is a placeholder for gml:AngleType.
    Indicates angle units of measure."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.uom = _cast(None, uom)
        self.uom_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AngleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AngleType.subclass:
            return AngleType.subclass(*args_, **kwargs_)
        else:
            return AngleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_AngleMeasureType(self, value):
        # Validate type ff:AngleMeasureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEGREES']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AngleMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='AngleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AngleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AngleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AngleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='AngleType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='AngleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
            self.validate_AngleMeasureType(self.uom)    # validate type AngleMeasureType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AngleType


class DimensionsType(GeneratedsSuper):
    """Describes dimensions: weight, height, length."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, height=None, length=None, width=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.height = height
        self.height_nsprefix_ = None
        self.length = length
        self.length_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionsType.subclass:
            return DimensionsType.subclass(*args_, **kwargs_)
        else:
            return DimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def hasContent_(self):
        if (
            self.height is not None or
            self.length is not None or
            self.width is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='DimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DimensionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='DimensionsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='DimensionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.height is not None:
            namespaceprefix_ = self.height_nsprefix_ + ':' if (UseCapturedNS_ and self.height_nsprefix_) else ''
            self.height.export(outfile, level, namespaceprefix_, namespacedef_='', name_='height', pretty_print=pretty_print)
        if self.length is not None:
            namespaceprefix_ = self.length_nsprefix_ + ':' if (UseCapturedNS_ and self.length_nsprefix_) else ''
            self.length.export(outfile, level, namespaceprefix_, namespacedef_='', name_='length', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'height':
            obj_ = LengthType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.height = obj_
            obj_.original_tagname_ = 'height'
        elif nodeName_ == 'length':
            obj_ = LengthType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.length = obj_
            obj_.original_tagname_ = 'length'
        elif nodeName_ == 'width':
            obj_ = LengthType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
# end class DimensionsType


class DistanceType(GeneratedsSuper):
    """The Distance type represents any distance between two points in space,
    in metric
    or imperial measurements.
    Required DistanceMeasure."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.uom = _cast(None, uom)
        self.uom_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DistanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DistanceType.subclass:
            return DistanceType.subclass(*args_, **kwargs_)
        else:
            return DistanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_DistanceMeasureType(self, value):
        # Validate type ff:DistanceMeasureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['NAUTICAL_MILES', 'MILES', 'KILOMETERS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DistanceMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='DistanceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DistanceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DistanceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DistanceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='DistanceType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='DistanceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
            self.validate_DistanceMeasureType(self.uom)    # validate type DistanceMeasureType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DistanceType


class GroundspeedType(GeneratedsSuper):
    """The Groundspeed type represents any ground speed measurement, in metric.
    or imperial,
    as
    specified by the "uom" attribute.
    Attribute of Groundspeed indicating units of ground speed measurement."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.uom = _cast(None, uom)
        self.uom_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GroundspeedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GroundspeedType.subclass:
            return GroundspeedType.subclass(*args_, **kwargs_)
        else:
            return GroundspeedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_GroundspeedMeasureType(self, value):
        # Validate type ff:GroundspeedMeasureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['KILOMETRES_PER_HOUR', 'KNOTS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on GroundspeedMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='GroundspeedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GroundspeedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GroundspeedType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GroundspeedType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='GroundspeedType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='GroundspeedType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
            self.validate_GroundspeedMeasureType(self.uom)    # validate type GroundspeedMeasureType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class GroundspeedType


class LengthType(GeneratedsSuper):
    """The Length type represents any length measurement, in metric or imperial
    measurements.
    Attribute of Length indicating units of measurement."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.uom = _cast(None, uom)
        self.uom_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LengthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LengthType.subclass:
            return LengthType.subclass(*args_, **kwargs_)
        else:
            return LengthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_LengthMeasureType(self, value):
        # Validate type ff:LengthMeasureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['FEET', 'INCHES', 'METRES', 'CENTIMETRES', 'MILLIMETRES']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on LengthMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='LengthType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LengthType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LengthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LengthType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='LengthType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='LengthType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
            self.validate_LengthMeasureType(self.uom)    # validate type LengthMeasureType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LengthType


class PressureType(GeneratedsSuper):
    """Describes the atmospheric pressure.
    Indicates the pressure units of measure."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.uom = _cast(None, uom)
        self.uom_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PressureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PressureType.subclass:
            return PressureType.subclass(*args_, **kwargs_)
        else:
            return PressureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_PressureMeasureType(self, value):
        # Validate type ff:PressureMeasureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ATMOSPHERES', 'BAR', 'HECTOPASCAL', 'PASCAL', 'POUNDS_PER_SQUARE_INCH', 'TORR', 'MILLIBAR', 'INCHES_OF_MERCURY']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PressureMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='PressureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PressureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PressureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PressureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='PressureType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='PressureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
            self.validate_PressureMeasureType(self.uom)    # validate type PressureMeasureType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PressureType


class TemperatureType(GeneratedsSuper):
    """Represents temperature on a specific scale
    Attribute of Temperature indicating measurement units."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.uom = _cast(None, uom)
        self.uom_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemperatureType.subclass:
            return TemperatureType.subclass(*args_, **kwargs_)
        else:
            return TemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_TemperatureMeasureType(self, value):
        # Validate type ff:TemperatureMeasureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['FARENHEIT', 'CELSIUS', 'KELVIN']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TemperatureMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='TemperatureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TemperatureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='TemperatureType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='TemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
            self.validate_TemperatureMeasureType(self.uom)    # validate type TemperatureMeasureType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TemperatureType


class TrueAirspeedOrMachType(GeneratedsSuper):
    """The Airspeed type represents any airspeed measurement, in metric.
    imperial, or Mach
    units, as
    specified by the "uom" attribute.
    Attribute of TrueAirspeed indicating measurement, in metric. imperial, or
    Mach units."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.uom = _cast(None, uom)
        self.uom_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrueAirspeedOrMachType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrueAirspeedOrMachType.subclass:
            return TrueAirspeedOrMachType.subclass(*args_, **kwargs_)
        else:
            return TrueAirspeedOrMachType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AirspeedMeasureType(self, value):
        # Validate type ff:AirspeedMeasureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['KILOMETRES_PER_HOUR', 'KNOTS', 'MACH']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AirspeedMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='TrueAirspeedOrMachType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrueAirspeedOrMachType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TrueAirspeedOrMachType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TrueAirspeedOrMachType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='TrueAirspeedOrMachType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='TrueAirspeedOrMachType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
            self.validate_AirspeedMeasureType(self.uom)    # validate type AirspeedMeasureType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TrueAirspeedOrMachType


class VolumeType(GeneratedsSuper):
    """The Volume type represents any volume measurement, in metric or imperial
    measurements.
    Attribute of Volume indicating measurement units."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.uom = _cast(None, uom)
        self.uom_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumeType.subclass:
            return VolumeType.subclass(*args_, **kwargs_)
        else:
            return VolumeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_VolumeMeasureType(self, value):
        # Validate type ff:VolumeMeasureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LITRES', 'GALLONS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on VolumeMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='VolumeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VolumeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VolumeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VolumeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='VolumeType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='VolumeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
            self.validate_VolumeMeasureType(self.uom)    # validate type VolumeMeasureType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class VolumeType


class WeightType(GeneratedsSuper):
    """The Weight type represents any weight measurement, in metric or imperial
    measurements.
    Attribute of Weight indicating measurement units."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.uom = _cast(None, uom)
        self.uom_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeightType.subclass:
            return WeightType.subclass(*args_, **kwargs_)
        else:
            return WeightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_WeightMeasureType(self, value):
        # Validate type ff:WeightMeasureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['KILOGRAMS', 'POUNDS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on WeightMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='WeightType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WeightType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WeightType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WeightType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='WeightType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='WeightType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
            self.validate_WeightMeasureType(self.uom)    # validate type WeightMeasureType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class WeightType


class WindDirectionType(AngleType):
    """Indicates the direction of the wind which is a specialization of the
    angle."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AngleType
    def __init__(self, uom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(WindDirectionType, self).__init__(uom, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WindDirectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WindDirectionType.subclass:
            return WindDirectionType.subclass(*args_, **kwargs_)
        else:
            return WindDirectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(WindDirectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='WindDirectionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WindDirectionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WindDirectionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WindDirectionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='WindDirectionType'):
        super(WindDirectionType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WindDirectionType')
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='WindDirectionType', fromsubclass_=False, pretty_print=True):
        super(WindDirectionType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(WindDirectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class WindDirectionType


class WindspeedType(GeneratedsSuper):
    """Indicates the Speed of wind.
    Indicates the windspeed units of measure."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.uom = _cast(None, uom)
        self.uom_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WindspeedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WindspeedType.subclass:
            return WindspeedType.subclass(*args_, **kwargs_)
        else:
            return WindspeedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_WindSpeedMeasureType(self, value):
        # Validate type ff:WindSpeedMeasureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MILES_PER_HOUR', 'KILOMETRES_PER_HOUR', 'KNOTS', 'METERS_PER_SECOND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on WindSpeedMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='WindspeedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WindspeedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WindspeedType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WindspeedType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='WindspeedType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='WindspeedType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
            self.validate_WindSpeedMeasureType(self.uom)    # validate type WindSpeedMeasureType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class WindspeedType


class GeographicLocationType(GeneratedsSuper):
    """Represents a location by latitude and longitude reference. The "srsName"
    attribute
    names the coordinate reference system (CRS) that defines the semantics of
    the
    lat/long pair according to the ISO6709 standard. FIXM uses only
    "urn:ogc:def:crs:EPSG::4326".
    Names the coordinate reference system (CRS) that defines the semantics of
    the
    lat/long pair according to the ISO6709 standard. FIXM uses only
    "urn:ogc:def:crs:EPSG::4326"."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, srsName='urn:ogc:def:crs:EPSG::4326', pos=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.srsName = _cast(None, srsName)
        self.srsName_nsprefix_ = None
        self.pos = pos
        self.validate_posType(self.pos)
        self.pos_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeographicLocationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeographicLocationType.subclass:
            return GeographicLocationType.subclass(*args_, **kwargs_)
        else:
            return GeographicLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_pos(self):
        return self.pos
    def set_pos(self, pos):
        self.pos = pos
    def get_srsName(self):
        return self.srsName
    def set_srsName(self, srsName):
        self.srsName = srsName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_posType(self, value):
        result = True
        # Validate type posType, a restriction on xs:double.
        pass
        return result
    def hasContent_(self):
        if (
            self.pos is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ff="http://www.fixm.aero/foundation/3.0"', name_='GeographicLocationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeographicLocationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeographicLocationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GeographicLocationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='GeographicLocationType'):
        if self.srsName is not None and 'srsName' not in already_processed:
            already_processed.add('srsName')
            outfile.write(' srsName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.srsName), input_name='srsName')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ff="http://www.fixm.aero/foundation/3.0"', name_='GeographicLocationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pos is not None:
            namespaceprefix_ = self.pos_nsprefix_ + ':' if (UseCapturedNS_ and self.pos_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spos>%s</%spos>%s' % (namespaceprefix_ , self.gds_format_double_list(self.pos, input_name='pos'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('srsName', node)
        if value is not None and 'srsName' not in already_processed:
            already_processed.add('srsName')
            self.srsName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'pos':
            value_ = child_.text
            value_ = self.gds_validate_double_list(value_, node, 'pos')
            self.pos = value_
            self.pos_nsprefix_ = child_.prefix
            # validate type posType
            self.validate_posType(self.pos)
# end class GeographicLocationType


class OrganizationType(GeneratedsSuper):
    """A feature used to model various Organisations and Authorities. For
    example: ATS Organisations,
    Aircraft Operating Agencies, States, Groups of States, etc.
    The full official name of the State, Organisation, Authority, aircraft
    operating
    agency, handling agency etc.
    Used when OrganizationCatergoryCode enumeration is insufficient."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, otherOrganization=None, contact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.otherOrganization = _cast(None, otherOrganization)
        self.otherOrganization_nsprefix_ = None
        self.contact = contact
        self.contact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganizationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganizationType.subclass:
            return OrganizationType.subclass(*args_, **kwargs_)
        else:
            return OrganizationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_contact(self):
        return self.contact
    def set_contact(self, contact):
        self.contact = contact
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_otherOrganization(self):
        return self.otherOrganization
    def set_otherOrganization(self, otherOrganization):
        self.otherOrganization = otherOrganization
    def validate_TextNameType(self, value):
        # Validate type ff:TextNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.contact is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='OrganizationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganizationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganizationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrganizationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='OrganizationType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.otherOrganization is not None and 'otherOrganization' not in already_processed:
            already_processed.add('otherOrganization')
            outfile.write(' otherOrganization=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.otherOrganization), input_name='otherOrganization')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='OrganizationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.contact is not None:
            namespaceprefix_ = self.contact_nsprefix_ + ':' if (UseCapturedNS_ and self.contact_nsprefix_) else ''
            self.contact.export(outfile, level, namespaceprefix_, namespacedef_='', name_='contact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_TextNameType(self.name)    # validate type TextNameType
        value = find_attr_value_('otherOrganization', node)
        if value is not None and 'otherOrganization' not in already_processed:
            already_processed.add('otherOrganization')
            self.otherOrganization = value
            self.validate_TextNameType(self.otherOrganization)    # validate type TextNameType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contact':
            class_obj_ = self.get_class_obj_(child_, ContactInformationType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contact = obj_
            obj_.original_tagname_ = 'contact'
# end class OrganizationType


class PersonType(GeneratedsSuper):
    """A natural person, rather than an organization or agency.
    Person's name."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, contact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.contact = contact
        self.contact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonType.subclass:
            return PersonType.subclass(*args_, **kwargs_)
        else:
            return PersonType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_contact(self):
        return self.contact
    def set_contact(self, contact):
        self.contact = contact
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def validate_TextNameType(self, value):
        # Validate type ff:TextNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.contact is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='PersonType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='PersonType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='PersonType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.contact is not None:
            namespaceprefix_ = self.contact_nsprefix_ + ':' if (UseCapturedNS_ and self.contact_nsprefix_) else ''
            self.contact.export(outfile, level, namespaceprefix_, namespacedef_='', name_='contact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_TextNameType(self.name)    # validate type TextNameType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contact':
            class_obj_ = self.get_class_obj_(child_, ContactInformationType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contact = obj_
            obj_.original_tagname_ = 'contact'
# end class PersonType


class PersonOrOrganizationType(GeneratedsSuper):
    """An identifiable, responsible entity that can be either a natural person
    or an organization."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, organization=None, person=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.organization = organization
        self.organization_nsprefix_ = None
        self.person = person
        self.person_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonOrOrganizationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonOrOrganizationType.subclass:
            return PersonOrOrganizationType.subclass(*args_, **kwargs_)
        else:
            return PersonOrOrganizationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_organization(self):
        return self.organization
    def set_organization(self, organization):
        self.organization = organization
    def get_person(self):
        return self.person
    def set_person(self, person):
        self.person = person
    def hasContent_(self):
        if (
            self.organization is not None or
            self.person is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='PersonOrOrganizationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonOrOrganizationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonOrOrganizationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonOrOrganizationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='PersonOrOrganizationType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='PersonOrOrganizationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.organization is not None:
            namespaceprefix_ = self.organization_nsprefix_ + ':' if (UseCapturedNS_ and self.organization_nsprefix_) else ''
            self.organization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='organization', pretty_print=pretty_print)
        if self.person is not None:
            namespaceprefix_ = self.person_nsprefix_ + ':' if (UseCapturedNS_ and self.person_nsprefix_) else ''
            self.person.export(outfile, level, namespaceprefix_, namespacedef_='', name_='person', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'organization':
            obj_ = OrganizationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organization = obj_
            obj_.original_tagname_ = 'organization'
        elif nodeName_ == 'person':
            obj_ = PersonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.person = obj_
            obj_.original_tagname_ = 'person'
# end class PersonOrOrganizationType


class TimeSpanType(GeneratedsSuper):
    """TimeSpans represent passage of time between two events.
    The start of the current TimeSpan.
    The end of the current TimeSpan."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, beginPosition=None, endPosition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.beginPosition = _cast(None, beginPosition)
        self.beginPosition_nsprefix_ = None
        self.endPosition = _cast(None, endPosition)
        self.endPosition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeSpanType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeSpanType.subclass:
            return TimeSpanType.subclass(*args_, **kwargs_)
        else:
            return TimeSpanType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_beginPosition(self):
        return self.beginPosition
    def set_beginPosition(self, beginPosition):
        self.beginPosition = beginPosition
    def get_endPosition(self):
        return self.endPosition
    def set_endPosition(self, endPosition):
        self.endPosition = endPosition
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='TimeSpanType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeSpanType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeSpanType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeSpanType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ff:', name_='TimeSpanType'):
        if self.beginPosition is not None and 'beginPosition' not in already_processed:
            already_processed.add('beginPosition')
            outfile.write(' beginPosition=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.beginPosition), input_name='beginPosition')), ))
        if self.endPosition is not None and 'endPosition' not in already_processed:
            already_processed.add('endPosition')
            outfile.write(' endPosition=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.endPosition), input_name='endPosition')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ff:', namespacedef_='', name_='TimeSpanType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('beginPosition', node)
        if value is not None and 'beginPosition' not in already_processed:
            already_processed.add('beginPosition')
            try:
                self.beginPosition = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (beginPosition): %s' % exp)
            self.validate_TimeType(self.beginPosition)    # validate type TimeType
        value = find_attr_value_('endPosition', node)
        if value is not None and 'endPosition' not in already_processed:
            already_processed.add('endPosition')
            try:
                self.endPosition = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (endPosition): %s' % exp)
            self.validate_TimeType(self.endPosition)    # validate type TimeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TimeSpanType


class MultiTimeType(GeneratedsSuper):
    """MultiTime is a general-purpose structure that records a common pattern
    of flight
    time:
    * estimated
    * actual
    * controlled
    * earliest
    * etc.
    This base implementation of MultiTime contains only "actual" and
    "estimated" time
    values. It is assumed
    that users of MultiTime will extend it by adding attributes for the other
    time types
    that they need. It is recommended that these extensions also use
    cardinality 0..1
    for new time elements.
    Each of these times is an instance of a ReportedTime, and each recorded
    time is decorated
    with a Provenance block that describes the system that contributed it, so
    that data
    fusion systems can sort out which of the competing times to believe."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, actual=None, estimated=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.actual = actual
        self.actual_nsprefix_ = None
        self.estimated = estimated
        self.estimated_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MultiTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MultiTimeType.subclass:
            return MultiTimeType.subclass(*args_, **kwargs_)
        else:
            return MultiTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_actual(self):
        return self.actual
    def set_actual(self, actual):
        self.actual = actual
    def get_estimated(self):
        return self.estimated
    def set_estimated(self, estimated):
        self.estimated = estimated
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.actual is not None or
            self.estimated is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='MultiTimeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MultiTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MultiTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MultiTimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='MultiTimeType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='MultiTimeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.actual is not None:
            namespaceprefix_ = self.actual_nsprefix_ + ':' if (UseCapturedNS_ and self.actual_nsprefix_) else ''
            self.actual.export(outfile, level, namespaceprefix_, namespacedef_='', name_='actual', pretty_print=pretty_print)
        if self.estimated is not None:
            namespaceprefix_ = self.estimated_nsprefix_ + ':' if (UseCapturedNS_ and self.estimated_nsprefix_) else ''
            self.estimated.export(outfile, level, namespaceprefix_, namespacedef_='', name_='estimated', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'actual':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.actual = obj_
            obj_.original_tagname_ = 'actual'
        elif nodeName_ == 'estimated':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.estimated = obj_
            obj_.original_tagname_ = 'estimated'
# end class MultiTimeType


class ReportedTimeType(GeneratedsSuper):
    """ReportedTime is a record of a time instant, together with a Provenance
    block that
    describes the system that
    contributed it.
    Time at which the event occurred
    Source for the time data."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, time=None, centre=None, source=None, system=None, timestamp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.time = _cast(None, time)
        self.time_nsprefix_ = None
        self.centre = _cast(None, centre)
        self.centre_nsprefix_ = None
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.timestamp = _cast(None, timestamp)
        self.timestamp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportedTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportedTimeType.subclass:
            return ReportedTimeType.subclass(*args_, **kwargs_)
        else:
            return ReportedTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_centre(self):
        return self.centre
    def set_centre(self, centre):
        self.centre = centre
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_timestamp(self):
        return self.timestamp
    def set_timestamp(self, timestamp):
        self.timestamp = timestamp
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_ProvenanceCentreType(self, value):
        # Validate type fb:ProvenanceCentreType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_ProvenanceSourceType(self, value):
        # Validate type fb:ProvenanceSourceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_ProvenanceSystemType(self, value):
        # Validate type fb:ProvenanceSystemType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='ReportedTimeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReportedTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReportedTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReportedTimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='ReportedTimeType'):
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            outfile.write(' time=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.time), input_name='time')), ))
        if self.centre is not None and 'centre' not in already_processed:
            already_processed.add('centre')
            outfile.write(' centre=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.centre), input_name='centre')), ))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            outfile.write(' timestamp=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.timestamp), input_name='timestamp')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='ReportedTimeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.add('time')
            try:
                self.time = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (time): %s' % exp)
            self.validate_TimeType(self.time)    # validate type TimeType
        value = find_attr_value_('centre', node)
        if value is not None and 'centre' not in already_processed:
            already_processed.add('centre')
            self.centre = value
            self.validate_ProvenanceCentreType(self.centre)    # validate type ProvenanceCentreType
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
            self.validate_ProvenanceSourceType(self.source)    # validate type ProvenanceSourceType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_ProvenanceSystemType(self.system)    # validate type ProvenanceSystemType
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            try:
                self.timestamp = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timestamp): %s' % exp)
            self.validate_TimeType(self.timestamp)    # validate type TimeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ReportedTimeType


class TargetMultiTimeType(MultiTimeType):
    """TargetMultiTime is an extension of MultiTime that includes target time
    for use in
    data that requires target time in addition to estimated and actual time."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MultiTimeType
    def __init__(self, actual=None, estimated=None, target=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TargetMultiTimeType, self).__init__(actual, estimated, extensiontype_,  **kwargs_)
        self.target = target
        self.target_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetMultiTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetMultiTimeType.subclass:
            return TargetMultiTimeType.subclass(*args_, **kwargs_)
        else:
            return TargetMultiTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.target is not None or
            super(TargetMultiTimeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='TargetMultiTimeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetMultiTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TargetMultiTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TargetMultiTimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='TargetMultiTimeType'):
        super(TargetMultiTimeType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TargetMultiTimeType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='TargetMultiTimeType', fromsubclass_=False, pretty_print=True):
        super(TargetMultiTimeType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.target is not None:
            namespaceprefix_ = self.target_nsprefix_ + ':' if (UseCapturedNS_ and self.target_nsprefix_) else ''
            self.target.export(outfile, level, namespaceprefix_, namespacedef_='', name_='target', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(TargetMultiTimeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'target':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.target = obj_
            obj_.original_tagname_ = 'target'
        super(TargetMultiTimeType, self).buildChildren(child_, node, nodeName_, True)
# end class TargetMultiTimeType


class TimeSequenceType(GeneratedsSuper):
    """TimeSequence represents important times in a process that spans some
    time and has
    multiple steps. Each element of TimeSequence represents a record of the
    actual time
    associated with each step of the process. TimeSequence does not require
    that all
    steps of the process be present or complete, and it does not permit
    multiple occurrences
    of the same step.
    This base implementation of TimeSequence contains only "approval", "begin",
    "end",
    "ready", and "request" times. It is assumed that users of this type will
    extend it
    by adding intermediate steps."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, approval=None, begin=None, end=None, ready=None, request=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.approval = approval
        self.approval_nsprefix_ = None
        self.begin = begin
        self.begin_nsprefix_ = None
        self.end = end
        self.end_nsprefix_ = None
        self.ready = ready
        self.ready_nsprefix_ = None
        self.request = request
        self.request_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeSequenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeSequenceType.subclass:
            return TimeSequenceType.subclass(*args_, **kwargs_)
        else:
            return TimeSequenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_approval(self):
        return self.approval
    def set_approval(self, approval):
        self.approval = approval
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def get_ready(self):
        return self.ready
    def set_ready(self, ready):
        self.ready = ready
    def get_request(self):
        return self.request
    def set_request(self, request):
        self.request = request
    def hasContent_(self):
        if (
            self.approval is not None or
            self.begin is not None or
            self.end is not None or
            self.ready is not None or
            self.request is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='TimeSequenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeSequenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeSequenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeSequenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='TimeSequenceType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='TimeSequenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.approval is not None:
            namespaceprefix_ = self.approval_nsprefix_ + ':' if (UseCapturedNS_ and self.approval_nsprefix_) else ''
            self.approval.export(outfile, level, namespaceprefix_, namespacedef_='', name_='approval', pretty_print=pretty_print)
        if self.begin is not None:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            self.begin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='begin', pretty_print=pretty_print)
        if self.end is not None:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            self.end.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end', pretty_print=pretty_print)
        if self.ready is not None:
            namespaceprefix_ = self.ready_nsprefix_ + ':' if (UseCapturedNS_ and self.ready_nsprefix_) else ''
            self.ready.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ready', pretty_print=pretty_print)
        if self.request is not None:
            namespaceprefix_ = self.request_nsprefix_ + ':' if (UseCapturedNS_ and self.request_nsprefix_) else ''
            self.request.export(outfile, level, namespaceprefix_, namespacedef_='', name_='request', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'approval':
            class_obj_ = self.get_class_obj_(child_, TargetMultiTimeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.approval = obj_
            obj_.original_tagname_ = 'approval'
        elif nodeName_ == 'begin':
            class_obj_ = self.get_class_obj_(child_, MultiTimeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin = obj_
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'end':
            class_obj_ = self.get_class_obj_(child_, MultiTimeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end = obj_
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'ready':
            class_obj_ = self.get_class_obj_(child_, MultiTimeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ready = obj_
            obj_.original_tagname_ = 'ready'
        elif nodeName_ == 'request':
            class_obj_ = self.get_class_obj_(child_, MultiTimeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.request = obj_
            obj_.original_tagname_ = 'request'
# end class TimeSequenceType


class FeatureType(GeneratedsSuper):
    """The Feature type is the parent of all FIXM complex types that describe
    physical
    objects or events.
    It is used as a marker to messaging and other tools that the contained
    information
    is
    to be treated as an unit and not further decomposed.
    Feature carries information about the ultimate source of its contained data
    in the "Provenance" attribute group. Implicitly, this information qualifies
    all the
    contained elements, unless one of them overrides it locally.
    It is expected that applications will use this to record their own meta-
    data about
    the information contained in the feature.
    An optional Provepnance structure."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, centre=None, source=None, system=None, timestamp=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.centre = _cast(None, centre)
        self.centre_nsprefix_ = None
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.timestamp = _cast(None, timestamp)
        self.timestamp_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FeatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FeatureType.subclass:
            return FeatureType.subclass(*args_, **kwargs_)
        else:
            return FeatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_centre(self):
        return self.centre
    def set_centre(self, centre):
        self.centre = centre
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_timestamp(self):
        return self.timestamp
    def set_timestamp(self, timestamp):
        self.timestamp = timestamp
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ProvenanceCentreType(self, value):
        # Validate type fb:ProvenanceCentreType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_ProvenanceSourceType(self, value):
        # Validate type fb:ProvenanceSourceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_ProvenanceSystemType(self, value):
        # Validate type fb:ProvenanceSystemType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='FeatureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FeatureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FeatureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FeatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='FeatureType'):
        if self.centre is not None and 'centre' not in already_processed:
            already_processed.add('centre')
            outfile.write(' centre=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.centre), input_name='centre')), ))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            outfile.write(' timestamp=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.timestamp), input_name='timestamp')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='FeatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('centre', node)
        if value is not None and 'centre' not in already_processed:
            already_processed.add('centre')
            self.centre = value
            self.validate_ProvenanceCentreType(self.centre)    # validate type ProvenanceCentreType
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
            self.validate_ProvenanceSourceType(self.source)    # validate type ProvenanceSourceType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_ProvenanceSystemType(self.system)    # validate type ProvenanceSystemType
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            try:
                self.timestamp = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timestamp): %s' % exp)
            self.validate_TimeType(self.timestamp)    # validate type TimeType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FeatureType


class AtcUnitReferenceType(GeneratedsSuper):
    """Reference to an Air Traffic Control organization of any type: unit,
    sector, etc.
    if present, reference represents a delegated authority.
    Identifies the sector associated with this AtcUnit"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, delegated=None, sectorIdentifier=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.delegated = _cast(None, delegated)
        self.delegated_nsprefix_ = None
        self.sectorIdentifier = _cast(None, sectorIdentifier)
        self.sectorIdentifier_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AtcUnitReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AtcUnitReferenceType.subclass:
            return AtcUnitReferenceType.subclass(*args_, **kwargs_)
        else:
            return AtcUnitReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_delegated(self):
        return self.delegated
    def set_delegated(self, delegated):
        self.delegated = delegated
    def get_sectorIdentifier(self):
        return self.sectorIdentifier
    def set_sectorIdentifier(self, sectorIdentifier):
        self.sectorIdentifier = sectorIdentifier
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_DelegatedUnitIndicatorType(self, value):
        # Validate type fb:DelegatedUnitIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AUTHORITY_DELEGATED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DelegatedUnitIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='AtcUnitReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AtcUnitReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AtcUnitReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AtcUnitReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='AtcUnitReferenceType'):
        if self.delegated is not None and 'delegated' not in already_processed:
            already_processed.add('delegated')
            outfile.write(' delegated=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delegated), input_name='delegated')), ))
        if self.sectorIdentifier is not None and 'sectorIdentifier' not in already_processed:
            already_processed.add('sectorIdentifier')
            outfile.write(' sectorIdentifier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sectorIdentifier), input_name='sectorIdentifier')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='AtcUnitReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delegated', node)
        if value is not None and 'delegated' not in already_processed:
            already_processed.add('delegated')
            self.delegated = value
            self.validate_DelegatedUnitIndicatorType(self.delegated)    # validate type DelegatedUnitIndicatorType
        value = find_attr_value_('sectorIdentifier', node)
        if value is not None and 'sectorIdentifier' not in already_processed:
            already_processed.add('sectorIdentifier')
            self.sectorIdentifier = value
            self.validate_FreeTextType(self.sectorIdentifier)    # validate type FreeTextType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AtcUnitReferenceType


class IdentifiedUnitReferenceType(AtcUnitReferenceType):
    """Represents the Aeronautical Fixed Telecommunication Network station
    address
    Identifier for the unit"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AtcUnitReferenceType
    def __init__(self, delegated=None, sectorIdentifier=None, unitIdentifier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IdentifiedUnitReferenceType, self).__init__(delegated, sectorIdentifier,  **kwargs_)
        self.unitIdentifier = _cast(None, unitIdentifier)
        self.unitIdentifier_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedUnitReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedUnitReferenceType.subclass:
            return IdentifiedUnitReferenceType.subclass(*args_, **kwargs_)
        else:
            return IdentifiedUnitReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unitIdentifier(self):
        return self.unitIdentifier
    def set_unitIdentifier(self, unitIdentifier):
        self.unitIdentifier = unitIdentifier
    def validate_AtcUnitNameType(self, value):
        # Validate type ff:AtcUnitNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_AtcUnitNameType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AtcUnitNameType_patterns_, ))
    validate_AtcUnitNameType_patterns_ = [['^(([A-Z]{4})|([A-Za-z0-9]{1,}))$']]
    def hasContent_(self):
        if (
            super(IdentifiedUnitReferenceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='IdentifiedUnitReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentifiedUnitReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiedUnitReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IdentifiedUnitReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='IdentifiedUnitReferenceType'):
        super(IdentifiedUnitReferenceType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiedUnitReferenceType')
        if self.unitIdentifier is not None and 'unitIdentifier' not in already_processed:
            already_processed.add('unitIdentifier')
            outfile.write(' unitIdentifier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unitIdentifier), input_name='unitIdentifier')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='IdentifiedUnitReferenceType', fromsubclass_=False, pretty_print=True):
        super(IdentifiedUnitReferenceType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitIdentifier', node)
        if value is not None and 'unitIdentifier' not in already_processed:
            already_processed.add('unitIdentifier')
            self.unitIdentifier = value
            self.validate_AtcUnitNameType(self.unitIdentifier)    # validate type AtcUnitNameType
        super(IdentifiedUnitReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IdentifiedUnitReferenceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IdentifiedUnitReferenceType


class UnknownUnitReferenceType(AtcUnitReferenceType):
    """The name and optional location of this ATC unit.
    Text name of this ATC unit or an alternate identifier for the unit."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AtcUnitReferenceType
    def __init__(self, delegated=None, sectorIdentifier=None, unitNameOrAltId=None, unitLocation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(UnknownUnitReferenceType, self).__init__(delegated, sectorIdentifier,  **kwargs_)
        self.unitNameOrAltId = _cast(None, unitNameOrAltId)
        self.unitNameOrAltId_nsprefix_ = None
        self.unitLocation = unitLocation
        self.unitLocation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnknownUnitReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnknownUnitReferenceType.subclass:
            return UnknownUnitReferenceType.subclass(*args_, **kwargs_)
        else:
            return UnknownUnitReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unitLocation(self):
        return self.unitLocation
    def set_unitLocation(self, unitLocation):
        self.unitLocation = unitLocation
    def get_unitNameOrAltId(self):
        return self.unitNameOrAltId
    def set_unitNameOrAltId(self, unitNameOrAltId):
        self.unitNameOrAltId = unitNameOrAltId
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.unitLocation is not None or
            super(UnknownUnitReferenceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"', name_='UnknownUnitReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnknownUnitReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnknownUnitReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UnknownUnitReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='UnknownUnitReferenceType'):
        super(UnknownUnitReferenceType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnknownUnitReferenceType')
        if self.unitNameOrAltId is not None and 'unitNameOrAltId' not in already_processed:
            already_processed.add('unitNameOrAltId')
            outfile.write(' unitNameOrAltId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unitNameOrAltId), input_name='unitNameOrAltId')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"', name_='UnknownUnitReferenceType', fromsubclass_=False, pretty_print=True):
        super(UnknownUnitReferenceType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.unitLocation is not None:
            namespaceprefix_ = self.unitLocation_nsprefix_ + ':' if (UseCapturedNS_ and self.unitLocation_nsprefix_) else ''
            self.unitLocation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unitLocation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitNameOrAltId', node)
        if value is not None and 'unitNameOrAltId' not in already_processed:
            already_processed.add('unitNameOrAltId')
            self.unitNameOrAltId = value
            self.validate_FreeTextType(self.unitNameOrAltId)    # validate type FreeTextType
        super(UnknownUnitReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'unitLocation':
            class_obj_ = self.get_class_obj_(child_, GeographicLocationType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unitLocation = obj_
            obj_.original_tagname_ = 'unitLocation'
        super(UnknownUnitReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class UnknownUnitReferenceType


class AirspeedChoiceType(GeneratedsSuper):
    """The airspeed choice indicates that airspeed can either be expressed as
    specific with
    a speed condition or a speed range between lower and upper bounds."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, airspeed=None, airspeedRange=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.airspeed = airspeed
        self.airspeed_nsprefix_ = None
        if airspeedRange is None:
            self.airspeedRange = []
        else:
            self.airspeedRange = airspeedRange
        self.airspeedRange_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AirspeedChoiceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AirspeedChoiceType.subclass:
            return AirspeedChoiceType.subclass(*args_, **kwargs_)
        else:
            return AirspeedChoiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_airspeed(self):
        return self.airspeed
    def set_airspeed(self, airspeed):
        self.airspeed = airspeed
    def get_airspeedRange(self):
        return self.airspeedRange
    def set_airspeedRange(self, airspeedRange):
        self.airspeedRange = airspeedRange
    def add_airspeedRange(self, value):
        self.airspeedRange.append(value)
    def insert_airspeedRange_at(self, index, value):
        self.airspeedRange.insert(index, value)
    def replace_airspeedRange_at(self, index, value):
        self.airspeedRange[index] = value
    def hasContent_(self):
        if (
            self.airspeed is not None or
            self.airspeedRange
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='AirspeedChoiceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AirspeedChoiceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AirspeedChoiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AirspeedChoiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='AirspeedChoiceType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='AirspeedChoiceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.airspeed is not None:
            namespaceprefix_ = self.airspeed_nsprefix_ + ':' if (UseCapturedNS_ and self.airspeed_nsprefix_) else ''
            self.airspeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='airspeed', pretty_print=pretty_print)
        for airspeedRange_ in self.airspeedRange:
            namespaceprefix_ = self.airspeedRange_nsprefix_ + ':' if (UseCapturedNS_ and self.airspeedRange_nsprefix_) else ''
            airspeedRange_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='airspeedRange', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'airspeed':
            obj_ = SpeedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.airspeed = obj_
            obj_.original_tagname_ = 'airspeed'
        elif nodeName_ == 'airspeedRange':
            obj_ = AirspeedRangeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.airspeedRange.append(obj_)
            obj_.original_tagname_ = 'airspeedRange'
# end class AirspeedChoiceType


class AirspeedRangeType(GeneratedsSuper):
    """The airspeed that can be expressed as a range between a lower and upper
    bound."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lowerSpeed=None, upperSpeed=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lowerSpeed = lowerSpeed
        self.lowerSpeed_nsprefix_ = None
        self.upperSpeed = upperSpeed
        self.upperSpeed_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AirspeedRangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AirspeedRangeType.subclass:
            return AirspeedRangeType.subclass(*args_, **kwargs_)
        else:
            return AirspeedRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lowerSpeed(self):
        return self.lowerSpeed
    def set_lowerSpeed(self, lowerSpeed):
        self.lowerSpeed = lowerSpeed
    def get_upperSpeed(self):
        return self.upperSpeed
    def set_upperSpeed(self, upperSpeed):
        self.upperSpeed = upperSpeed
    def hasContent_(self):
        if (
            self.lowerSpeed is not None or
            self.upperSpeed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"', name_='AirspeedRangeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AirspeedRangeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AirspeedRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AirspeedRangeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='AirspeedRangeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"', name_='AirspeedRangeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lowerSpeed is not None:
            namespaceprefix_ = self.lowerSpeed_nsprefix_ + ':' if (UseCapturedNS_ and self.lowerSpeed_nsprefix_) else ''
            self.lowerSpeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lowerSpeed', pretty_print=pretty_print)
        if self.upperSpeed is not None:
            namespaceprefix_ = self.upperSpeed_nsprefix_ + ':' if (UseCapturedNS_ and self.upperSpeed_nsprefix_) else ''
            self.upperSpeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='upperSpeed', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lowerSpeed':
            class_obj_ = self.get_class_obj_(child_, AirspeedInIasOrMachType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lowerSpeed = obj_
            obj_.original_tagname_ = 'lowerSpeed'
        elif nodeName_ == 'upperSpeed':
            class_obj_ = self.get_class_obj_(child_, AirspeedInIasOrMachType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.upperSpeed = obj_
            obj_.original_tagname_ = 'upperSpeed'
# end class AirspeedRangeType


class AltitudeChoiceType(GeneratedsSuper):
    """The altitude choice allows to either represent a specific altitude or an
    altitude
    range with a lower and upper bound"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, altitude=None, altitudeRange=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.altitude = altitude
        self.altitude_nsprefix_ = None
        self.altitudeRange = altitudeRange
        self.altitudeRange_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AltitudeChoiceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AltitudeChoiceType.subclass:
            return AltitudeChoiceType.subclass(*args_, **kwargs_)
        else:
            return AltitudeChoiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_altitude(self):
        return self.altitude
    def set_altitude(self, altitude):
        self.altitude = altitude
    def get_altitudeRange(self):
        return self.altitudeRange
    def set_altitudeRange(self, altitudeRange):
        self.altitudeRange = altitudeRange
    def hasContent_(self):
        if (
            self.altitude is not None or
            self.altitudeRange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='AltitudeChoiceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AltitudeChoiceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AltitudeChoiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AltitudeChoiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='AltitudeChoiceType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='AltitudeChoiceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.altitude is not None:
            namespaceprefix_ = self.altitude_nsprefix_ + ':' if (UseCapturedNS_ and self.altitude_nsprefix_) else ''
            self.altitude.export(outfile, level, namespaceprefix_, namespacedef_='', name_='altitude', pretty_print=pretty_print)
        if self.altitudeRange is not None:
            namespaceprefix_ = self.altitudeRange_nsprefix_ + ':' if (UseCapturedNS_ and self.altitudeRange_nsprefix_) else ''
            self.altitudeRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='altitudeRange', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'altitude':
            class_obj_ = self.get_class_obj_(child_, AltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.altitude = obj_
            obj_.original_tagname_ = 'altitude'
        elif nodeName_ == 'altitudeRange':
            obj_ = VerticalRangeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.altitudeRange = obj_
            obj_.original_tagname_ = 'altitudeRange'
# end class AltitudeChoiceType


class BeaconCodeType(GeneratedsSuper):
    """.Beacon Code: The assigned four-character numeric code transmitted by
    the aircraft
    transponder in response to a secondary surveillance radar interrogation
    signal which
    is used to assist air traffic controllers to identify aircraft.
    Optional Secondary Surveillance Radar (SSR) Mode."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ssrMode=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ssrMode = _cast(None, ssrMode)
        self.ssrMode_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BeaconCodeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BeaconCodeType.subclass:
            return BeaconCodeType.subclass(*args_, **kwargs_)
        else:
            return BeaconCodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ssrMode(self):
        return self.ssrMode
    def set_ssrMode(self, ssrMode):
        self.ssrMode = ssrMode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SsrModeType(self, value):
        # Validate type fb:SsrModeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'C', 'S']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SsrModeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='BeaconCodeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BeaconCodeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BeaconCodeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BeaconCodeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='BeaconCodeType'):
        if self.ssrMode is not None and 'ssrMode' not in already_processed:
            already_processed.add('ssrMode')
            outfile.write(' ssrMode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ssrMode), input_name='ssrMode')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='BeaconCodeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ssrMode', node)
        if value is not None and 'ssrMode' not in already_processed:
            already_processed.add('ssrMode')
            self.ssrMode = value
            self.validate_SsrModeType(self.ssrMode)    # validate type SsrModeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BeaconCodeType


class GloballyUniqueFlightIdentifierType(GeneratedsSuper):
    """A reference that uniquely identifies a specific flight and that is
    independent of
    any particular system.
    Code Space of the GUFI"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, codeSpace='urn:uuid', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.codeSpace = _cast(None, codeSpace)
        self.codeSpace_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GloballyUniqueFlightIdentifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GloballyUniqueFlightIdentifierType.subclass:
            return GloballyUniqueFlightIdentifierType.subclass(*args_, **kwargs_)
        else:
            return GloballyUniqueFlightIdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_codeSpace(self):
        return self.codeSpace
    def set_codeSpace(self, codeSpace):
        self.codeSpace = codeSpace
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='GloballyUniqueFlightIdentifierType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GloballyUniqueFlightIdentifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GloballyUniqueFlightIdentifierType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GloballyUniqueFlightIdentifierType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='GloballyUniqueFlightIdentifierType'):
        if self.codeSpace is not None and 'codeSpace' not in already_processed:
            already_processed.add('codeSpace')
            outfile.write(' codeSpace=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSpace), input_name='codeSpace')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='GloballyUniqueFlightIdentifierType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codeSpace', node)
        if value is not None and 'codeSpace' not in already_processed:
            already_processed.add('codeSpace')
            self.codeSpace = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class GloballyUniqueFlightIdentifierType


class GroundspeedChoiceType(GeneratedsSuper):
    """The groundspeed choice indicates that groundspeed can either be
    expressed as specific
    with a speed condition or a speed range between lower and upper bounds."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, groundspeed=None, groundspeedRange=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.groundspeed = groundspeed
        self.groundspeed_nsprefix_ = None
        self.groundspeedRange = groundspeedRange
        self.groundspeedRange_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GroundspeedChoiceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GroundspeedChoiceType.subclass:
            return GroundspeedChoiceType.subclass(*args_, **kwargs_)
        else:
            return GroundspeedChoiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_groundspeed(self):
        return self.groundspeed
    def set_groundspeed(self, groundspeed):
        self.groundspeed = groundspeed
    def get_groundspeedRange(self):
        return self.groundspeedRange
    def set_groundspeedRange(self, groundspeedRange):
        self.groundspeedRange = groundspeedRange
    def hasContent_(self):
        if (
            self.groundspeed is not None or
            self.groundspeedRange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='GroundspeedChoiceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GroundspeedChoiceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GroundspeedChoiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GroundspeedChoiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='GroundspeedChoiceType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='GroundspeedChoiceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.groundspeed is not None:
            namespaceprefix_ = self.groundspeed_nsprefix_ + ':' if (UseCapturedNS_ and self.groundspeed_nsprefix_) else ''
            self.groundspeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='groundspeed', pretty_print=pretty_print)
        if self.groundspeedRange is not None:
            namespaceprefix_ = self.groundspeedRange_nsprefix_ + ':' if (UseCapturedNS_ and self.groundspeedRange_nsprefix_) else ''
            self.groundspeedRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='groundspeedRange', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'groundspeed':
            obj_ = GroundspeedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.groundspeed = obj_
            obj_.original_tagname_ = 'groundspeed'
        elif nodeName_ == 'groundspeedRange':
            obj_ = GroundspeedRangeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.groundspeedRange = obj_
            obj_.original_tagname_ = 'groundspeedRange'
# end class GroundspeedChoiceType


class GroundspeedRangeType(GeneratedsSuper):
    """The groundspeed that can be expressed as a range between a lower and
    upper bound."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lowerSpeed=None, upperSpeed=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lowerSpeed = lowerSpeed
        self.lowerSpeed_nsprefix_ = None
        self.upperSpeed = upperSpeed
        self.upperSpeed_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GroundspeedRangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GroundspeedRangeType.subclass:
            return GroundspeedRangeType.subclass(*args_, **kwargs_)
        else:
            return GroundspeedRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lowerSpeed(self):
        return self.lowerSpeed
    def set_lowerSpeed(self, lowerSpeed):
        self.lowerSpeed = lowerSpeed
    def get_upperSpeed(self):
        return self.upperSpeed
    def set_upperSpeed(self, upperSpeed):
        self.upperSpeed = upperSpeed
    def hasContent_(self):
        if (
            self.lowerSpeed is not None or
            self.upperSpeed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"', name_='GroundspeedRangeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GroundspeedRangeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GroundspeedRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GroundspeedRangeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='GroundspeedRangeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"', name_='GroundspeedRangeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lowerSpeed is not None:
            namespaceprefix_ = self.lowerSpeed_nsprefix_ + ':' if (UseCapturedNS_ and self.lowerSpeed_nsprefix_) else ''
            self.lowerSpeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lowerSpeed', pretty_print=pretty_print)
        if self.upperSpeed is not None:
            namespaceprefix_ = self.upperSpeed_nsprefix_ + ':' if (UseCapturedNS_ and self.upperSpeed_nsprefix_) else ''
            self.upperSpeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='upperSpeed', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lowerSpeed':
            obj_ = GroundspeedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lowerSpeed = obj_
            obj_.original_tagname_ = 'lowerSpeed'
        elif nodeName_ == 'upperSpeed':
            obj_ = GroundspeedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.upperSpeed = obj_
            obj_.original_tagname_ = 'upperSpeed'
# end class GroundspeedRangeType


class LateralOfftrackType(GeneratedsSuper):
    """Represents a lateral offtrack which can either be an offset or weather
    deviation.
    Specifies the reason for Lateral Offtrack"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, offtrackReason=None, offtrackDistance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.offtrackReason = _cast(None, offtrackReason)
        self.offtrackReason_nsprefix_ = None
        if offtrackDistance is None:
            self.offtrackDistance = []
        else:
            self.offtrackDistance = offtrackDistance
        self.offtrackDistance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LateralOfftrackType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LateralOfftrackType.subclass:
            return LateralOfftrackType.subclass(*args_, **kwargs_)
        else:
            return LateralOfftrackType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_offtrackDistance(self):
        return self.offtrackDistance
    def set_offtrackDistance(self, offtrackDistance):
        self.offtrackDistance = offtrackDistance
    def add_offtrackDistance(self, value):
        self.offtrackDistance.append(value)
    def insert_offtrackDistance_at(self, index, value):
        self.offtrackDistance.insert(index, value)
    def replace_offtrackDistance_at(self, index, value):
        self.offtrackDistance[index] = value
    def get_offtrackReason(self):
        return self.offtrackReason
    def set_offtrackReason(self, offtrackReason):
        self.offtrackReason = offtrackReason
    def validate_OfftrackReasonType(self, value):
        # Validate type fb:OfftrackReasonType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OFFSET', 'DEVIATION']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OfftrackReasonType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.offtrackDistance
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='LateralOfftrackType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LateralOfftrackType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LateralOfftrackType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LateralOfftrackType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='LateralOfftrackType'):
        if self.offtrackReason is not None and 'offtrackReason' not in already_processed:
            already_processed.add('offtrackReason')
            outfile.write(' offtrackReason=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.offtrackReason), input_name='offtrackReason')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='LateralOfftrackType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for offtrackDistance_ in self.offtrackDistance:
            namespaceprefix_ = self.offtrackDistance_nsprefix_ + ':' if (UseCapturedNS_ and self.offtrackDistance_nsprefix_) else ''
            offtrackDistance_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offtrackDistance', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('offtrackReason', node)
        if value is not None and 'offtrackReason' not in already_processed:
            already_processed.add('offtrackReason')
            self.offtrackReason = value
            self.validate_OfftrackReasonType(self.offtrackReason)    # validate type OfftrackReasonType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'offtrackDistance':
            obj_ = OfftrackDistanceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offtrackDistance.append(obj_)
            obj_.original_tagname_ = 'offtrackDistance'
# end class LateralOfftrackType


class NameValueListType(GeneratedsSuper):
    """A basic list of name/value pairs.
    The name/value list structure is intended for use in the RARE situations
    where otherwise
    unstructured data can be rendered into a semi-structure of tags and data.
    It is not
    appropriate for adding arbitrary data to arbitrary places in the schema."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nameValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if nameValue is None:
            self.nameValue = []
        else:
            self.nameValue = nameValue
        self.nameValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameValueListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameValueListType.subclass:
            return NameValueListType.subclass(*args_, **kwargs_)
        else:
            return NameValueListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nameValue(self):
        return self.nameValue
    def set_nameValue(self, nameValue):
        self.nameValue = nameValue
    def add_nameValue(self, value):
        self.nameValue.append(value)
    def insert_nameValue_at(self, index, value):
        self.nameValue.insert(index, value)
    def replace_nameValue_at(self, index, value):
        self.nameValue[index] = value
    def hasContent_(self):
        if (
            self.nameValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='NameValueListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NameValueListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NameValueListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NameValueListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='NameValueListType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='NameValueListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for nameValue_ in self.nameValue:
            namespaceprefix_ = self.nameValue_nsprefix_ + ':' if (UseCapturedNS_ and self.nameValue_nsprefix_) else ''
            nameValue_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nameValue', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nameValue':
            obj_ = NameValuePairType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nameValue.append(obj_)
            obj_.original_tagname_ = 'nameValue'
# end class NameValueListType


class NameValuePairType(GeneratedsSuper):
    """This is a general purpose data structure used when it is desired to map
    an identifying
    string (the "name") into a data string (the "value"). These name/value
    pairs are
    often part of a repeating element so that the whole element expresses a set
    of names
    mapped onto a set of values.
    The identifying portion of the pair, formatted as if for an enumeration.
    Consider
    using an actual enumeration for legal values.
    The data content portion of the pair. This is intended for a *short*
    unstructured
    string like a natural language comment, and should not be used as storage
    for codes,
    values, or other structured data."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameValuePairType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameValuePairType.subclass:
            return NameValuePairType.subclass(*args_, **kwargs_)
        else:
            return NameValuePairType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='NameValuePairType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NameValuePairType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NameValuePairType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NameValuePairType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='NameValuePairType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='NameValuePairType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FreeTextType(self.name)    # validate type FreeTextType
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_FreeTextType(self.value)    # validate type FreeTextType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NameValuePairType


class OfftrackDistanceType(GeneratedsSuper):
    """Represents an offtrack distance that is lateral relative to a location
    expressed
    by a distance measurement and offset direction.
    Specifies the direction of the offset"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, direction=None, distance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.direction = _cast(None, direction)
        self.direction_nsprefix_ = None
        self.distance = distance
        self.distance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OfftrackDistanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OfftrackDistanceType.subclass:
            return OfftrackDistanceType.subclass(*args_, **kwargs_)
        else:
            return OfftrackDistanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_distance(self):
        return self.distance
    def set_distance(self, distance):
        self.distance = distance
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def validate_OfftrackDirectionType(self, value):
        # Validate type fb:OfftrackDirectionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LEFT', 'RIGHT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OfftrackDirectionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.distance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"', name_='OfftrackDistanceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OfftrackDistanceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OfftrackDistanceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OfftrackDistanceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='OfftrackDistanceType'):
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            outfile.write(' direction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.direction), input_name='direction')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"', name_='OfftrackDistanceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.distance is not None:
            namespaceprefix_ = self.distance_nsprefix_ + ':' if (UseCapturedNS_ and self.distance_nsprefix_) else ''
            self.distance.export(outfile, level, namespaceprefix_, namespacedef_='', name_='distance', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            self.direction = value
            self.validate_OfftrackDirectionType(self.direction)    # validate type OfftrackDirectionType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'distance':
            class_obj_ = self.get_class_obj_(child_, DistanceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.distance = obj_
            obj_.original_tagname_ = 'distance'
# end class OfftrackDistanceType


class RadioFrequencyType(GeneratedsSuper):
    """RadioFrequency is the designation of a communication frequency in the
    HF, UHF, VHF,
    EHF bands
    Required unit of measure for RadioFrequency in KHz OR MHz."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.uom = _cast(None, uom)
        self.uom_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadioFrequencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadioFrequencyType.subclass:
            return RadioFrequencyType.subclass(*args_, **kwargs_)
        else:
            return RadioFrequencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_FrequencyMeasureType(self, value):
        # Validate type fb:FrequencyMeasureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MEGAHERTZ', 'KILOHERTZ']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FrequencyMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='RadioFrequencyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RadioFrequencyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RadioFrequencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RadioFrequencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='RadioFrequencyType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='RadioFrequencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
            self.validate_FrequencyMeasureType(self.uom)    # validate type FrequencyMeasureType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RadioFrequencyType


class SpeedType(AirspeedInIasOrMachType):
    """The airspeed can be expressed as a specific speed with a condition.
    The speed condition indicates whether the aircraft will be maintaining,
    exceeding,
    or flying more slowly than the assigned boundary crossing speed."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AirspeedInIasOrMachType
    def __init__(self, uom=None, speedCondition=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SpeedType, self).__init__(uom, valueOf_,  **kwargs_)
        self.speedCondition = _cast(None, speedCondition)
        self.speedCondition_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpeedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpeedType.subclass:
            return SpeedType.subclass(*args_, **kwargs_)
        else:
            return SpeedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_speedCondition(self):
        return self.speedCondition
    def set_speedCondition(self, speedCondition):
        self.speedCondition = speedCondition
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SpeedConditionType(self, value):
        # Validate type fb:SpeedConditionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AT_OR_LESS', 'AT_OR_GREATER', 'AT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SpeedConditionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(SpeedType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='SpeedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpeedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpeedType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpeedType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='SpeedType'):
        super(SpeedType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpeedType')
        if self.speedCondition is not None and 'speedCondition' not in already_processed:
            already_processed.add('speedCondition')
            outfile.write(' speedCondition=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.speedCondition), input_name='speedCondition')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='SpeedType', fromsubclass_=False, pretty_print=True):
        super(SpeedType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('speedCondition', node)
        if value is not None and 'speedCondition' not in already_processed:
            already_processed.add('speedCondition')
            self.speedCondition = value
            self.validate_SpeedConditionType(self.speedCondition)    # validate type SpeedConditionType
        super(SpeedType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SpeedType


class VerticalRangeType(GeneratedsSuper):
    """Represents a vertical range from a lower bound altitude to an upper
    bound altitude."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lowerBound=None, upperBound=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lowerBound = lowerBound
        self.lowerBound_nsprefix_ = None
        self.upperBound = upperBound
        self.upperBound_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalRangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalRangeType.subclass:
            return VerticalRangeType.subclass(*args_, **kwargs_)
        else:
            return VerticalRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lowerBound(self):
        return self.lowerBound
    def set_lowerBound(self, lowerBound):
        self.lowerBound = lowerBound
    def get_upperBound(self):
        return self.upperBound
    def set_upperBound(self, upperBound):
        self.upperBound = upperBound
    def hasContent_(self):
        if (
            self.lowerBound is not None or
            self.upperBound is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"', name_='VerticalRangeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VerticalRangeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VerticalRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VerticalRangeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='VerticalRangeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"', name_='VerticalRangeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lowerBound is not None:
            namespaceprefix_ = self.lowerBound_nsprefix_ + ':' if (UseCapturedNS_ and self.lowerBound_nsprefix_) else ''
            self.lowerBound.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lowerBound', pretty_print=pretty_print)
        if self.upperBound is not None:
            namespaceprefix_ = self.upperBound_nsprefix_ + ':' if (UseCapturedNS_ and self.upperBound_nsprefix_) else ''
            self.upperBound.export(outfile, level, namespaceprefix_, namespacedef_='', name_='upperBound', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lowerBound':
            class_obj_ = self.get_class_obj_(child_, AltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lowerBound = obj_
            obj_.original_tagname_ = 'lowerBound'
        elif nodeName_ == 'upperBound':
            class_obj_ = self.get_class_obj_(child_, AltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.upperBound = obj_
            obj_.original_tagname_ = 'upperBound'
# end class VerticalRangeType


class ExtensionType(FeatureType):
    """The Extension type is the base type from which extension (non-core)
    objects inherit.
    Extension objects can be attached to a Flight through the "extensions"
    element."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FeatureType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ExtensionType, self).__init__(centre, source, system, timestamp,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExtensionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExtensionType.subclass:
            return ExtensionType.subclass(*args_, **kwargs_)
        else:
            return ExtensionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (
            super(ExtensionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='ExtensionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExtensionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExtensionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExtensionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='ExtensionType'):
        super(ExtensionType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExtensionType')
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='ExtensionType', fromsubclass_=False, pretty_print=True):
        super(ExtensionType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExtensionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ExtensionType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExtensionType


class AircraftType(FeatureType):
    """This is a main aircraft class that contains all the information about
    the aircraft.
    .Aircraft Address: A code that enables the exchange of text-based messages
    between
    suitably equipped Air Traffic Service (ATS) ground systems and aircraft
    cockpit displays.
    .Aircraft Colour and Markings: The colours of the aircraft and a
    description of the
    aircraft's significant markings.
    .Aircraft Performance Category: A coded category assigned to the aircraft
    based on
    a speed directly proportional to its stall speed, which functions as a
    standardized
    basis for relating aircraft manoeuvrability to specific instrument approach
    procedures.
    .Aircraft Quantity: Number of aircraft flying in a formation in which the
    aircraft
    are governed by one flight plan.
    .Engine Type: The category of the aircraft engine.
    .Aircraft Registration Mark: A unique, alphanumeric string that identifies
    a civil
    aircraft and consists of the Aircraft Nationality or Common Mark and an
    additional
    alphanumeric string assigned by the state of registry or common mark
    registering
    authority.
    .Wake Turbulence Category: ICAO classification of the aircraft wake
    turbulence, based
    on the maximum certified take off mass."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FeatureType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, aircraftAddress=None, aircraftColours=None, aircraftPerformance=None, aircraftQuantity=None, engineType=None, registration=None, wakeTurbulence=None, aircraftType=None, capabilities=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AircraftType, self).__init__(centre, source, system, timestamp,  **kwargs_)
        self.aircraftAddress = _cast(None, aircraftAddress)
        self.aircraftAddress_nsprefix_ = None
        self.aircraftColours = _cast(None, aircraftColours)
        self.aircraftColours_nsprefix_ = None
        self.aircraftPerformance = _cast(None, aircraftPerformance)
        self.aircraftPerformance_nsprefix_ = None
        self.aircraftQuantity = _cast(None, aircraftQuantity)
        self.aircraftQuantity_nsprefix_ = None
        self.engineType = _cast(None, engineType)
        self.engineType_nsprefix_ = None
        self.registration = _cast(None, registration)
        self.registration_nsprefix_ = None
        self.wakeTurbulence = _cast(None, wakeTurbulence)
        self.wakeTurbulence_nsprefix_ = None
        self.aircraftType = aircraftType
        self.aircraftType_nsprefix_ = None
        self.capabilities = capabilities
        self.capabilities_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AircraftType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AircraftType.subclass:
            return AircraftType.subclass(*args_, **kwargs_)
        else:
            return AircraftType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_aircraftType(self):
        return self.aircraftType
    def set_aircraftType(self, aircraftType):
        self.aircraftType = aircraftType
    def get_capabilities(self):
        return self.capabilities
    def set_capabilities(self, capabilities):
        self.capabilities = capabilities
    def get_aircraftAddress(self):
        return self.aircraftAddress
    def set_aircraftAddress(self, aircraftAddress):
        self.aircraftAddress = aircraftAddress
    def get_aircraftColours(self):
        return self.aircraftColours
    def set_aircraftColours(self, aircraftColours):
        self.aircraftColours = aircraftColours
    def get_aircraftPerformance(self):
        return self.aircraftPerformance
    def set_aircraftPerformance(self, aircraftPerformance):
        self.aircraftPerformance = aircraftPerformance
    def get_aircraftQuantity(self):
        return self.aircraftQuantity
    def set_aircraftQuantity(self, aircraftQuantity):
        self.aircraftQuantity = aircraftQuantity
    def get_engineType(self):
        return self.engineType
    def set_engineType(self, engineType):
        self.engineType = engineType
    def get_registration(self):
        return self.registration
    def set_registration(self, registration):
        self.registration = registration
    def get_wakeTurbulence(self):
        return self.wakeTurbulence
    def set_wakeTurbulence(self, wakeTurbulence):
        self.wakeTurbulence = wakeTurbulence
    def validate_AircraftAddressType(self, value):
        # Validate type fx:AircraftAddressType, a restriction on fb:FreeTextType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on AircraftAddressType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on AircraftAddressType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AircraftAddressType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AircraftAddressType_patterns_, ))
    validate_AircraftAddressType_patterns_ = [['^([0-9A-F]{6})$']]
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_AircraftPerformanceCategoryType(self, value):
        # Validate type fx:AircraftPerformanceCategoryType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'B', 'C', 'D', 'E', 'H']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AircraftPerformanceCategoryType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_CountType(self, value):
        # Validate type fb:CountType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on CountType' % {"value": value, "lineno": lineno} )
                result = False
    def validate_EngineTypeType(self, value):
        # Validate type fx:EngineTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PISTON', 'TURBO_PROP', 'TURBO_SHAFT', 'TURBO_JET', 'TURBO_FAN', 'PROP_FAN']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EngineTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_AircraftRegistrationType(self, value):
        # Validate type fx:AircraftRegistrationType, a restriction on fb:FreeTextType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on AircraftRegistrationType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on AircraftRegistrationType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_AircraftRegistrationType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AircraftRegistrationType_patterns_, ))
    validate_AircraftRegistrationType_patterns_ = [['^([A-Z0-9]{1,7})$']]
    def validate_WakeTurbulenceCategoryType(self, value):
        # Validate type fx:WakeTurbulenceCategoryType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['L', 'M', 'H', 'J']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on WakeTurbulenceCategoryType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.aircraftType is not None or
            self.capabilities is not None or
            super(AircraftType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='AircraftType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AircraftType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AircraftType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AircraftType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='AircraftType'):
        super(AircraftType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AircraftType')
        if self.aircraftAddress is not None and 'aircraftAddress' not in already_processed:
            already_processed.add('aircraftAddress')
            outfile.write(' aircraftAddress=%s' % (quote_attrib(self.aircraftAddress), ))
        if self.aircraftColours is not None and 'aircraftColours' not in already_processed:
            already_processed.add('aircraftColours')
            outfile.write(' aircraftColours=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aircraftColours), input_name='aircraftColours')), ))
        if self.aircraftPerformance is not None and 'aircraftPerformance' not in already_processed:
            already_processed.add('aircraftPerformance')
            outfile.write(' aircraftPerformance=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aircraftPerformance), input_name='aircraftPerformance')), ))
        if self.aircraftQuantity is not None and 'aircraftQuantity' not in already_processed:
            already_processed.add('aircraftQuantity')
            outfile.write(' aircraftQuantity="%s"' % self.gds_format_integer(self.aircraftQuantity, input_name='aircraftQuantity'))
        if self.engineType is not None and 'engineType' not in already_processed:
            already_processed.add('engineType')
            outfile.write(' engineType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.engineType), input_name='engineType')), ))
        if self.registration is not None and 'registration' not in already_processed:
            already_processed.add('registration')
            outfile.write(' registration=%s' % (quote_attrib(self.registration), ))
        if self.wakeTurbulence is not None and 'wakeTurbulence' not in already_processed:
            already_processed.add('wakeTurbulence')
            outfile.write(' wakeTurbulence=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.wakeTurbulence), input_name='wakeTurbulence')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='AircraftType', fromsubclass_=False, pretty_print=True):
        super(AircraftType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.aircraftType is not None:
            namespaceprefix_ = self.aircraftType_nsprefix_ + ':' if (UseCapturedNS_ and self.aircraftType_nsprefix_) else ''
            self.aircraftType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='aircraftType', pretty_print=pretty_print)
        if self.capabilities is not None:
            namespaceprefix_ = self.capabilities_nsprefix_ + ':' if (UseCapturedNS_ and self.capabilities_nsprefix_) else ''
            self.capabilities.export(outfile, level, namespaceprefix_, namespacedef_='', name_='capabilities', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aircraftAddress', node)
        if value is not None and 'aircraftAddress' not in already_processed:
            already_processed.add('aircraftAddress')
            self.aircraftAddress = value
            self.validate_AircraftAddressType(self.aircraftAddress)    # validate type AircraftAddressType
        value = find_attr_value_('aircraftColours', node)
        if value is not None and 'aircraftColours' not in already_processed:
            already_processed.add('aircraftColours')
            self.aircraftColours = value
            self.validate_FreeTextType(self.aircraftColours)    # validate type FreeTextType
        value = find_attr_value_('aircraftPerformance', node)
        if value is not None and 'aircraftPerformance' not in already_processed:
            already_processed.add('aircraftPerformance')
            self.aircraftPerformance = value
            self.validate_AircraftPerformanceCategoryType(self.aircraftPerformance)    # validate type AircraftPerformanceCategoryType
        value = find_attr_value_('aircraftQuantity', node)
        if value is not None and 'aircraftQuantity' not in already_processed:
            already_processed.add('aircraftQuantity')
            self.aircraftQuantity = self.gds_parse_integer(value, node, 'aircraftQuantity')
            self.validate_CountType(self.aircraftQuantity)    # validate type CountType
        value = find_attr_value_('engineType', node)
        if value is not None and 'engineType' not in already_processed:
            already_processed.add('engineType')
            self.engineType = value
            self.validate_EngineTypeType(self.engineType)    # validate type EngineTypeType
        value = find_attr_value_('registration', node)
        if value is not None and 'registration' not in already_processed:
            already_processed.add('registration')
            self.registration = value
            self.validate_AircraftRegistrationType(self.registration)    # validate type AircraftRegistrationType
        value = find_attr_value_('wakeTurbulence', node)
        if value is not None and 'wakeTurbulence' not in already_processed:
            already_processed.add('wakeTurbulence')
            self.wakeTurbulence = value
            self.validate_WakeTurbulenceCategoryType(self.wakeTurbulence)    # validate type WakeTurbulenceCategoryType
        super(AircraftType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'aircraftType':
            obj_ = AircraftTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.aircraftType = obj_
            obj_.original_tagname_ = 'aircraftType'
        elif nodeName_ == 'capabilities':
            obj_ = AircraftCapabilitiesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.capabilities = obj_
            obj_.original_tagname_ = 'capabilities'
        super(AircraftType, self).buildChildren(child_, node, nodeName_, True)
# end class AircraftType


class AircraftCapabilitiesType(GeneratedsSuper):
    """Groups all the aircraft's capabilities.
    if present, indicates that aircraft has the "standard" capabilities for the
    flight."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, standardCapabilities=None, communication=None, navigation=None, surveillance=None, survival=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.standardCapabilities = _cast(None, standardCapabilities)
        self.standardCapabilities_nsprefix_ = None
        self.communication = communication
        self.communication_nsprefix_ = None
        self.navigation = navigation
        self.navigation_nsprefix_ = None
        self.surveillance = surveillance
        self.surveillance_nsprefix_ = None
        self.survival = survival
        self.survival_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AircraftCapabilitiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AircraftCapabilitiesType.subclass:
            return AircraftCapabilitiesType.subclass(*args_, **kwargs_)
        else:
            return AircraftCapabilitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_communication(self):
        return self.communication
    def set_communication(self, communication):
        self.communication = communication
    def get_navigation(self):
        return self.navigation
    def set_navigation(self, navigation):
        self.navigation = navigation
    def get_surveillance(self):
        return self.surveillance
    def set_surveillance(self, surveillance):
        self.surveillance = surveillance
    def get_survival(self):
        return self.survival
    def set_survival(self, survival):
        self.survival = survival
    def get_standardCapabilities(self):
        return self.standardCapabilities
    def set_standardCapabilities(self, standardCapabilities):
        self.standardCapabilities = standardCapabilities
    def validate_StandardCapabilitiesIndicatorType(self, value):
        # Validate type fx:StandardCapabilitiesIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['STANDARD']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StandardCapabilitiesIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.communication is not None or
            self.navigation is not None or
            self.surveillance is not None or
            self.survival is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='AircraftCapabilitiesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AircraftCapabilitiesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AircraftCapabilitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AircraftCapabilitiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='AircraftCapabilitiesType'):
        if self.standardCapabilities is not None and 'standardCapabilities' not in already_processed:
            already_processed.add('standardCapabilities')
            outfile.write(' standardCapabilities=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.standardCapabilities), input_name='standardCapabilities')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='AircraftCapabilitiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.communication is not None:
            namespaceprefix_ = self.communication_nsprefix_ + ':' if (UseCapturedNS_ and self.communication_nsprefix_) else ''
            self.communication.export(outfile, level, namespaceprefix_, namespacedef_='', name_='communication', pretty_print=pretty_print)
        if self.navigation is not None:
            namespaceprefix_ = self.navigation_nsprefix_ + ':' if (UseCapturedNS_ and self.navigation_nsprefix_) else ''
            self.navigation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='navigation', pretty_print=pretty_print)
        if self.surveillance is not None:
            namespaceprefix_ = self.surveillance_nsprefix_ + ':' if (UseCapturedNS_ and self.surveillance_nsprefix_) else ''
            self.surveillance.export(outfile, level, namespaceprefix_, namespacedef_='', name_='surveillance', pretty_print=pretty_print)
        if self.survival is not None:
            namespaceprefix_ = self.survival_nsprefix_ + ':' if (UseCapturedNS_ and self.survival_nsprefix_) else ''
            self.survival.export(outfile, level, namespaceprefix_, namespacedef_='', name_='survival', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('standardCapabilities', node)
        if value is not None and 'standardCapabilities' not in already_processed:
            already_processed.add('standardCapabilities')
            self.standardCapabilities = value
            self.validate_StandardCapabilitiesIndicatorType(self.standardCapabilities)    # validate type StandardCapabilitiesIndicatorType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'communication':
            obj_ = CommunicationCapabilitiesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.communication = obj_
            obj_.original_tagname_ = 'communication'
        elif nodeName_ == 'navigation':
            obj_ = NavigationCapabilitiesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.navigation = obj_
            obj_.original_tagname_ = 'navigation'
        elif nodeName_ == 'surveillance':
            obj_ = SurveillanceCapabilitiesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.surveillance = obj_
            obj_.original_tagname_ = 'surveillance'
        elif nodeName_ == 'survival':
            obj_ = SurvivalCapabilitiesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.survival = obj_
            obj_.original_tagname_ = 'survival'
# end class AircraftCapabilitiesType


class AircraftTypeType(GeneratedsSuper):
    """.Aircraft Type: The manufacturer and model of the airframe expressed
    either as an
    ICAO-approved designator or a text description."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, icaoModelIdentifier=None, otherModelData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.icaoModelIdentifier = icaoModelIdentifier
        self.validate_IcaoAircraftIdentifierType(self.icaoModelIdentifier)
        self.icaoModelIdentifier_nsprefix_ = None
        self.otherModelData = otherModelData
        self.validate_FreeTextType(self.otherModelData)
        self.otherModelData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AircraftTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AircraftTypeType.subclass:
            return AircraftTypeType.subclass(*args_, **kwargs_)
        else:
            return AircraftTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_icaoModelIdentifier(self):
        return self.icaoModelIdentifier
    def set_icaoModelIdentifier(self, icaoModelIdentifier):
        self.icaoModelIdentifier = icaoModelIdentifier
    def get_otherModelData(self):
        return self.otherModelData
    def set_otherModelData(self, otherModelData):
        self.otherModelData = otherModelData
    def validate_IcaoAircraftIdentifierType(self, value):
        result = True
        # Validate type IcaoAircraftIdentifierType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_IcaoAircraftIdentifierType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IcaoAircraftIdentifierType_patterns_, ))
                result = False
        return result
    validate_IcaoAircraftIdentifierType_patterns_ = [['^([A-Z0-9]{2,4})$']]
    def validate_FreeTextType(self, value):
        result = True
        # Validate type FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.icaoModelIdentifier is not None or
            self.otherModelData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='AircraftTypeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AircraftTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AircraftTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AircraftTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='AircraftTypeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='AircraftTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.icaoModelIdentifier is not None:
            namespaceprefix_ = self.icaoModelIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.icaoModelIdentifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sicaoModelIdentifier>%s</%sicaoModelIdentifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.icaoModelIdentifier), input_name='icaoModelIdentifier')), namespaceprefix_ , eol_))
        if self.otherModelData is not None:
            namespaceprefix_ = self.otherModelData_nsprefix_ + ':' if (UseCapturedNS_ and self.otherModelData_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sotherModelData>%s</%sotherModelData>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.otherModelData), input_name='otherModelData')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'icaoModelIdentifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'icaoModelIdentifier')
            value_ = self.gds_validate_string(value_, node, 'icaoModelIdentifier')
            self.icaoModelIdentifier = value_
            self.icaoModelIdentifier_nsprefix_ = child_.prefix
            # validate type IcaoAircraftIdentifierType
            self.validate_IcaoAircraftIdentifierType(self.icaoModelIdentifier)
        elif nodeName_ == 'otherModelData':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'otherModelData')
            value_ = self.gds_validate_string(value_, node, 'otherModelData')
            self.otherModelData = value_
            self.otherModelData_nsprefix_ = child_.prefix
            # validate type FreeTextType
            self.validate_FreeTextType(self.otherModelData)
# end class AircraftTypeType


class CommunicationCapabilitiesType(GeneratedsSuper):
    """.Communications Capabilities: The serviceable communications equipment,
    available
    on the aircraft at the time of flight, and associated flight crew
    qualifications
    that may be used to communicate with ATS units.
    Additional Communication capabilities available on the aircraft.
    Additional data link capabilities available on the aircraft.
    .Selective Calling Code: A code that consists of two 2-letter pairs and
    acts as a
    paging system for an ATS unit to establish voice communications with the
    pilot of
    an aircraft."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, otherCommunicationCapabilities=None, otherDataLinkCapabilities=None, selectiveCallingCode=None, communicationCode=None, dataLinkCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.otherCommunicationCapabilities = _cast(None, otherCommunicationCapabilities)
        self.otherCommunicationCapabilities_nsprefix_ = None
        self.otherDataLinkCapabilities = _cast(None, otherDataLinkCapabilities)
        self.otherDataLinkCapabilities_nsprefix_ = None
        self.selectiveCallingCode = _cast(None, selectiveCallingCode)
        self.selectiveCallingCode_nsprefix_ = None
        self.communicationCode = communicationCode
        self.validate_communicationCodeType(self.communicationCode)
        self.communicationCode_nsprefix_ = None
        self.dataLinkCode = dataLinkCode
        self.validate_dataLinkCodeType(self.dataLinkCode)
        self.dataLinkCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommunicationCapabilitiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommunicationCapabilitiesType.subclass:
            return CommunicationCapabilitiesType.subclass(*args_, **kwargs_)
        else:
            return CommunicationCapabilitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_communicationCode(self):
        return self.communicationCode
    def set_communicationCode(self, communicationCode):
        self.communicationCode = communicationCode
    def get_dataLinkCode(self):
        return self.dataLinkCode
    def set_dataLinkCode(self, dataLinkCode):
        self.dataLinkCode = dataLinkCode
    def get_otherCommunicationCapabilities(self):
        return self.otherCommunicationCapabilities
    def set_otherCommunicationCapabilities(self, otherCommunicationCapabilities):
        self.otherCommunicationCapabilities = otherCommunicationCapabilities
    def get_otherDataLinkCapabilities(self):
        return self.otherDataLinkCapabilities
    def set_otherDataLinkCapabilities(self, otherDataLinkCapabilities):
        self.otherDataLinkCapabilities = otherDataLinkCapabilities
    def get_selectiveCallingCode(self):
        return self.selectiveCallingCode
    def set_selectiveCallingCode(self, selectiveCallingCode):
        self.selectiveCallingCode = selectiveCallingCode
    def validate_communicationCodeType(self, value):
        result = True
        # Validate type communicationCodeType, a restriction on fx:CommunicationCodeType.
        pass
        return result
    def validate_dataLinkCodeType(self, value):
        result = True
        # Validate type dataLinkCodeType, a restriction on fx:DataLinkCodeType.
        pass
        return result
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_SelectiveCallingCodeType(self, value):
        # Validate type fx:SelectiveCallingCodeType, a restriction on fb:FreeTextType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SelectiveCallingCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SelectiveCallingCodeType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SelectiveCallingCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SelectiveCallingCodeType_patterns_, ))
    validate_SelectiveCallingCodeType_patterns_ = [['^([A-HJ-MP-S]{4})$']]
    def hasContent_(self):
        if (
            self.communicationCode is not None or
            self.dataLinkCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='CommunicationCapabilitiesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CommunicationCapabilitiesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CommunicationCapabilitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CommunicationCapabilitiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='CommunicationCapabilitiesType'):
        if self.otherCommunicationCapabilities is not None and 'otherCommunicationCapabilities' not in already_processed:
            already_processed.add('otherCommunicationCapabilities')
            outfile.write(' otherCommunicationCapabilities=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.otherCommunicationCapabilities), input_name='otherCommunicationCapabilities')), ))
        if self.otherDataLinkCapabilities is not None and 'otherDataLinkCapabilities' not in already_processed:
            already_processed.add('otherDataLinkCapabilities')
            outfile.write(' otherDataLinkCapabilities=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.otherDataLinkCapabilities), input_name='otherDataLinkCapabilities')), ))
        if self.selectiveCallingCode is not None and 'selectiveCallingCode' not in already_processed:
            already_processed.add('selectiveCallingCode')
            outfile.write(' selectiveCallingCode=%s' % (quote_attrib(self.selectiveCallingCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='CommunicationCapabilitiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.communicationCode is not None:
            namespaceprefix_ = self.communicationCode_nsprefix_ + ':' if (UseCapturedNS_ and self.communicationCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommunicationCode>%s</%scommunicationCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(' '.join(self.communicationCode)), input_name='communicationCode')), namespaceprefix_ , eol_))
        if self.dataLinkCode is not None:
            namespaceprefix_ = self.dataLinkCode_nsprefix_ + ':' if (UseCapturedNS_ and self.dataLinkCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdataLinkCode>%s</%sdataLinkCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(' '.join(self.dataLinkCode)), input_name='dataLinkCode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('otherCommunicationCapabilities', node)
        if value is not None and 'otherCommunicationCapabilities' not in already_processed:
            already_processed.add('otherCommunicationCapabilities')
            self.otherCommunicationCapabilities = value
            self.validate_FreeTextType(self.otherCommunicationCapabilities)    # validate type FreeTextType
        value = find_attr_value_('otherDataLinkCapabilities', node)
        if value is not None and 'otherDataLinkCapabilities' not in already_processed:
            already_processed.add('otherDataLinkCapabilities')
            self.otherDataLinkCapabilities = value
            self.validate_FreeTextType(self.otherDataLinkCapabilities)    # validate type FreeTextType
        value = find_attr_value_('selectiveCallingCode', node)
        if value is not None and 'selectiveCallingCode' not in already_processed:
            already_processed.add('selectiveCallingCode')
            self.selectiveCallingCode = value
            self.validate_SelectiveCallingCodeType(self.selectiveCallingCode)    # validate type SelectiveCallingCodeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'communicationCode':
            value_ = child_.text
            self.communicationCode = value_
            self.communicationCode_nsprefix_ = child_.prefix
            # validate type communicationCodeType
            self.validate_communicationCodeType(self.communicationCode)
        elif nodeName_ == 'dataLinkCode':
            value_ = child_.text
            self.dataLinkCode = value_
            self.dataLinkCode_nsprefix_ = child_.prefix
            # validate type dataLinkCodeType
            self.validate_dataLinkCodeType(self.dataLinkCode)
# end class CommunicationCapabilitiesType


class NavigationCapabilitiesType(GeneratedsSuper):
    """.Navigation Capabilities: The serviceable navigation equipment available
    on board
    the aircraft at the time of flight and for which the flight crew is
    qualified.
    Additional navigation capabilities available on board the aircraft."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, otherNavigationCapabilities=None, navigationCode=None, performanceBasedCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.otherNavigationCapabilities = _cast(None, otherNavigationCapabilities)
        self.otherNavigationCapabilities_nsprefix_ = None
        self.navigationCode = navigationCode
        self.validate_navigationCodeType(self.navigationCode)
        self.navigationCode_nsprefix_ = None
        self.performanceBasedCode = performanceBasedCode
        self.validate_performanceBasedCodeType(self.performanceBasedCode)
        self.performanceBasedCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NavigationCapabilitiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NavigationCapabilitiesType.subclass:
            return NavigationCapabilitiesType.subclass(*args_, **kwargs_)
        else:
            return NavigationCapabilitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_navigationCode(self):
        return self.navigationCode
    def set_navigationCode(self, navigationCode):
        self.navigationCode = navigationCode
    def get_performanceBasedCode(self):
        return self.performanceBasedCode
    def set_performanceBasedCode(self, performanceBasedCode):
        self.performanceBasedCode = performanceBasedCode
    def get_otherNavigationCapabilities(self):
        return self.otherNavigationCapabilities
    def set_otherNavigationCapabilities(self, otherNavigationCapabilities):
        self.otherNavigationCapabilities = otherNavigationCapabilities
    def validate_navigationCodeType(self, value):
        result = True
        # Validate type navigationCodeType, a restriction on fx:NavigationCodeType.
        pass
        return result
    def validate_performanceBasedCodeType(self, value):
        result = True
        # Validate type performanceBasedCodeType, a restriction on fx:PerformanceBasedCodeType.
        pass
        return result
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.navigationCode is not None or
            self.performanceBasedCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='NavigationCapabilitiesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NavigationCapabilitiesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NavigationCapabilitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NavigationCapabilitiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='NavigationCapabilitiesType'):
        if self.otherNavigationCapabilities is not None and 'otherNavigationCapabilities' not in already_processed:
            already_processed.add('otherNavigationCapabilities')
            outfile.write(' otherNavigationCapabilities=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.otherNavigationCapabilities), input_name='otherNavigationCapabilities')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='NavigationCapabilitiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.navigationCode is not None:
            namespaceprefix_ = self.navigationCode_nsprefix_ + ':' if (UseCapturedNS_ and self.navigationCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snavigationCode>%s</%snavigationCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(' '.join(self.navigationCode)), input_name='navigationCode')), namespaceprefix_ , eol_))
        if self.performanceBasedCode is not None:
            namespaceprefix_ = self.performanceBasedCode_nsprefix_ + ':' if (UseCapturedNS_ and self.performanceBasedCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sperformanceBasedCode>%s</%sperformanceBasedCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(' '.join(self.performanceBasedCode)), input_name='performanceBasedCode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('otherNavigationCapabilities', node)
        if value is not None and 'otherNavigationCapabilities' not in already_processed:
            already_processed.add('otherNavigationCapabilities')
            self.otherNavigationCapabilities = value
            self.validate_FreeTextType(self.otherNavigationCapabilities)    # validate type FreeTextType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'navigationCode':
            value_ = child_.text
            self.navigationCode = value_
            self.navigationCode_nsprefix_ = child_.prefix
            # validate type navigationCodeType
            self.validate_navigationCodeType(self.navigationCode)
        elif nodeName_ == 'performanceBasedCode':
            value_ = child_.text
            self.performanceBasedCode = value_
            self.performanceBasedCode_nsprefix_ = child_.prefix
            # validate type performanceBasedCodeType
            self.validate_performanceBasedCodeType(self.performanceBasedCode)
# end class NavigationCapabilitiesType


class SurveillanceCapabilitiesType(GeneratedsSuper):
    """.Surveillance Capabilities: The serviceable Secondary Surveillance Radar
    (SSR) and/or
    Automatic Dependent Surveillance (ADS) equipment available on the aircraft
    at the
    time of flight that may be used to identify and/or locate the aircraft.
    Additional surveillance capabilities available on board the aircraft."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, otherSurveillanceCapabilities=None, surveillanceCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.otherSurveillanceCapabilities = _cast(None, otherSurveillanceCapabilities)
        self.otherSurveillanceCapabilities_nsprefix_ = None
        self.surveillanceCode = surveillanceCode
        self.validate_surveillanceCodeType(self.surveillanceCode)
        self.surveillanceCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SurveillanceCapabilitiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SurveillanceCapabilitiesType.subclass:
            return SurveillanceCapabilitiesType.subclass(*args_, **kwargs_)
        else:
            return SurveillanceCapabilitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_surveillanceCode(self):
        return self.surveillanceCode
    def set_surveillanceCode(self, surveillanceCode):
        self.surveillanceCode = surveillanceCode
    def get_otherSurveillanceCapabilities(self):
        return self.otherSurveillanceCapabilities
    def set_otherSurveillanceCapabilities(self, otherSurveillanceCapabilities):
        self.otherSurveillanceCapabilities = otherSurveillanceCapabilities
    def validate_surveillanceCodeType(self, value):
        result = True
        # Validate type surveillanceCodeType, a restriction on fx:SurveillanceCodeType.
        pass
        return result
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.surveillanceCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='SurveillanceCapabilitiesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SurveillanceCapabilitiesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SurveillanceCapabilitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SurveillanceCapabilitiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='SurveillanceCapabilitiesType'):
        if self.otherSurveillanceCapabilities is not None and 'otherSurveillanceCapabilities' not in already_processed:
            already_processed.add('otherSurveillanceCapabilities')
            outfile.write(' otherSurveillanceCapabilities=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.otherSurveillanceCapabilities), input_name='otherSurveillanceCapabilities')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='SurveillanceCapabilitiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.surveillanceCode is not None:
            namespaceprefix_ = self.surveillanceCode_nsprefix_ + ':' if (UseCapturedNS_ and self.surveillanceCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssurveillanceCode>%s</%ssurveillanceCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(' '.join(self.surveillanceCode)), input_name='surveillanceCode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('otherSurveillanceCapabilities', node)
        if value is not None and 'otherSurveillanceCapabilities' not in already_processed:
            already_processed.add('otherSurveillanceCapabilities')
            self.otherSurveillanceCapabilities = value
            self.validate_FreeTextType(self.otherSurveillanceCapabilities)    # validate type FreeTextType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'surveillanceCode':
            value_ = child_.text
            self.surveillanceCode = value_
            self.surveillanceCode_nsprefix_ = child_.prefix
            # validate type surveillanceCodeType
            self.validate_surveillanceCodeType(self.surveillanceCode)
# end class SurveillanceCapabilitiesType


class DinghyType(GeneratedsSuper):
    """Describes the aircraft dingy.
    .Dinghy Cover Status: Indication of the covered/uncovered nature of the
    dinghies
    carried by the aircraft.
    .Dinghy Quantity: The number of dinghies carried by the aircraft.
    Dinghy Total Capacity: The total number of persons that can be accommodated
    by the
    dinghies carried on board the aircraft.
    .Dinghy Total Capacity: The total number of persons that can be
    accommodated by the
    dinghies carried on board the aircraft."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, covered=None, quantity=None, totalCapacity=None, colour=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.covered = _cast(None, covered)
        self.covered_nsprefix_ = None
        self.quantity = _cast(None, quantity)
        self.quantity_nsprefix_ = None
        self.totalCapacity = _cast(None, totalCapacity)
        self.totalCapacity_nsprefix_ = None
        self.colour = colour
        self.colour_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DinghyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DinghyType.subclass:
            return DinghyType.subclass(*args_, **kwargs_)
        else:
            return DinghyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_colour(self):
        return self.colour
    def set_colour(self, colour):
        self.colour = colour
    def get_covered(self):
        return self.covered
    def set_covered(self, covered):
        self.covered = covered
    def get_quantity(self):
        return self.quantity
    def set_quantity(self, quantity):
        self.quantity = quantity
    def get_totalCapacity(self):
        return self.totalCapacity
    def set_totalCapacity(self, totalCapacity):
        self.totalCapacity = totalCapacity
    def validate_DinghyCoverType(self, value):
        # Validate type fx:DinghyCoverType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COVERED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DinghyCoverType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_CountType(self, value):
        # Validate type fb:CountType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on CountType' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.colour is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='DinghyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DinghyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DinghyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DinghyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='DinghyType'):
        if self.covered is not None and 'covered' not in already_processed:
            already_processed.add('covered')
            outfile.write(' covered=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.covered), input_name='covered')), ))
        if self.quantity is not None and 'quantity' not in already_processed:
            already_processed.add('quantity')
            outfile.write(' quantity="%s"' % self.gds_format_integer(self.quantity, input_name='quantity'))
        if self.totalCapacity is not None and 'totalCapacity' not in already_processed:
            already_processed.add('totalCapacity')
            outfile.write(' totalCapacity="%s"' % self.gds_format_integer(self.totalCapacity, input_name='totalCapacity'))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='DinghyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.colour is not None:
            namespaceprefix_ = self.colour_nsprefix_ + ':' if (UseCapturedNS_ and self.colour_nsprefix_) else ''
            self.colour.export(outfile, level, namespaceprefix_, namespacedef_='', name_='colour', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('covered', node)
        if value is not None and 'covered' not in already_processed:
            already_processed.add('covered')
            self.covered = value
            self.validate_DinghyCoverType(self.covered)    # validate type DinghyCoverType
        value = find_attr_value_('quantity', node)
        if value is not None and 'quantity' not in already_processed:
            already_processed.add('quantity')
            self.quantity = self.gds_parse_integer(value, node, 'quantity')
            self.validate_CountType(self.quantity)    # validate type CountType
        value = find_attr_value_('totalCapacity', node)
        if value is not None and 'totalCapacity' not in already_processed:
            already_processed.add('totalCapacity')
            self.totalCapacity = self.gds_parse_integer(value, node, 'totalCapacity')
            self.validate_CountType(self.totalCapacity)    # validate type CountType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'colour':
            obj_ = DinghyColourType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.colour = obj_
            obj_.original_tagname_ = 'colour'
# end class DinghyType


class DinghyColourType(GeneratedsSuper):
    """.Dinghy Colour: The colour of the dinghies carried by the aircraft."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, colourCode=None, otherColour=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.colourCode = colourCode
        self.validate_DinghyColourCodeType(self.colourCode)
        self.colourCode_nsprefix_ = None
        self.otherColour = otherColour
        self.validate_FreeTextType(self.otherColour)
        self.otherColour_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DinghyColourType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DinghyColourType.subclass:
            return DinghyColourType.subclass(*args_, **kwargs_)
        else:
            return DinghyColourType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_colourCode(self):
        return self.colourCode
    def set_colourCode(self, colourCode):
        self.colourCode = colourCode
    def get_otherColour(self):
        return self.otherColour
    def set_otherColour(self, otherColour):
        self.otherColour = otherColour
    def validate_DinghyColourCodeType(self, value):
        result = True
        # Validate type DinghyColourCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['RED', 'ORANGE', 'YELLOW', 'GREEN', 'BLUE', 'VIOLET', 'BLACK', 'WHITE', 'GRAY', 'SILVER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DinghyColourCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_FreeTextType(self, value):
        result = True
        # Validate type FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.colourCode is not None or
            self.otherColour is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='DinghyColourType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DinghyColourType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DinghyColourType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DinghyColourType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='DinghyColourType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='DinghyColourType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.colourCode is not None:
            namespaceprefix_ = self.colourCode_nsprefix_ + ':' if (UseCapturedNS_ and self.colourCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scolourCode>%s</%scolourCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.colourCode), input_name='colourCode')), namespaceprefix_ , eol_))
        if self.otherColour is not None:
            namespaceprefix_ = self.otherColour_nsprefix_ + ':' if (UseCapturedNS_ and self.otherColour_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sotherColour>%s</%sotherColour>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.otherColour), input_name='otherColour')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'colourCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'colourCode')
            value_ = self.gds_validate_string(value_, node, 'colourCode')
            self.colourCode = value_
            self.colourCode_nsprefix_ = child_.prefix
            # validate type DinghyColourCodeType
            self.validate_DinghyColourCodeType(self.colourCode)
        elif nodeName_ == 'otherColour':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'otherColour')
            value_ = self.gds_validate_string(value_, node, 'otherColour')
            self.otherColour = value_
            self.otherColour_nsprefix_ = child_.prefix
            # validate type FreeTextType
            self.validate_FreeTextType(self.otherColour)
# end class DinghyColourType


class SurvivalCapabilitiesType(GeneratedsSuper):
    """Groups the aircraft survival capabilities.
    .Survival Equipment Remarks: A description of survival equipment carried on
    the aircraft
    and any other useful remarks regarding survival equipment."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, survivalEquipmentRemarks=None, dinghyInformation=None, emergencyRadioCode=None, lifeJacketCode=None, survivalEquipmentCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.survivalEquipmentRemarks = _cast(None, survivalEquipmentRemarks)
        self.survivalEquipmentRemarks_nsprefix_ = None
        self.dinghyInformation = dinghyInformation
        self.dinghyInformation_nsprefix_ = None
        self.emergencyRadioCode = emergencyRadioCode
        self.validate_emergencyRadioCodeType(self.emergencyRadioCode)
        self.emergencyRadioCode_nsprefix_ = None
        self.lifeJacketCode = lifeJacketCode
        self.validate_lifeJacketCodeType(self.lifeJacketCode)
        self.lifeJacketCode_nsprefix_ = None
        self.survivalEquipmentCode = survivalEquipmentCode
        self.validate_survivalEquipmentCodeType(self.survivalEquipmentCode)
        self.survivalEquipmentCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SurvivalCapabilitiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SurvivalCapabilitiesType.subclass:
            return SurvivalCapabilitiesType.subclass(*args_, **kwargs_)
        else:
            return SurvivalCapabilitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dinghyInformation(self):
        return self.dinghyInformation
    def set_dinghyInformation(self, dinghyInformation):
        self.dinghyInformation = dinghyInformation
    def get_emergencyRadioCode(self):
        return self.emergencyRadioCode
    def set_emergencyRadioCode(self, emergencyRadioCode):
        self.emergencyRadioCode = emergencyRadioCode
    def get_lifeJacketCode(self):
        return self.lifeJacketCode
    def set_lifeJacketCode(self, lifeJacketCode):
        self.lifeJacketCode = lifeJacketCode
    def get_survivalEquipmentCode(self):
        return self.survivalEquipmentCode
    def set_survivalEquipmentCode(self, survivalEquipmentCode):
        self.survivalEquipmentCode = survivalEquipmentCode
    def get_survivalEquipmentRemarks(self):
        return self.survivalEquipmentRemarks
    def set_survivalEquipmentRemarks(self, survivalEquipmentRemarks):
        self.survivalEquipmentRemarks = survivalEquipmentRemarks
    def validate_emergencyRadioCodeType(self, value):
        result = True
        # Validate type emergencyRadioCodeType, a restriction on fx:EmergencyRadioCodeType.
        pass
        return result
    def validate_lifeJacketCodeType(self, value):
        result = True
        # Validate type lifeJacketCodeType, a restriction on fx:LifeJacketCodeType.
        pass
        return result
    def validate_survivalEquipmentCodeType(self, value):
        result = True
        # Validate type survivalEquipmentCodeType, a restriction on fx:SurvivalEquipmentCodeType.
        pass
        return result
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.dinghyInformation is not None or
            self.emergencyRadioCode is not None or
            self.lifeJacketCode is not None or
            self.survivalEquipmentCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='SurvivalCapabilitiesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SurvivalCapabilitiesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SurvivalCapabilitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SurvivalCapabilitiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='SurvivalCapabilitiesType'):
        if self.survivalEquipmentRemarks is not None and 'survivalEquipmentRemarks' not in already_processed:
            already_processed.add('survivalEquipmentRemarks')
            outfile.write(' survivalEquipmentRemarks=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.survivalEquipmentRemarks), input_name='survivalEquipmentRemarks')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='SurvivalCapabilitiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dinghyInformation is not None:
            namespaceprefix_ = self.dinghyInformation_nsprefix_ + ':' if (UseCapturedNS_ and self.dinghyInformation_nsprefix_) else ''
            self.dinghyInformation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dinghyInformation', pretty_print=pretty_print)
        if self.emergencyRadioCode is not None:
            namespaceprefix_ = self.emergencyRadioCode_nsprefix_ + ':' if (UseCapturedNS_ and self.emergencyRadioCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semergencyRadioCode>%s</%semergencyRadioCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(' '.join(self.emergencyRadioCode)), input_name='emergencyRadioCode')), namespaceprefix_ , eol_))
        if self.lifeJacketCode is not None:
            namespaceprefix_ = self.lifeJacketCode_nsprefix_ + ':' if (UseCapturedNS_ and self.lifeJacketCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slifeJacketCode>%s</%slifeJacketCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(' '.join(self.lifeJacketCode)), input_name='lifeJacketCode')), namespaceprefix_ , eol_))
        if self.survivalEquipmentCode is not None:
            namespaceprefix_ = self.survivalEquipmentCode_nsprefix_ + ':' if (UseCapturedNS_ and self.survivalEquipmentCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssurvivalEquipmentCode>%s</%ssurvivalEquipmentCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(' '.join(self.survivalEquipmentCode)), input_name='survivalEquipmentCode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('survivalEquipmentRemarks', node)
        if value is not None and 'survivalEquipmentRemarks' not in already_processed:
            already_processed.add('survivalEquipmentRemarks')
            self.survivalEquipmentRemarks = value
            self.validate_FreeTextType(self.survivalEquipmentRemarks)    # validate type FreeTextType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dinghyInformation':
            obj_ = DinghyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dinghyInformation = obj_
            obj_.original_tagname_ = 'dinghyInformation'
        elif nodeName_ == 'emergencyRadioCode':
            value_ = child_.text
            self.emergencyRadioCode = value_
            self.emergencyRadioCode_nsprefix_ = child_.prefix
            # validate type emergencyRadioCodeType
            self.validate_emergencyRadioCodeType(self.emergencyRadioCode)
        elif nodeName_ == 'lifeJacketCode':
            value_ = child_.text
            self.lifeJacketCode = value_
            self.lifeJacketCode_nsprefix_ = child_.prefix
            # validate type lifeJacketCodeType
            self.validate_lifeJacketCodeType(self.lifeJacketCode)
        elif nodeName_ == 'survivalEquipmentCode':
            value_ = child_.text
            self.survivalEquipmentCode = value_
            self.survivalEquipmentCode_nsprefix_ = child_.prefix
            # validate type survivalEquipmentCodeType
            self.validate_survivalEquipmentCodeType(self.survivalEquipmentCode)
# end class SurvivalCapabilitiesType


class AdditionalHandlingInformationType(GeneratedsSuper):
    """.Additional Handling Information: Additional information related to the
    handling
    of dangerous goods, as identified on the Shipper's Declaration for
    Dangerous Goods."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, responsibleAgent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.responsibleAgent = responsibleAgent
        self.responsibleAgent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdditionalHandlingInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdditionalHandlingInformationType.subclass:
            return AdditionalHandlingInformationType.subclass(*args_, **kwargs_)
        else:
            return AdditionalHandlingInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_responsibleAgent(self):
        return self.responsibleAgent
    def set_responsibleAgent(self, responsibleAgent):
        self.responsibleAgent = responsibleAgent
    def hasContent_(self):
        if (
            self.responsibleAgent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='AdditionalHandlingInformationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdditionalHandlingInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdditionalHandlingInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AdditionalHandlingInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='AdditionalHandlingInformationType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='AdditionalHandlingInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.responsibleAgent is not None:
            namespaceprefix_ = self.responsibleAgent_nsprefix_ + ':' if (UseCapturedNS_ and self.responsibleAgent_nsprefix_) else ''
            self.responsibleAgent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='responsibleAgent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'responsibleAgent':
            obj_ = PersonOrOrganizationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.responsibleAgent = obj_
            obj_.original_tagname_ = 'responsibleAgent'
# end class AdditionalHandlingInformationType


class AirWaybillType(GeneratedsSuper):
    """.Air Waybill Number: The number referencing the air waybill.
    .Air Waybill Number: The number referencing the air waybill."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, airWaybillNumber=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.airWaybillNumber = _cast(None, airWaybillNumber)
        self.airWaybillNumber_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AirWaybillType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AirWaybillType.subclass:
            return AirWaybillType.subclass(*args_, **kwargs_)
        else:
            return AirWaybillType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_airWaybillNumber(self):
        return self.airWaybillNumber
    def set_airWaybillNumber(self, airWaybillNumber):
        self.airWaybillNumber = airWaybillNumber
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='AirWaybillType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AirWaybillType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AirWaybillType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AirWaybillType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='AirWaybillType'):
        if self.airWaybillNumber is not None and 'airWaybillNumber' not in already_processed:
            already_processed.add('airWaybillNumber')
            outfile.write(' airWaybillNumber=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.airWaybillNumber), input_name='airWaybillNumber')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='AirWaybillType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('airWaybillNumber', node)
        if value is not None and 'airWaybillNumber' not in already_processed:
            already_processed.add('airWaybillNumber')
            self.airWaybillNumber = value
            self.validate_FreeTextType(self.airWaybillNumber)    # validate type FreeTextType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AirWaybillType


class DangerousGoodsType(FeatureType):
    """.Shipper's Declaration For Dangerous Goods Summary: The section of the
    IATA Shipper's
    Declaration For Dangerous Goods required at the end portion of the SDDG for
    a shipment.
    .Shipper's Declaration For Dangerous Goods Header: The part of the IATA
    Shipper's
    Declaration For Dangerous Goods that contains the basic header information
    on who
    is sending and receiving this shipment.
    .IATA Shipper's Declaration For Dangerous Goods: This is the outermost
    grouping element
    for the information required for the shipment of dangerous goods.
    .Aircraft Dangerous Goods Limitation: Describes whether the shipment is
    packed to
    comply with the limitations prescribed for passenger and cargo aircraft or
    the limitations
    for cargo aircraft only.
    .Emergency Response Guidebook Number: A reference to a set of instructions
    to handle
    a specific dangerous goods situation.
    .On Board Dangerous Goods Location: The location of a dangerous goods
    shipment inside
    the airframe.
    .Shipment Type: An indicator used for dangerous cargo of whether the
    package is radioactive
    or not."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FeatureType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, aircraftLimitation=None, guidebookNumber=None, onboardLocation=None, shipment=None, airWayBill=None, handlingInformation=None, packageGroup=None, shippingInformation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DangerousGoodsType, self).__init__(centre, source, system, timestamp,  **kwargs_)
        self.aircraftLimitation = _cast(None, aircraftLimitation)
        self.aircraftLimitation_nsprefix_ = None
        self.guidebookNumber = _cast(None, guidebookNumber)
        self.guidebookNumber_nsprefix_ = None
        self.onboardLocation = _cast(None, onboardLocation)
        self.onboardLocation_nsprefix_ = None
        self.shipment = _cast(None, shipment)
        self.shipment_nsprefix_ = None
        self.airWayBill = airWayBill
        self.airWayBill_nsprefix_ = None
        self.handlingInformation = handlingInformation
        self.handlingInformation_nsprefix_ = None
        if packageGroup is None:
            self.packageGroup = []
        else:
            self.packageGroup = packageGroup
        self.packageGroup_nsprefix_ = None
        self.shippingInformation = shippingInformation
        self.shippingInformation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DangerousGoodsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DangerousGoodsType.subclass:
            return DangerousGoodsType.subclass(*args_, **kwargs_)
        else:
            return DangerousGoodsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_airWayBill(self):
        return self.airWayBill
    def set_airWayBill(self, airWayBill):
        self.airWayBill = airWayBill
    def get_handlingInformation(self):
        return self.handlingInformation
    def set_handlingInformation(self, handlingInformation):
        self.handlingInformation = handlingInformation
    def get_packageGroup(self):
        return self.packageGroup
    def set_packageGroup(self, packageGroup):
        self.packageGroup = packageGroup
    def add_packageGroup(self, value):
        self.packageGroup.append(value)
    def insert_packageGroup_at(self, index, value):
        self.packageGroup.insert(index, value)
    def replace_packageGroup_at(self, index, value):
        self.packageGroup[index] = value
    def get_shippingInformation(self):
        return self.shippingInformation
    def set_shippingInformation(self, shippingInformation):
        self.shippingInformation = shippingInformation
    def get_aircraftLimitation(self):
        return self.aircraftLimitation
    def set_aircraftLimitation(self, aircraftLimitation):
        self.aircraftLimitation = aircraftLimitation
    def get_guidebookNumber(self):
        return self.guidebookNumber
    def set_guidebookNumber(self, guidebookNumber):
        self.guidebookNumber = guidebookNumber
    def get_onboardLocation(self):
        return self.onboardLocation
    def set_onboardLocation(self, onboardLocation):
        self.onboardLocation = onboardLocation
    def get_shipment(self):
        return self.shipment
    def set_shipment(self, shipment):
        self.shipment = shipment
    def validate_AircraftDangerousGoodsLimitationType(self, value):
        # Validate type fx:AircraftDangerousGoodsLimitationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PASSENGER_AND_CARGO_AIRCRAFT', 'CARGO_AIRCRAFT_ONLY']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AircraftDangerousGoodsLimitationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ShipmentTypeType(self, value):
        # Validate type fx:ShipmentTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['RADIOACTIVE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ShipmentTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.airWayBill is not None or
            self.handlingInformation is not None or
            self.packageGroup or
            self.shippingInformation is not None or
            super(DangerousGoodsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='DangerousGoodsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DangerousGoodsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DangerousGoodsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DangerousGoodsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='DangerousGoodsType'):
        super(DangerousGoodsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DangerousGoodsType')
        if self.aircraftLimitation is not None and 'aircraftLimitation' not in already_processed:
            already_processed.add('aircraftLimitation')
            outfile.write(' aircraftLimitation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aircraftLimitation), input_name='aircraftLimitation')), ))
        if self.guidebookNumber is not None and 'guidebookNumber' not in already_processed:
            already_processed.add('guidebookNumber')
            outfile.write(' guidebookNumber=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.guidebookNumber), input_name='guidebookNumber')), ))
        if self.onboardLocation is not None and 'onboardLocation' not in already_processed:
            already_processed.add('onboardLocation')
            outfile.write(' onboardLocation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onboardLocation), input_name='onboardLocation')), ))
        if self.shipment is not None and 'shipment' not in already_processed:
            already_processed.add('shipment')
            outfile.write(' shipment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.shipment), input_name='shipment')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='DangerousGoodsType', fromsubclass_=False, pretty_print=True):
        super(DangerousGoodsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.airWayBill is not None:
            namespaceprefix_ = self.airWayBill_nsprefix_ + ':' if (UseCapturedNS_ and self.airWayBill_nsprefix_) else ''
            self.airWayBill.export(outfile, level, namespaceprefix_, namespacedef_='', name_='airWayBill', pretty_print=pretty_print)
        if self.handlingInformation is not None:
            namespaceprefix_ = self.handlingInformation_nsprefix_ + ':' if (UseCapturedNS_ and self.handlingInformation_nsprefix_) else ''
            self.handlingInformation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='handlingInformation', pretty_print=pretty_print)
        for packageGroup_ in self.packageGroup:
            namespaceprefix_ = self.packageGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.packageGroup_nsprefix_) else ''
            packageGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='packageGroup', pretty_print=pretty_print)
        if self.shippingInformation is not None:
            namespaceprefix_ = self.shippingInformation_nsprefix_ + ':' if (UseCapturedNS_ and self.shippingInformation_nsprefix_) else ''
            self.shippingInformation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='shippingInformation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aircraftLimitation', node)
        if value is not None and 'aircraftLimitation' not in already_processed:
            already_processed.add('aircraftLimitation')
            self.aircraftLimitation = value
            self.validate_AircraftDangerousGoodsLimitationType(self.aircraftLimitation)    # validate type AircraftDangerousGoodsLimitationType
        value = find_attr_value_('guidebookNumber', node)
        if value is not None and 'guidebookNumber' not in already_processed:
            already_processed.add('guidebookNumber')
            self.guidebookNumber = value
            self.validate_FreeTextType(self.guidebookNumber)    # validate type FreeTextType
        value = find_attr_value_('onboardLocation', node)
        if value is not None and 'onboardLocation' not in already_processed:
            already_processed.add('onboardLocation')
            self.onboardLocation = value
            self.validate_FreeTextType(self.onboardLocation)    # validate type FreeTextType
        value = find_attr_value_('shipment', node)
        if value is not None and 'shipment' not in already_processed:
            already_processed.add('shipment')
            self.shipment = value
            self.validate_ShipmentTypeType(self.shipment)    # validate type ShipmentTypeType
        super(DangerousGoodsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'airWayBill':
            obj_ = AirWaybillType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.airWayBill = obj_
            obj_.original_tagname_ = 'airWayBill'
        elif nodeName_ == 'handlingInformation':
            obj_ = AdditionalHandlingInformationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.handlingInformation = obj_
            obj_.original_tagname_ = 'handlingInformation'
        elif nodeName_ == 'packageGroup':
            obj_ = DangerousGoodsPackageGroupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.packageGroup.append(obj_)
            obj_.original_tagname_ = 'packageGroup'
        elif nodeName_ == 'shippingInformation':
            obj_ = ShippingInformationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.shippingInformation = obj_
            obj_.original_tagname_ = 'shippingInformation'
        super(DangerousGoodsType, self).buildChildren(child_, node, nodeName_, True)
# end class DangerousGoodsType


class DeclarationTextType(GeneratedsSuper):
    """.Declaration Text: Consignor: The consignor's statement indicating the
    dangerous
    goods have been packaged and handled according to regulations.
    .Declaration Text: Shipper: This shipper's statement indicating the
    dangerous goods
    have been packaged and handled according to regulations.
    .Declaration Text: Compliance: The warning message for not complying with
    the regulations.
    .Declaration Text: Compliance: The warning message for not complying with
    the regulations.
    .Declaration Text: Consignor: The consignor's statement indicating the
    dangerous
    goods have been packaged and handled according to regulations.
    .Declaration Text: Shipper: This shipper's statement indicating the
    dangerous goods
    have been packaged and handled according to regulations."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, compliance=None, consignor=None, shipper=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.compliance = _cast(None, compliance)
        self.compliance_nsprefix_ = None
        self.consignor = _cast(None, consignor)
        self.consignor_nsprefix_ = None
        self.shipper = _cast(None, shipper)
        self.shipper_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeclarationTextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeclarationTextType.subclass:
            return DeclarationTextType.subclass(*args_, **kwargs_)
        else:
            return DeclarationTextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_compliance(self):
        return self.compliance
    def set_compliance(self, compliance):
        self.compliance = compliance
    def get_consignor(self):
        return self.consignor
    def set_consignor(self, consignor):
        self.consignor = consignor
    def get_shipper(self):
        return self.shipper
    def set_shipper(self, shipper):
        self.shipper = shipper
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='DeclarationTextType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeclarationTextType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeclarationTextType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DeclarationTextType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='DeclarationTextType'):
        if self.compliance is not None and 'compliance' not in already_processed:
            already_processed.add('compliance')
            outfile.write(' compliance=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.compliance), input_name='compliance')), ))
        if self.consignor is not None and 'consignor' not in already_processed:
            already_processed.add('consignor')
            outfile.write(' consignor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.consignor), input_name='consignor')), ))
        if self.shipper is not None and 'shipper' not in already_processed:
            already_processed.add('shipper')
            outfile.write(' shipper=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.shipper), input_name='shipper')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='DeclarationTextType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('compliance', node)
        if value is not None and 'compliance' not in already_processed:
            already_processed.add('compliance')
            self.compliance = value
            self.validate_FreeTextType(self.compliance)    # validate type FreeTextType
        value = find_attr_value_('consignor', node)
        if value is not None and 'consignor' not in already_processed:
            already_processed.add('consignor')
            self.consignor = value
            self.validate_FreeTextType(self.consignor)    # validate type FreeTextType
        value = find_attr_value_('shipper', node)
        if value is not None and 'shipper' not in already_processed:
            already_processed.add('shipper')
            self.shipper = value
            self.validate_FreeTextType(self.shipper)    # validate type FreeTextType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DeclarationTextType


class ShippingInformationType(GeneratedsSuper):
    """IATA Shipper's Declaration for Dangerous Goods.
    .Dangerous Goods Screening Location: The name of the Certified Cargo
    Screening Facility,
    as approved by the Transportation Security Administration (TSA), or the
    location/name
    of any screening performed.
    .Departure Country: The Code and Name of the departure country where the
    package
    originated.
    .Destination Country: The Name and Code of the dangerous good's country of
    destination.
    .Departure Country: The Code and Name of the departure country where the
    package
    originated.
    .Shipment Authorizations: Additional information related to an approval,
    permission,
    or other specific detail regarding the shipment of dangerous goods.
    .Subsidiary Hazard Class and Division: An identifier of any subsidiary
    hazard class(es)/division(s)
    in addition to the primary hazard class and division.
    .Supplementary Information: Additional information that may be added to the
    proper
    shipping name to more fully describe the goods or to identify a particular
    condition.
    .Supplementary Shipping Information: Additional information that may be
    added to
    the proper shipping name to more fully describe the goods or to identify a
    particular
    condition."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dangerousGoodsScreeningLocation=None, departureCountry=None, destinationCountry=None, originCountry=None, shipmentAuthorizations=None, subsidiaryHazardClassAndDivision=None, supplementaryInformation=None, aerodromeOfLoading=None, aerodromeOfUnloading=None, consignee=None, declarationText=None, shipper=None, transferAerodromes=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dangerousGoodsScreeningLocation = _cast(None, dangerousGoodsScreeningLocation)
        self.dangerousGoodsScreeningLocation_nsprefix_ = None
        self.departureCountry = _cast(None, departureCountry)
        self.departureCountry_nsprefix_ = None
        self.destinationCountry = _cast(None, destinationCountry)
        self.destinationCountry_nsprefix_ = None
        self.originCountry = _cast(None, originCountry)
        self.originCountry_nsprefix_ = None
        self.shipmentAuthorizations = _cast(None, shipmentAuthorizations)
        self.shipmentAuthorizations_nsprefix_ = None
        self.subsidiaryHazardClassAndDivision = _cast(None, subsidiaryHazardClassAndDivision)
        self.subsidiaryHazardClassAndDivision_nsprefix_ = None
        self.supplementaryInformation = _cast(None, supplementaryInformation)
        self.supplementaryInformation_nsprefix_ = None
        self.aerodromeOfLoading = aerodromeOfLoading
        self.aerodromeOfLoading_nsprefix_ = None
        self.aerodromeOfUnloading = aerodromeOfUnloading
        self.aerodromeOfUnloading_nsprefix_ = None
        self.consignee = consignee
        self.consignee_nsprefix_ = None
        self.declarationText = declarationText
        self.declarationText_nsprefix_ = None
        self.shipper = shipper
        self.shipper_nsprefix_ = None
        self.transferAerodromes = transferAerodromes
        self.validate_transferAerodromesType(self.transferAerodromes)
        self.transferAerodromes_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShippingInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShippingInformationType.subclass:
            return ShippingInformationType.subclass(*args_, **kwargs_)
        else:
            return ShippingInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_aerodromeOfLoading(self):
        return self.aerodromeOfLoading
    def set_aerodromeOfLoading(self, aerodromeOfLoading):
        self.aerodromeOfLoading = aerodromeOfLoading
    def set_aerodromeOfLoading_with_type(self, value):
        self.aerodromeOfLoading = value
        value.original_tagname_ = 'aerodromeOfLoading'
        value.extensiontype_ = value.__class__.__name__
    def get_aerodromeOfUnloading(self):
        return self.aerodromeOfUnloading
    def set_aerodromeOfUnloading(self, aerodromeOfUnloading):
        self.aerodromeOfUnloading = aerodromeOfUnloading
    def set_aerodromeOfUnloading_with_type(self, value):
        self.aerodromeOfUnloading = value
        value.original_tagname_ = 'aerodromeOfUnloading'
        value.extensiontype_ = value.__class__.__name__
    def get_consignee(self):
        return self.consignee
    def set_consignee(self, consignee):
        self.consignee = consignee
    def get_declarationText(self):
        return self.declarationText
    def set_declarationText(self, declarationText):
        self.declarationText = declarationText
    def get_shipper(self):
        return self.shipper
    def set_shipper(self, shipper):
        self.shipper = shipper
    def get_transferAerodromes(self):
        return self.transferAerodromes
    def set_transferAerodromes(self, transferAerodromes):
        self.transferAerodromes = transferAerodromes
    def get_dangerousGoodsScreeningLocation(self):
        return self.dangerousGoodsScreeningLocation
    def set_dangerousGoodsScreeningLocation(self, dangerousGoodsScreeningLocation):
        self.dangerousGoodsScreeningLocation = dangerousGoodsScreeningLocation
    def get_departureCountry(self):
        return self.departureCountry
    def set_departureCountry(self, departureCountry):
        self.departureCountry = departureCountry
    def get_destinationCountry(self):
        return self.destinationCountry
    def set_destinationCountry(self, destinationCountry):
        self.destinationCountry = destinationCountry
    def get_originCountry(self):
        return self.originCountry
    def set_originCountry(self, originCountry):
        self.originCountry = originCountry
    def get_shipmentAuthorizations(self):
        return self.shipmentAuthorizations
    def set_shipmentAuthorizations(self, shipmentAuthorizations):
        self.shipmentAuthorizations = shipmentAuthorizations
    def get_subsidiaryHazardClassAndDivision(self):
        return self.subsidiaryHazardClassAndDivision
    def set_subsidiaryHazardClassAndDivision(self, subsidiaryHazardClassAndDivision):
        self.subsidiaryHazardClassAndDivision = subsidiaryHazardClassAndDivision
    def get_supplementaryInformation(self):
        return self.supplementaryInformation
    def set_supplementaryInformation(self, supplementaryInformation):
        self.supplementaryInformation = supplementaryInformation
    def validate_transferAerodromesType(self, value):
        result = True
        # Validate type transferAerodromesType, a restriction on ff:AerodromeIcaoCodeType.
        pass
        return result
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_TextCountryNameType(self, value):
        # Validate type ff:TextCountryNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.aerodromeOfLoading is not None or
            self.aerodromeOfUnloading is not None or
            self.consignee is not None or
            self.declarationText is not None or
            self.shipper is not None or
            self.transferAerodromes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ShippingInformationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShippingInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShippingInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShippingInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='ShippingInformationType'):
        if self.dangerousGoodsScreeningLocation is not None and 'dangerousGoodsScreeningLocation' not in already_processed:
            already_processed.add('dangerousGoodsScreeningLocation')
            outfile.write(' dangerousGoodsScreeningLocation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dangerousGoodsScreeningLocation), input_name='dangerousGoodsScreeningLocation')), ))
        if self.departureCountry is not None and 'departureCountry' not in already_processed:
            already_processed.add('departureCountry')
            outfile.write(' departureCountry=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.departureCountry), input_name='departureCountry')), ))
        if self.destinationCountry is not None and 'destinationCountry' not in already_processed:
            already_processed.add('destinationCountry')
            outfile.write(' destinationCountry=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.destinationCountry), input_name='destinationCountry')), ))
        if self.originCountry is not None and 'originCountry' not in already_processed:
            already_processed.add('originCountry')
            outfile.write(' originCountry=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.originCountry), input_name='originCountry')), ))
        if self.shipmentAuthorizations is not None and 'shipmentAuthorizations' not in already_processed:
            already_processed.add('shipmentAuthorizations')
            outfile.write(' shipmentAuthorizations=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.shipmentAuthorizations), input_name='shipmentAuthorizations')), ))
        if self.subsidiaryHazardClassAndDivision is not None and 'subsidiaryHazardClassAndDivision' not in already_processed:
            already_processed.add('subsidiaryHazardClassAndDivision')
            outfile.write(' subsidiaryHazardClassAndDivision=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.subsidiaryHazardClassAndDivision), input_name='subsidiaryHazardClassAndDivision')), ))
        if self.supplementaryInformation is not None and 'supplementaryInformation' not in already_processed:
            already_processed.add('supplementaryInformation')
            outfile.write(' supplementaryInformation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.supplementaryInformation), input_name='supplementaryInformation')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ShippingInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.aerodromeOfLoading is not None:
            self.aerodromeOfLoading.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.aerodromeOfUnloading is not None:
            self.aerodromeOfUnloading.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.consignee is not None:
            namespaceprefix_ = self.consignee_nsprefix_ + ':' if (UseCapturedNS_ and self.consignee_nsprefix_) else ''
            self.consignee.export(outfile, level, namespaceprefix_, namespacedef_='', name_='consignee', pretty_print=pretty_print)
        if self.declarationText is not None:
            namespaceprefix_ = self.declarationText_nsprefix_ + ':' if (UseCapturedNS_ and self.declarationText_nsprefix_) else ''
            self.declarationText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='declarationText', pretty_print=pretty_print)
        if self.shipper is not None:
            namespaceprefix_ = self.shipper_nsprefix_ + ':' if (UseCapturedNS_ and self.shipper_nsprefix_) else ''
            self.shipper.export(outfile, level, namespaceprefix_, namespacedef_='', name_='shipper', pretty_print=pretty_print)
        if self.transferAerodromes is not None:
            namespaceprefix_ = self.transferAerodromes_nsprefix_ + ':' if (UseCapturedNS_ and self.transferAerodromes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stransferAerodromes>%s</%stransferAerodromes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(' '.join(self.transferAerodromes)), input_name='transferAerodromes')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dangerousGoodsScreeningLocation', node)
        if value is not None and 'dangerousGoodsScreeningLocation' not in already_processed:
            already_processed.add('dangerousGoodsScreeningLocation')
            self.dangerousGoodsScreeningLocation = value
            self.validate_FreeTextType(self.dangerousGoodsScreeningLocation)    # validate type FreeTextType
        value = find_attr_value_('departureCountry', node)
        if value is not None and 'departureCountry' not in already_processed:
            already_processed.add('departureCountry')
            self.departureCountry = value
            self.validate_TextCountryNameType(self.departureCountry)    # validate type TextCountryNameType
        value = find_attr_value_('destinationCountry', node)
        if value is not None and 'destinationCountry' not in already_processed:
            already_processed.add('destinationCountry')
            self.destinationCountry = value
            self.validate_TextCountryNameType(self.destinationCountry)    # validate type TextCountryNameType
        value = find_attr_value_('originCountry', node)
        if value is not None and 'originCountry' not in already_processed:
            already_processed.add('originCountry')
            self.originCountry = value
            self.validate_TextCountryNameType(self.originCountry)    # validate type TextCountryNameType
        value = find_attr_value_('shipmentAuthorizations', node)
        if value is not None and 'shipmentAuthorizations' not in already_processed:
            already_processed.add('shipmentAuthorizations')
            self.shipmentAuthorizations = value
            self.validate_FreeTextType(self.shipmentAuthorizations)    # validate type FreeTextType
        value = find_attr_value_('subsidiaryHazardClassAndDivision', node)
        if value is not None and 'subsidiaryHazardClassAndDivision' not in already_processed:
            already_processed.add('subsidiaryHazardClassAndDivision')
            self.subsidiaryHazardClassAndDivision = value
            self.validate_FreeTextType(self.subsidiaryHazardClassAndDivision)    # validate type FreeTextType
        value = find_attr_value_('supplementaryInformation', node)
        if value is not None and 'supplementaryInformation' not in already_processed:
            already_processed.add('supplementaryInformation')
            self.supplementaryInformation = value
            self.validate_FreeTextType(self.supplementaryInformation)    # validate type FreeTextType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'aerodromeOfLoading':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <aerodromeOfLoading> element')
            self.aerodromeOfLoading = obj_
            obj_.original_tagname_ = 'aerodromeOfLoading'
        elif nodeName_ == 'aerodromeOfUnloading':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <aerodromeOfUnloading> element')
            self.aerodromeOfUnloading = obj_
            obj_.original_tagname_ = 'aerodromeOfUnloading'
        elif nodeName_ == 'consignee':
            obj_ = StructuredPostalAddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.consignee = obj_
            obj_.original_tagname_ = 'consignee'
        elif nodeName_ == 'declarationText':
            obj_ = DeclarationTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.declarationText = obj_
            obj_.original_tagname_ = 'declarationText'
        elif nodeName_ == 'shipper':
            obj_ = StructuredPostalAddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.shipper = obj_
            obj_.original_tagname_ = 'shipper'
        elif nodeName_ == 'transferAerodromes':
            value_ = child_.text
            self.transferAerodromes = value_
            self.transferAerodromes_nsprefix_ = child_.prefix
            # validate type transferAerodromesType
            self.validate_transferAerodromesType(self.transferAerodromes)
# end class ShippingInformationType


class StructuredPostalAddressType(ContactInformationType):
    """.Country Name: The name of a country.
    .Region Name: The name of the region within a country specific to this
    address.
    .Postal Structured Address: The XML Grouping Element that contains the
    parts of a
    Postal Address broken into its component parts (Structured).
    .Post Office Box: The Post Office (PO) Box number portion of a structured
    postal
    address.
    .Department: Contains the Department Name portion of the Address.
    .Country Code: A code that indicates a country.
    .Street: The building number and Street Name portion of the Address.
    .City Name: The name of the city the package is being shipped to.
    .ZIP or Postal Code: The ZIP/Postal Code corresponding to the street
    address."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ContactInformationType
    def __init__(self, name=None, title=None, address=None, onlineContact=None, phoneFax=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(StructuredPostalAddressType, self).__init__(name, title, address, onlineContact, phoneFax,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StructuredPostalAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StructuredPostalAddressType.subclass:
            return StructuredPostalAddressType.subclass(*args_, **kwargs_)
        else:
            return StructuredPostalAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (
            super(StructuredPostalAddressType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='StructuredPostalAddressType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StructuredPostalAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StructuredPostalAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StructuredPostalAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='StructuredPostalAddressType'):
        super(StructuredPostalAddressType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StructuredPostalAddressType')
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='StructuredPostalAddressType', fromsubclass_=False, pretty_print=True):
        super(StructuredPostalAddressType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StructuredPostalAddressType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(StructuredPostalAddressType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class StructuredPostalAddressType


class AllPackedInOneType(GeneratedsSuper):
    """.All Packed In One: A statement identifying the dangerous goods listed
    are all contained
    within the same outer packaging.
    The number of packages in the same outer packaging.
    .Q Value: The amount of energy released in a reaction."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, numberOfPackages=None, qValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.numberOfPackages = _cast(None, numberOfPackages)
        self.numberOfPackages_nsprefix_ = None
        self.qValue = _cast(None, qValue)
        self.qValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AllPackedInOneType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AllPackedInOneType.subclass:
            return AllPackedInOneType.subclass(*args_, **kwargs_)
        else:
            return AllPackedInOneType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_numberOfPackages(self):
        return self.numberOfPackages
    def set_numberOfPackages(self, numberOfPackages):
        self.numberOfPackages = numberOfPackages
    def get_qValue(self):
        return self.qValue
    def set_qValue(self, qValue):
        self.qValue = qValue
    def validate_CountType(self, value):
        # Validate type fb:CountType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on CountType' % {"value": value, "lineno": lineno} )
                result = False
    def validate_DecimalIndexType(self, value):
        # Validate type fb:DecimalIndexType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on DecimalIndexType' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='AllPackedInOneType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AllPackedInOneType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AllPackedInOneType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AllPackedInOneType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='AllPackedInOneType'):
        if self.numberOfPackages is not None and 'numberOfPackages' not in already_processed:
            already_processed.add('numberOfPackages')
            outfile.write(' numberOfPackages="%s"' % self.gds_format_integer(self.numberOfPackages, input_name='numberOfPackages'))
        if self.qValue is not None and 'qValue' not in already_processed:
            already_processed.add('qValue')
            outfile.write(' qValue="%s"' % self.gds_format_decimal(self.qValue, input_name='qValue'))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='AllPackedInOneType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfPackages', node)
        if value is not None and 'numberOfPackages' not in already_processed:
            already_processed.add('numberOfPackages')
            self.numberOfPackages = self.gds_parse_integer(value, node, 'numberOfPackages')
            self.validate_CountType(self.numberOfPackages)    # validate type CountType
        value = find_attr_value_('qValue', node)
        if value is not None and 'qValue' not in already_processed:
            already_processed.add('qValue')
            value = self.gds_parse_decimal(value, node, 'qValue')
            self.qValue = value
            self.validate_DecimalIndexType(self.qValue)    # validate type DecimalIndexType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AllPackedInOneType


class DangerousGoodsDimensionsType(GeneratedsSuper):
    """Weight and volume (not height, width, and depth):"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, grossWeight=None, netWeight=None, volume=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.grossWeight = grossWeight
        self.grossWeight_nsprefix_ = None
        self.netWeight = netWeight
        self.netWeight_nsprefix_ = None
        self.volume = volume
        self.volume_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DangerousGoodsDimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DangerousGoodsDimensionsType.subclass:
            return DangerousGoodsDimensionsType.subclass(*args_, **kwargs_)
        else:
            return DangerousGoodsDimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_grossWeight(self):
        return self.grossWeight
    def set_grossWeight(self, grossWeight):
        self.grossWeight = grossWeight
    def get_netWeight(self):
        return self.netWeight
    def set_netWeight(self, netWeight):
        self.netWeight = netWeight
    def get_volume(self):
        return self.volume
    def set_volume(self, volume):
        self.volume = volume
    def hasContent_(self):
        if (
            self.grossWeight is not None or
            self.netWeight is not None or
            self.volume is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='DangerousGoodsDimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DangerousGoodsDimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DangerousGoodsDimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DangerousGoodsDimensionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='DangerousGoodsDimensionsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='DangerousGoodsDimensionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.grossWeight is not None:
            namespaceprefix_ = self.grossWeight_nsprefix_ + ':' if (UseCapturedNS_ and self.grossWeight_nsprefix_) else ''
            self.grossWeight.export(outfile, level, namespaceprefix_, namespacedef_='', name_='grossWeight', pretty_print=pretty_print)
        if self.netWeight is not None:
            namespaceprefix_ = self.netWeight_nsprefix_ + ':' if (UseCapturedNS_ and self.netWeight_nsprefix_) else ''
            self.netWeight.export(outfile, level, namespaceprefix_, namespacedef_='', name_='netWeight', pretty_print=pretty_print)
        if self.volume is not None:
            namespaceprefix_ = self.volume_nsprefix_ + ':' if (UseCapturedNS_ and self.volume_nsprefix_) else ''
            self.volume.export(outfile, level, namespaceprefix_, namespacedef_='', name_='volume', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'grossWeight':
            obj_ = WeightType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.grossWeight = obj_
            obj_.original_tagname_ = 'grossWeight'
        elif nodeName_ == 'netWeight':
            obj_ = WeightType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.netWeight = obj_
            obj_.original_tagname_ = 'netWeight'
        elif nodeName_ == 'volume':
            obj_ = VolumeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.volume = obj_
            obj_.original_tagname_ = 'volume'
# end class DangerousGoodsDimensionsType


class DangerousGoodsPackageType(GeneratedsSuper):
    """.Dangerous Goods List of Package Detail: The part of the IATA Shipper's
    Declaration
    For Dangerous Goods that contains the Package Details for the shipment.
    .Shipper's Declaration For Dangerous Goods Packaging Detail: The part of
    the IATA
    Shipper's Declaration For Dangerous Goods that contains the packaging
    details for
    this shipment.
    .Shipper's Declaration For Dangerous Goods Line Item Details: The part of
    the IATA
    Shipper's Declaration For Dangerous Goods contains the line items details
    for this
    shipment.
    .Dangerous Goods List of Line Item Detail: The part of the IATA Shipper's
    Declaration
    For Dangerous Goods that contains the Line Item information for the
    shipment.
    .Dangerous Goods List of Overpack Detail: The part of the IATA Shipper's
    Declaration
    For Dangerous Goods that contains the Overpack Detail for the shipment.
    .Compatibility Group: When shipping dangerous goods, the reference to the
    group which
    identifies the kind of substances and articles deemed to be compatible.
    .Aircraft Dangerous Goods Limitation: Describes whether the shipment is
    packed to
    comply with the limitations prescribed for passenger and cargo aircraft or
    the limitations
    for cargo aircraft only.
    .Dangerous Goods Quantity: The total number of dangerous good packages of
    the same
    type and content.
    .Marine Pollutant Indicator: An indicator if the transported dangerous
    goods have
    marine pollutant content.
    .Overpack Indicator: An indicator that individual packages are assembled
    into a single
    unit for handling.
    .Packing Group: A code that indicates the relative degree of danger
    presented by
    various articles and substances within a Class or Division.
    .Packing Instruction Number: A number that corresponds to packing
    instructions required
    by U.S. and international regulations.
    .Product Name: The commonly used trade name associated with a dangerous
    good.
    .Proper Shipping Name: The name used to describe a particular article or
    substance
    in all shipping documents and notifications and, where appropriate, on
    packaging,
    as shown in the UN Model Regulations Dangerous Goods List.
    .Reportable Quantity: The minimum amount of hazardous substance released
    into the
    environment before the Environmental Protection Agency (EPA) requires
    notification
    of the release to the National Response Centre.
    .Shipment Type: An indicator used for dangerous cargo of whether the
    package is radioactive
    or not.
    .Supplementary Information: Additional information that may be added to the
    proper
    shipping name to more fully describe the goods or to identify a particular
    condition.
    .Technical Name: The additional chemical name(s) required for some proper
    shipping
    names for dangerous goods.
    .Dangerous Goods Type of Packaging: The material or container in which the
    dangerous
    good is packaged.
    .United Nations Number: A four-digit identification number assigned by the
    United
    Nations Committee of Experts on the Transport of Dangerous Goods to
    identify a substance
    or a particular group of substances considered dangerous goods."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, compatibilityGroup=None, dangerousGoodsLimitation=None, dangerousGoodsQuantity=None, marinePollutantIndicator=None, overpackIndicator=None, packingGroup=None, packingInstructionNumber=None, productName=None, properShippingName=None, reportableQuantity=None, shipmentType=None, supplementaryInformation=None, technicalName=None, typeOfPackaging=None, unNumber=None, allPackedInOne=None, hazardClass=None, packageDimensions=None, radioactiveMaterials=None, shipmentDimensions=None, subsidiaryHazardClass=None, temperatures=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.compatibilityGroup = _cast(None, compatibilityGroup)
        self.compatibilityGroup_nsprefix_ = None
        self.dangerousGoodsLimitation = _cast(None, dangerousGoodsLimitation)
        self.dangerousGoodsLimitation_nsprefix_ = None
        self.dangerousGoodsQuantity = _cast(None, dangerousGoodsQuantity)
        self.dangerousGoodsQuantity_nsprefix_ = None
        self.marinePollutantIndicator = _cast(None, marinePollutantIndicator)
        self.marinePollutantIndicator_nsprefix_ = None
        self.overpackIndicator = _cast(None, overpackIndicator)
        self.overpackIndicator_nsprefix_ = None
        self.packingGroup = _cast(None, packingGroup)
        self.packingGroup_nsprefix_ = None
        self.packingInstructionNumber = _cast(None, packingInstructionNumber)
        self.packingInstructionNumber_nsprefix_ = None
        self.productName = _cast(None, productName)
        self.productName_nsprefix_ = None
        self.properShippingName = _cast(None, properShippingName)
        self.properShippingName_nsprefix_ = None
        self.reportableQuantity = _cast(None, reportableQuantity)
        self.reportableQuantity_nsprefix_ = None
        self.shipmentType = _cast(None, shipmentType)
        self.shipmentType_nsprefix_ = None
        self.supplementaryInformation = _cast(None, supplementaryInformation)
        self.supplementaryInformation_nsprefix_ = None
        self.technicalName = _cast(None, technicalName)
        self.technicalName_nsprefix_ = None
        self.typeOfPackaging = _cast(None, typeOfPackaging)
        self.typeOfPackaging_nsprefix_ = None
        self.unNumber = _cast(None, unNumber)
        self.unNumber_nsprefix_ = None
        self.allPackedInOne = allPackedInOne
        self.allPackedInOne_nsprefix_ = None
        self.hazardClass = hazardClass
        self.hazardClass_nsprefix_ = None
        self.packageDimensions = packageDimensions
        self.packageDimensions_nsprefix_ = None
        self.radioactiveMaterials = radioactiveMaterials
        self.radioactiveMaterials_nsprefix_ = None
        self.shipmentDimensions = shipmentDimensions
        self.shipmentDimensions_nsprefix_ = None
        if subsidiaryHazardClass is None:
            self.subsidiaryHazardClass = []
        else:
            self.subsidiaryHazardClass = subsidiaryHazardClass
        self.subsidiaryHazardClass_nsprefix_ = None
        self.temperatures = temperatures
        self.temperatures_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DangerousGoodsPackageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DangerousGoodsPackageType.subclass:
            return DangerousGoodsPackageType.subclass(*args_, **kwargs_)
        else:
            return DangerousGoodsPackageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_allPackedInOne(self):
        return self.allPackedInOne
    def set_allPackedInOne(self, allPackedInOne):
        self.allPackedInOne = allPackedInOne
    def get_hazardClass(self):
        return self.hazardClass
    def set_hazardClass(self, hazardClass):
        self.hazardClass = hazardClass
    def get_packageDimensions(self):
        return self.packageDimensions
    def set_packageDimensions(self, packageDimensions):
        self.packageDimensions = packageDimensions
    def get_radioactiveMaterials(self):
        return self.radioactiveMaterials
    def set_radioactiveMaterials(self, radioactiveMaterials):
        self.radioactiveMaterials = radioactiveMaterials
    def get_shipmentDimensions(self):
        return self.shipmentDimensions
    def set_shipmentDimensions(self, shipmentDimensions):
        self.shipmentDimensions = shipmentDimensions
    def get_subsidiaryHazardClass(self):
        return self.subsidiaryHazardClass
    def set_subsidiaryHazardClass(self, subsidiaryHazardClass):
        self.subsidiaryHazardClass = subsidiaryHazardClass
    def add_subsidiaryHazardClass(self, value):
        self.subsidiaryHazardClass.append(value)
    def insert_subsidiaryHazardClass_at(self, index, value):
        self.subsidiaryHazardClass.insert(index, value)
    def replace_subsidiaryHazardClass_at(self, index, value):
        self.subsidiaryHazardClass[index] = value
    def get_temperatures(self):
        return self.temperatures
    def set_temperatures(self, temperatures):
        self.temperatures = temperatures
    def get_compatibilityGroup(self):
        return self.compatibilityGroup
    def set_compatibilityGroup(self, compatibilityGroup):
        self.compatibilityGroup = compatibilityGroup
    def get_dangerousGoodsLimitation(self):
        return self.dangerousGoodsLimitation
    def set_dangerousGoodsLimitation(self, dangerousGoodsLimitation):
        self.dangerousGoodsLimitation = dangerousGoodsLimitation
    def get_dangerousGoodsQuantity(self):
        return self.dangerousGoodsQuantity
    def set_dangerousGoodsQuantity(self, dangerousGoodsQuantity):
        self.dangerousGoodsQuantity = dangerousGoodsQuantity
    def get_marinePollutantIndicator(self):
        return self.marinePollutantIndicator
    def set_marinePollutantIndicator(self, marinePollutantIndicator):
        self.marinePollutantIndicator = marinePollutantIndicator
    def get_overpackIndicator(self):
        return self.overpackIndicator
    def set_overpackIndicator(self, overpackIndicator):
        self.overpackIndicator = overpackIndicator
    def get_packingGroup(self):
        return self.packingGroup
    def set_packingGroup(self, packingGroup):
        self.packingGroup = packingGroup
    def get_packingInstructionNumber(self):
        return self.packingInstructionNumber
    def set_packingInstructionNumber(self, packingInstructionNumber):
        self.packingInstructionNumber = packingInstructionNumber
    def get_productName(self):
        return self.productName
    def set_productName(self, productName):
        self.productName = productName
    def get_properShippingName(self):
        return self.properShippingName
    def set_properShippingName(self, properShippingName):
        self.properShippingName = properShippingName
    def get_reportableQuantity(self):
        return self.reportableQuantity
    def set_reportableQuantity(self, reportableQuantity):
        self.reportableQuantity = reportableQuantity
    def get_shipmentType(self):
        return self.shipmentType
    def set_shipmentType(self, shipmentType):
        self.shipmentType = shipmentType
    def get_supplementaryInformation(self):
        return self.supplementaryInformation
    def set_supplementaryInformation(self, supplementaryInformation):
        self.supplementaryInformation = supplementaryInformation
    def get_technicalName(self):
        return self.technicalName
    def set_technicalName(self, technicalName):
        self.technicalName = technicalName
    def get_typeOfPackaging(self):
        return self.typeOfPackaging
    def set_typeOfPackaging(self, typeOfPackaging):
        self.typeOfPackaging = typeOfPackaging
    def get_unNumber(self):
        return self.unNumber
    def set_unNumber(self, unNumber):
        self.unNumber = unNumber
    def validate_CompatibilityGroupType(self, value):
        # Validate type fx:CompatibilityGroupType, a restriction on fb:FreeTextType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CompatibilityGroupType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CompatibilityGroupType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CompatibilityGroupType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CompatibilityGroupType_patterns_, ))
    validate_CompatibilityGroupType_patterns_ = [['^([A-H|K-L|N|S])$']]
    def validate_AircraftDangerousGoodsLimitationType(self, value):
        # Validate type fx:AircraftDangerousGoodsLimitationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PASSENGER_AND_CARGO_AIRCRAFT', 'CARGO_AIRCRAFT_ONLY']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AircraftDangerousGoodsLimitationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_CountType(self, value):
        # Validate type fb:CountType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on CountType' % {"value": value, "lineno": lineno} )
                result = False
    def validate_MarinePollutantIndicatorType(self, value):
        # Validate type fx:MarinePollutantIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MARINE_POLLUTANT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MarinePollutantIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_OverpackIndicatorType(self, value):
        # Validate type fx:OverpackIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OVERPACK_USED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OverpackIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_PackingGroupType(self, value):
        # Validate type fx:PackingGroupType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['I', 'II', 'III']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PackingGroupType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ShipmentTypeType(self, value):
        # Validate type fx:ShipmentTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['RADIOACTIVE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ShipmentTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.allPackedInOne is not None or
            self.hazardClass is not None or
            self.packageDimensions is not None or
            self.radioactiveMaterials is not None or
            self.shipmentDimensions is not None or
            self.subsidiaryHazardClass or
            self.temperatures is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='DangerousGoodsPackageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DangerousGoodsPackageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DangerousGoodsPackageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DangerousGoodsPackageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='DangerousGoodsPackageType'):
        if self.compatibilityGroup is not None and 'compatibilityGroup' not in already_processed:
            already_processed.add('compatibilityGroup')
            outfile.write(' compatibilityGroup=%s' % (quote_attrib(self.compatibilityGroup), ))
        if self.dangerousGoodsLimitation is not None and 'dangerousGoodsLimitation' not in already_processed:
            already_processed.add('dangerousGoodsLimitation')
            outfile.write(' dangerousGoodsLimitation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dangerousGoodsLimitation), input_name='dangerousGoodsLimitation')), ))
        if self.dangerousGoodsQuantity is not None and 'dangerousGoodsQuantity' not in already_processed:
            already_processed.add('dangerousGoodsQuantity')
            outfile.write(' dangerousGoodsQuantity="%s"' % self.gds_format_integer(self.dangerousGoodsQuantity, input_name='dangerousGoodsQuantity'))
        if self.marinePollutantIndicator is not None and 'marinePollutantIndicator' not in already_processed:
            already_processed.add('marinePollutantIndicator')
            outfile.write(' marinePollutantIndicator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.marinePollutantIndicator), input_name='marinePollutantIndicator')), ))
        if self.overpackIndicator is not None and 'overpackIndicator' not in already_processed:
            already_processed.add('overpackIndicator')
            outfile.write(' overpackIndicator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.overpackIndicator), input_name='overpackIndicator')), ))
        if self.packingGroup is not None and 'packingGroup' not in already_processed:
            already_processed.add('packingGroup')
            outfile.write(' packingGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.packingGroup), input_name='packingGroup')), ))
        if self.packingInstructionNumber is not None and 'packingInstructionNumber' not in already_processed:
            already_processed.add('packingInstructionNumber')
            outfile.write(' packingInstructionNumber=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.packingInstructionNumber), input_name='packingInstructionNumber')), ))
        if self.productName is not None and 'productName' not in already_processed:
            already_processed.add('productName')
            outfile.write(' productName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.productName), input_name='productName')), ))
        if self.properShippingName is not None and 'properShippingName' not in already_processed:
            already_processed.add('properShippingName')
            outfile.write(' properShippingName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.properShippingName), input_name='properShippingName')), ))
        if self.reportableQuantity is not None and 'reportableQuantity' not in already_processed:
            already_processed.add('reportableQuantity')
            outfile.write(' reportableQuantity="%s"' % self.gds_format_integer(self.reportableQuantity, input_name='reportableQuantity'))
        if self.shipmentType is not None and 'shipmentType' not in already_processed:
            already_processed.add('shipmentType')
            outfile.write(' shipmentType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.shipmentType), input_name='shipmentType')), ))
        if self.supplementaryInformation is not None and 'supplementaryInformation' not in already_processed:
            already_processed.add('supplementaryInformation')
            outfile.write(' supplementaryInformation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.supplementaryInformation), input_name='supplementaryInformation')), ))
        if self.technicalName is not None and 'technicalName' not in already_processed:
            already_processed.add('technicalName')
            outfile.write(' technicalName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.technicalName), input_name='technicalName')), ))
        if self.typeOfPackaging is not None and 'typeOfPackaging' not in already_processed:
            already_processed.add('typeOfPackaging')
            outfile.write(' typeOfPackaging=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.typeOfPackaging), input_name='typeOfPackaging')), ))
        if self.unNumber is not None and 'unNumber' not in already_processed:
            already_processed.add('unNumber')
            outfile.write(' unNumber=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unNumber), input_name='unNumber')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='DangerousGoodsPackageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.allPackedInOne is not None:
            namespaceprefix_ = self.allPackedInOne_nsprefix_ + ':' if (UseCapturedNS_ and self.allPackedInOne_nsprefix_) else ''
            self.allPackedInOne.export(outfile, level, namespaceprefix_, namespacedef_='', name_='allPackedInOne', pretty_print=pretty_print)
        if self.hazardClass is not None:
            namespaceprefix_ = self.hazardClass_nsprefix_ + ':' if (UseCapturedNS_ and self.hazardClass_nsprefix_) else ''
            self.hazardClass.export(outfile, level, namespaceprefix_, namespacedef_='', name_='hazardClass', pretty_print=pretty_print)
        if self.packageDimensions is not None:
            namespaceprefix_ = self.packageDimensions_nsprefix_ + ':' if (UseCapturedNS_ and self.packageDimensions_nsprefix_) else ''
            self.packageDimensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='packageDimensions', pretty_print=pretty_print)
        if self.radioactiveMaterials is not None:
            namespaceprefix_ = self.radioactiveMaterials_nsprefix_ + ':' if (UseCapturedNS_ and self.radioactiveMaterials_nsprefix_) else ''
            self.radioactiveMaterials.export(outfile, level, namespaceprefix_, namespacedef_='', name_='radioactiveMaterials', pretty_print=pretty_print)
        if self.shipmentDimensions is not None:
            namespaceprefix_ = self.shipmentDimensions_nsprefix_ + ':' if (UseCapturedNS_ and self.shipmentDimensions_nsprefix_) else ''
            self.shipmentDimensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='shipmentDimensions', pretty_print=pretty_print)
        for subsidiaryHazardClass_ in self.subsidiaryHazardClass:
            namespaceprefix_ = self.subsidiaryHazardClass_nsprefix_ + ':' if (UseCapturedNS_ and self.subsidiaryHazardClass_nsprefix_) else ''
            subsidiaryHazardClass_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subsidiaryHazardClass', pretty_print=pretty_print)
        if self.temperatures is not None:
            namespaceprefix_ = self.temperatures_nsprefix_ + ':' if (UseCapturedNS_ and self.temperatures_nsprefix_) else ''
            self.temperatures.export(outfile, level, namespaceprefix_, namespacedef_='', name_='temperatures', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('compatibilityGroup', node)
        if value is not None and 'compatibilityGroup' not in already_processed:
            already_processed.add('compatibilityGroup')
            self.compatibilityGroup = value
            self.validate_CompatibilityGroupType(self.compatibilityGroup)    # validate type CompatibilityGroupType
        value = find_attr_value_('dangerousGoodsLimitation', node)
        if value is not None and 'dangerousGoodsLimitation' not in already_processed:
            already_processed.add('dangerousGoodsLimitation')
            self.dangerousGoodsLimitation = value
            self.validate_AircraftDangerousGoodsLimitationType(self.dangerousGoodsLimitation)    # validate type AircraftDangerousGoodsLimitationType
        value = find_attr_value_('dangerousGoodsQuantity', node)
        if value is not None and 'dangerousGoodsQuantity' not in already_processed:
            already_processed.add('dangerousGoodsQuantity')
            self.dangerousGoodsQuantity = self.gds_parse_integer(value, node, 'dangerousGoodsQuantity')
            self.validate_CountType(self.dangerousGoodsQuantity)    # validate type CountType
        value = find_attr_value_('marinePollutantIndicator', node)
        if value is not None and 'marinePollutantIndicator' not in already_processed:
            already_processed.add('marinePollutantIndicator')
            self.marinePollutantIndicator = value
            self.validate_MarinePollutantIndicatorType(self.marinePollutantIndicator)    # validate type MarinePollutantIndicatorType
        value = find_attr_value_('overpackIndicator', node)
        if value is not None and 'overpackIndicator' not in already_processed:
            already_processed.add('overpackIndicator')
            self.overpackIndicator = value
            self.validate_OverpackIndicatorType(self.overpackIndicator)    # validate type OverpackIndicatorType
        value = find_attr_value_('packingGroup', node)
        if value is not None and 'packingGroup' not in already_processed:
            already_processed.add('packingGroup')
            self.packingGroup = value
            self.validate_PackingGroupType(self.packingGroup)    # validate type PackingGroupType
        value = find_attr_value_('packingInstructionNumber', node)
        if value is not None and 'packingInstructionNumber' not in already_processed:
            already_processed.add('packingInstructionNumber')
            self.packingInstructionNumber = value
            self.validate_FreeTextType(self.packingInstructionNumber)    # validate type FreeTextType
        value = find_attr_value_('productName', node)
        if value is not None and 'productName' not in already_processed:
            already_processed.add('productName')
            self.productName = value
            self.validate_FreeTextType(self.productName)    # validate type FreeTextType
        value = find_attr_value_('properShippingName', node)
        if value is not None and 'properShippingName' not in already_processed:
            already_processed.add('properShippingName')
            self.properShippingName = value
            self.validate_FreeTextType(self.properShippingName)    # validate type FreeTextType
        value = find_attr_value_('reportableQuantity', node)
        if value is not None and 'reportableQuantity' not in already_processed:
            already_processed.add('reportableQuantity')
            self.reportableQuantity = self.gds_parse_integer(value, node, 'reportableQuantity')
            self.validate_CountType(self.reportableQuantity)    # validate type CountType
        value = find_attr_value_('shipmentType', node)
        if value is not None and 'shipmentType' not in already_processed:
            already_processed.add('shipmentType')
            self.shipmentType = value
            self.validate_ShipmentTypeType(self.shipmentType)    # validate type ShipmentTypeType
        value = find_attr_value_('supplementaryInformation', node)
        if value is not None and 'supplementaryInformation' not in already_processed:
            already_processed.add('supplementaryInformation')
            self.supplementaryInformation = value
            self.validate_FreeTextType(self.supplementaryInformation)    # validate type FreeTextType
        value = find_attr_value_('technicalName', node)
        if value is not None and 'technicalName' not in already_processed:
            already_processed.add('technicalName')
            self.technicalName = value
            self.validate_FreeTextType(self.technicalName)    # validate type FreeTextType
        value = find_attr_value_('typeOfPackaging', node)
        if value is not None and 'typeOfPackaging' not in already_processed:
            already_processed.add('typeOfPackaging')
            self.typeOfPackaging = value
            self.validate_FreeTextType(self.typeOfPackaging)    # validate type FreeTextType
        value = find_attr_value_('unNumber', node)
        if value is not None and 'unNumber' not in already_processed:
            already_processed.add('unNumber')
            self.unNumber = value
            self.validate_FreeTextType(self.unNumber)    # validate type FreeTextType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'allPackedInOne':
            obj_ = AllPackedInOneType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.allPackedInOne = obj_
            obj_.original_tagname_ = 'allPackedInOne'
        elif nodeName_ == 'hazardClass':
            obj_ = HazardClassType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.hazardClass = obj_
            obj_.original_tagname_ = 'hazardClass'
        elif nodeName_ == 'packageDimensions':
            obj_ = DimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.packageDimensions = obj_
            obj_.original_tagname_ = 'packageDimensions'
        elif nodeName_ == 'radioactiveMaterials':
            obj_ = RadioactiveMaterialType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.radioactiveMaterials = obj_
            obj_.original_tagname_ = 'radioactiveMaterials'
        elif nodeName_ == 'shipmentDimensions':
            obj_ = DangerousGoodsDimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.shipmentDimensions = obj_
            obj_.original_tagname_ = 'shipmentDimensions'
        elif nodeName_ == 'subsidiaryHazardClass':
            obj_ = HazardClassType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subsidiaryHazardClass.append(obj_)
            obj_.original_tagname_ = 'subsidiaryHazardClass'
        elif nodeName_ == 'temperatures':
            obj_ = TemperaturesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.temperatures = obj_
            obj_.original_tagname_ = 'temperatures'
# end class DangerousGoodsPackageType


class DangerousGoodsPackageGroupType(GeneratedsSuper):
    """A collection of at least one DangerousGoodsPackage.
    .Shipper's Declaration For Dangerous Goods Packaging Detail: The part of
    the IATA
    Shipper's Declaration For Dangerous Goods that contains the packaging
    details for
    this shipment.
    .Dangerous Goods Package Details: The part of the IATA Shipper's
    Declaration For
    Dangerous Goods that contains the Package Details for the shipment.
    .Exclusive Use Shipment Indicator: An indicator of sole use, by a single
    shipper,
    of an aircraft or of a large freight container, of which all initial,
    intermediate
    and final loading and unloading is carried out in accordance with the
    directions
    of the shipper or consignee."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, shipmentUseIndicator=None, dangerousGoodsPackage=None, shipmentDimensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.shipmentUseIndicator = _cast(None, shipmentUseIndicator)
        self.shipmentUseIndicator_nsprefix_ = None
        if dangerousGoodsPackage is None:
            self.dangerousGoodsPackage = []
        else:
            self.dangerousGoodsPackage = dangerousGoodsPackage
        self.dangerousGoodsPackage_nsprefix_ = None
        self.shipmentDimensions = shipmentDimensions
        self.shipmentDimensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DangerousGoodsPackageGroupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DangerousGoodsPackageGroupType.subclass:
            return DangerousGoodsPackageGroupType.subclass(*args_, **kwargs_)
        else:
            return DangerousGoodsPackageGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dangerousGoodsPackage(self):
        return self.dangerousGoodsPackage
    def set_dangerousGoodsPackage(self, dangerousGoodsPackage):
        self.dangerousGoodsPackage = dangerousGoodsPackage
    def add_dangerousGoodsPackage(self, value):
        self.dangerousGoodsPackage.append(value)
    def insert_dangerousGoodsPackage_at(self, index, value):
        self.dangerousGoodsPackage.insert(index, value)
    def replace_dangerousGoodsPackage_at(self, index, value):
        self.dangerousGoodsPackage[index] = value
    def get_shipmentDimensions(self):
        return self.shipmentDimensions
    def set_shipmentDimensions(self, shipmentDimensions):
        self.shipmentDimensions = shipmentDimensions
    def get_shipmentUseIndicator(self):
        return self.shipmentUseIndicator
    def set_shipmentUseIndicator(self, shipmentUseIndicator):
        self.shipmentUseIndicator = shipmentUseIndicator
    def validate_ShipmentUseType(self, value):
        # Validate type fx:ShipmentUseType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['EXCLUSIVE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ShipmentUseType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.dangerousGoodsPackage or
            self.shipmentDimensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='DangerousGoodsPackageGroupType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DangerousGoodsPackageGroupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DangerousGoodsPackageGroupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DangerousGoodsPackageGroupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='DangerousGoodsPackageGroupType'):
        if self.shipmentUseIndicator is not None and 'shipmentUseIndicator' not in already_processed:
            already_processed.add('shipmentUseIndicator')
            outfile.write(' shipmentUseIndicator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.shipmentUseIndicator), input_name='shipmentUseIndicator')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='DangerousGoodsPackageGroupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dangerousGoodsPackage_ in self.dangerousGoodsPackage:
            namespaceprefix_ = self.dangerousGoodsPackage_nsprefix_ + ':' if (UseCapturedNS_ and self.dangerousGoodsPackage_nsprefix_) else ''
            dangerousGoodsPackage_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dangerousGoodsPackage', pretty_print=pretty_print)
        if self.shipmentDimensions is not None:
            namespaceprefix_ = self.shipmentDimensions_nsprefix_ + ':' if (UseCapturedNS_ and self.shipmentDimensions_nsprefix_) else ''
            self.shipmentDimensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='shipmentDimensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('shipmentUseIndicator', node)
        if value is not None and 'shipmentUseIndicator' not in already_processed:
            already_processed.add('shipmentUseIndicator')
            self.shipmentUseIndicator = value
            self.validate_ShipmentUseType(self.shipmentUseIndicator)    # validate type ShipmentUseType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dangerousGoodsPackage':
            obj_ = DangerousGoodsPackageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dangerousGoodsPackage.append(obj_)
            obj_.original_tagname_ = 'dangerousGoodsPackage'
        elif nodeName_ == 'shipmentDimensions':
            obj_ = DangerousGoodsDimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.shipmentDimensions = obj_
            obj_.original_tagname_ = 'shipmentDimensions'
# end class DangerousGoodsPackageGroupType


class HazardClassType(GeneratedsSuper):
    """.Hazard Class and Division: A number assigned to a dangerous good that
    represents
    a classification (Class) according to the most dominant hazard it
    represents, potentially
    followed by a number representing a subdivision (Division) within the
    Class.
    .Subsidiary Hazard Class and Division: An identifier of any subsidiary
    hazard class(es)/division(s)
    in addition to the primary hazard class and division.
    A number representing a subdivision (Division) within the Class."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, hazardDivision=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.hazardDivision = _cast(None, hazardDivision)
        self.hazardDivision_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HazardClassType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HazardClassType.subclass:
            return HazardClassType.subclass(*args_, **kwargs_)
        else:
            return HazardClassType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_hazardDivision(self):
        return self.hazardDivision
    def set_hazardDivision(self, hazardDivision):
        self.hazardDivision = hazardDivision
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_CountType(self, value):
        # Validate type fb:CountType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on CountType' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='HazardClassType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HazardClassType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HazardClassType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HazardClassType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='HazardClassType'):
        if self.hazardDivision is not None and 'hazardDivision' not in already_processed:
            already_processed.add('hazardDivision')
            outfile.write(' hazardDivision="%s"' % self.gds_format_integer(self.hazardDivision, input_name='hazardDivision'))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='HazardClassType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hazardDivision', node)
        if value is not None and 'hazardDivision' not in already_processed:
            already_processed.add('hazardDivision')
            self.hazardDivision = self.gds_parse_integer(value, node, 'hazardDivision')
            self.validate_CountType(self.hazardDivision)    # validate type CountType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class HazardClassType


class TemperaturesType(GeneratedsSuper):
    """Control Temperature:
    Emergency Temperature:
    Flashpoint Temperature:
    The lowest temperature at which it can vaporize to form an ignitable
    mixture in air."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, controlTemperature=None, emergencyTemperature=None, flashpointTemperature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.controlTemperature = controlTemperature
        self.controlTemperature_nsprefix_ = None
        self.emergencyTemperature = emergencyTemperature
        self.emergencyTemperature_nsprefix_ = None
        self.flashpointTemperature = flashpointTemperature
        self.flashpointTemperature_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemperaturesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemperaturesType.subclass:
            return TemperaturesType.subclass(*args_, **kwargs_)
        else:
            return TemperaturesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_controlTemperature(self):
        return self.controlTemperature
    def set_controlTemperature(self, controlTemperature):
        self.controlTemperature = controlTemperature
    def get_emergencyTemperature(self):
        return self.emergencyTemperature
    def set_emergencyTemperature(self, emergencyTemperature):
        self.emergencyTemperature = emergencyTemperature
    def get_flashpointTemperature(self):
        return self.flashpointTemperature
    def set_flashpointTemperature(self, flashpointTemperature):
        self.flashpointTemperature = flashpointTemperature
    def hasContent_(self):
        if (
            self.controlTemperature is not None or
            self.emergencyTemperature is not None or
            self.flashpointTemperature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='TemperaturesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TemperaturesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TemperaturesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TemperaturesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='TemperaturesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='TemperaturesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.controlTemperature is not None:
            namespaceprefix_ = self.controlTemperature_nsprefix_ + ':' if (UseCapturedNS_ and self.controlTemperature_nsprefix_) else ''
            self.controlTemperature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='controlTemperature', pretty_print=pretty_print)
        if self.emergencyTemperature is not None:
            namespaceprefix_ = self.emergencyTemperature_nsprefix_ + ':' if (UseCapturedNS_ and self.emergencyTemperature_nsprefix_) else ''
            self.emergencyTemperature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emergencyTemperature', pretty_print=pretty_print)
        if self.flashpointTemperature is not None:
            namespaceprefix_ = self.flashpointTemperature_nsprefix_ + ':' if (UseCapturedNS_ and self.flashpointTemperature_nsprefix_) else ''
            self.flashpointTemperature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='flashpointTemperature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'controlTemperature':
            obj_ = TemperatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.controlTemperature = obj_
            obj_.original_tagname_ = 'controlTemperature'
        elif nodeName_ == 'emergencyTemperature':
            obj_ = TemperatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.emergencyTemperature = obj_
            obj_.original_tagname_ = 'emergencyTemperature'
        elif nodeName_ == 'flashpointTemperature':
            obj_ = TemperatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.flashpointTemperature = obj_
            obj_.original_tagname_ = 'flashpointTemperature'
# end class TemperaturesType


class RadioactiveMaterialType(GeneratedsSuper):
    """.Radioactive Materials: The XML grouping element for goods that contain
    radioactive
    materials.
    .Radioactive Material Category: A category used for radioactive materials
    in a package,
    overpack or freight container, based on their maximum radiation level.
    .Criticality Safety Index: The dimensionless number (rounded up to the next
    tenth)
    assigned to and placed on the label of a fissile material package to
    designate the
    degree of control of accumulation of packages containing fissile material
    during
    transportation.
    .Fissile Excepted Indicator: An indicator of whether the restrictions for
    fissile
    material are excepted for a particular package.
    .Transport Index: A figure representing the radiation level measured at one
    meter
    from the package."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, category=None, criticalitySafetyIndex=None, fissileExceptedIndicator=None, transportIndex=None, radionuclide=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.category = _cast(None, category)
        self.category_nsprefix_ = None
        self.criticalitySafetyIndex = _cast(None, criticalitySafetyIndex)
        self.criticalitySafetyIndex_nsprefix_ = None
        self.fissileExceptedIndicator = _cast(None, fissileExceptedIndicator)
        self.fissileExceptedIndicator_nsprefix_ = None
        self.transportIndex = _cast(None, transportIndex)
        self.transportIndex_nsprefix_ = None
        self.radionuclide = radionuclide
        self.radionuclide_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadioactiveMaterialType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadioactiveMaterialType.subclass:
            return RadioactiveMaterialType.subclass(*args_, **kwargs_)
        else:
            return RadioactiveMaterialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_radionuclide(self):
        return self.radionuclide
    def set_radionuclide(self, radionuclide):
        self.radionuclide = radionuclide
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def get_criticalitySafetyIndex(self):
        return self.criticalitySafetyIndex
    def set_criticalitySafetyIndex(self, criticalitySafetyIndex):
        self.criticalitySafetyIndex = criticalitySafetyIndex
    def get_fissileExceptedIndicator(self):
        return self.fissileExceptedIndicator
    def set_fissileExceptedIndicator(self, fissileExceptedIndicator):
        self.fissileExceptedIndicator = fissileExceptedIndicator
    def get_transportIndex(self):
        return self.transportIndex
    def set_transportIndex(self, transportIndex):
        self.transportIndex = transportIndex
    def validate_RadioactiveMaterialCategoryType(self, value):
        # Validate type fx:RadioactiveMaterialCategoryType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['I_WHITE', 'II_YELLOW', 'III_YELLOW']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RadioactiveMaterialCategoryType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DecimalIndexType(self, value):
        # Validate type fb:DecimalIndexType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on DecimalIndexType' % {"value": value, "lineno": lineno} )
                result = False
    def validate_FissileExceptedType(self, value):
        # Validate type fx:FissileExceptedType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['EXCEPTED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FissileExceptedType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.radionuclide is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='RadioactiveMaterialType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RadioactiveMaterialType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RadioactiveMaterialType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RadioactiveMaterialType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='RadioactiveMaterialType'):
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
        if self.criticalitySafetyIndex is not None and 'criticalitySafetyIndex' not in already_processed:
            already_processed.add('criticalitySafetyIndex')
            outfile.write(' criticalitySafetyIndex="%s"' % self.gds_format_decimal(self.criticalitySafetyIndex, input_name='criticalitySafetyIndex'))
        if self.fissileExceptedIndicator is not None and 'fissileExceptedIndicator' not in already_processed:
            already_processed.add('fissileExceptedIndicator')
            outfile.write(' fissileExceptedIndicator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fissileExceptedIndicator), input_name='fissileExceptedIndicator')), ))
        if self.transportIndex is not None and 'transportIndex' not in already_processed:
            already_processed.add('transportIndex')
            outfile.write(' transportIndex="%s"' % self.gds_format_decimal(self.transportIndex, input_name='transportIndex'))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='RadioactiveMaterialType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.radionuclide is not None:
            namespaceprefix_ = self.radionuclide_nsprefix_ + ':' if (UseCapturedNS_ and self.radionuclide_nsprefix_) else ''
            self.radionuclide.export(outfile, level, namespaceprefix_, namespacedef_='', name_='radionuclide', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
            self.validate_RadioactiveMaterialCategoryType(self.category)    # validate type RadioactiveMaterialCategoryType
        value = find_attr_value_('criticalitySafetyIndex', node)
        if value is not None and 'criticalitySafetyIndex' not in already_processed:
            already_processed.add('criticalitySafetyIndex')
            value = self.gds_parse_decimal(value, node, 'criticalitySafetyIndex')
            self.criticalitySafetyIndex = value
            self.validate_DecimalIndexType(self.criticalitySafetyIndex)    # validate type DecimalIndexType
        value = find_attr_value_('fissileExceptedIndicator', node)
        if value is not None and 'fissileExceptedIndicator' not in already_processed:
            already_processed.add('fissileExceptedIndicator')
            self.fissileExceptedIndicator = value
            self.validate_FissileExceptedType(self.fissileExceptedIndicator)    # validate type FissileExceptedType
        value = find_attr_value_('transportIndex', node)
        if value is not None and 'transportIndex' not in already_processed:
            already_processed.add('transportIndex')
            value = self.gds_parse_decimal(value, node, 'transportIndex')
            self.transportIndex = value
            self.validate_DecimalIndexType(self.transportIndex)    # validate type DecimalIndexType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'radionuclide':
            obj_ = RadionuclideType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.radionuclide = obj_
            obj_.original_tagname_ = 'radionuclide'
# end class RadioactiveMaterialType


class RadioactiveMaterialActivityType(GeneratedsSuper):
    """.Activity: The measure of the rate of decay, or activity, of a
    radioactive material.
    Units of measure of for RadioactiveMaterialActivity."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.uom = _cast(None, uom)
        self.uom_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadioactiveMaterialActivityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadioactiveMaterialActivityType.subclass:
            return RadioactiveMaterialActivityType.subclass(*args_, **kwargs_)
        else:
            return RadioactiveMaterialActivityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_RadioactivityMeasureType(self, value):
        # Validate type fx:RadioactivityMeasureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['GRAMS', 'BECQUERELS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RadioactivityMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='RadioactiveMaterialActivityType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RadioactiveMaterialActivityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RadioactiveMaterialActivityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RadioactiveMaterialActivityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='RadioactiveMaterialActivityType'):
        if self.uom is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            outfile.write(' uom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uom), input_name='uom')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='RadioactiveMaterialActivityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uom', node)
        if value is not None and 'uom' not in already_processed:
            already_processed.add('uom')
            self.uom = value
            self.validate_RadioactivityMeasureType(self.uom)    # validate type RadioactivityMeasureType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RadioactiveMaterialActivityType


class RadionuclideType(GeneratedsSuper):
    """.Radionuclide: The XML sub-grouping element for Radioactive Materials.
    .Low Dispersible Material Indicator: An indicator the dangerous good is a
    low dispersible
    radioactive material, a solid radioactive material or a solid radioactive
    material
    in a sealed capsule, which has limited dispersibility and is not in powder
    form.
    .Physical and Chemical Form: A description of the physical and chemical
    form when
    the dangerous goods are radioactive.
    .Radionuclide ID: Identification number of each radionuclide or for
    mixtures of radionuclides.
    .Radionuclide Name: The name or symbol of each radionuclide or for mixtures
    of radionuclides,
    an appropriate general description, or a list of the most restrictive
    nuclides.
    .Special Form Indicator: A notation that the material is 'special form' and
    cannot
    produce radioactive contamination."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lowDispersibleMaterialIndicator=None, physicalChemicalForm=None, radionuclideId=None, radionuclideName=None, specialFormIndicator=None, activity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lowDispersibleMaterialIndicator = _cast(None, lowDispersibleMaterialIndicator)
        self.lowDispersibleMaterialIndicator_nsprefix_ = None
        self.physicalChemicalForm = _cast(None, physicalChemicalForm)
        self.physicalChemicalForm_nsprefix_ = None
        self.radionuclideId = _cast(None, radionuclideId)
        self.radionuclideId_nsprefix_ = None
        self.radionuclideName = _cast(None, radionuclideName)
        self.radionuclideName_nsprefix_ = None
        self.specialFormIndicator = _cast(None, specialFormIndicator)
        self.specialFormIndicator_nsprefix_ = None
        self.activity = activity
        self.activity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadionuclideType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadionuclideType.subclass:
            return RadionuclideType.subclass(*args_, **kwargs_)
        else:
            return RadionuclideType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_activity(self):
        return self.activity
    def set_activity(self, activity):
        self.activity = activity
    def get_lowDispersibleMaterialIndicator(self):
        return self.lowDispersibleMaterialIndicator
    def set_lowDispersibleMaterialIndicator(self, lowDispersibleMaterialIndicator):
        self.lowDispersibleMaterialIndicator = lowDispersibleMaterialIndicator
    def get_physicalChemicalForm(self):
        return self.physicalChemicalForm
    def set_physicalChemicalForm(self, physicalChemicalForm):
        self.physicalChemicalForm = physicalChemicalForm
    def get_radionuclideId(self):
        return self.radionuclideId
    def set_radionuclideId(self, radionuclideId):
        self.radionuclideId = radionuclideId
    def get_radionuclideName(self):
        return self.radionuclideName
    def set_radionuclideName(self, radionuclideName):
        self.radionuclideName = radionuclideName
    def get_specialFormIndicator(self):
        return self.specialFormIndicator
    def set_specialFormIndicator(self, specialFormIndicator):
        self.specialFormIndicator = specialFormIndicator
    def validate_MaterialDispersabilityType(self, value):
        # Validate type fx:MaterialDispersabilityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LOW_DISPERSIBLE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MaterialDispersabilityType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_SpecialFormType(self, value):
        # Validate type fx:SpecialFormType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SPECIAL_FORM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SpecialFormType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.activity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='RadionuclideType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RadionuclideType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RadionuclideType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RadionuclideType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='RadionuclideType'):
        if self.lowDispersibleMaterialIndicator is not None and 'lowDispersibleMaterialIndicator' not in already_processed:
            already_processed.add('lowDispersibleMaterialIndicator')
            outfile.write(' lowDispersibleMaterialIndicator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lowDispersibleMaterialIndicator), input_name='lowDispersibleMaterialIndicator')), ))
        if self.physicalChemicalForm is not None and 'physicalChemicalForm' not in already_processed:
            already_processed.add('physicalChemicalForm')
            outfile.write(' physicalChemicalForm=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.physicalChemicalForm), input_name='physicalChemicalForm')), ))
        if self.radionuclideId is not None and 'radionuclideId' not in already_processed:
            already_processed.add('radionuclideId')
            outfile.write(' radionuclideId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.radionuclideId), input_name='radionuclideId')), ))
        if self.radionuclideName is not None and 'radionuclideName' not in already_processed:
            already_processed.add('radionuclideName')
            outfile.write(' radionuclideName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.radionuclideName), input_name='radionuclideName')), ))
        if self.specialFormIndicator is not None and 'specialFormIndicator' not in already_processed:
            already_processed.add('specialFormIndicator')
            outfile.write(' specialFormIndicator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.specialFormIndicator), input_name='specialFormIndicator')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='RadionuclideType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.activity is not None:
            namespaceprefix_ = self.activity_nsprefix_ + ':' if (UseCapturedNS_ and self.activity_nsprefix_) else ''
            self.activity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='activity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lowDispersibleMaterialIndicator', node)
        if value is not None and 'lowDispersibleMaterialIndicator' not in already_processed:
            already_processed.add('lowDispersibleMaterialIndicator')
            self.lowDispersibleMaterialIndicator = value
            self.validate_MaterialDispersabilityType(self.lowDispersibleMaterialIndicator)    # validate type MaterialDispersabilityType
        value = find_attr_value_('physicalChemicalForm', node)
        if value is not None and 'physicalChemicalForm' not in already_processed:
            already_processed.add('physicalChemicalForm')
            self.physicalChemicalForm = value
            self.validate_FreeTextType(self.physicalChemicalForm)    # validate type FreeTextType
        value = find_attr_value_('radionuclideId', node)
        if value is not None and 'radionuclideId' not in already_processed:
            already_processed.add('radionuclideId')
            self.radionuclideId = value
            self.validate_FreeTextType(self.radionuclideId)    # validate type FreeTextType
        value = find_attr_value_('radionuclideName', node)
        if value is not None and 'radionuclideName' not in already_processed:
            already_processed.add('radionuclideName')
            self.radionuclideName = value
            self.validate_FreeTextType(self.radionuclideName)    # validate type FreeTextType
        value = find_attr_value_('specialFormIndicator', node)
        if value is not None and 'specialFormIndicator' not in already_processed:
            already_processed.add('specialFormIndicator')
            self.specialFormIndicator = value
            self.validate_SpecialFormType(self.specialFormIndicator)    # validate type SpecialFormType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'activity':
            obj_ = RadioactiveMaterialActivityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activity = obj_
            obj_.original_tagname_ = 'activity'
# end class RadionuclideType


class FlightArrivalType(FeatureType):
    """Arrival information linked to a flight. This information shall include:
    * assigned runway
    * assigned STAR procedure
    * Missed_Approach status (Boolean)
    * Eligibility for AMAN (Is the flight already in the scope of AMAN
    sequencing?)
    .Fleet Prioritization - Arrival: The relative priority of a flight, within
    a flight
    operator s fleet of aircraft, defined for a portion or the entire arrival
    phase of
    flight.
    .Arrival Sequence Number: The expected sequence of the flight in the
    scheduling list
    of arriving flights.
    .In-Block Time - Earliest: The earliest time an aircraft operator is able
    to arrive
    at the gate on completion of the flight, as specified by the aircraft
    operator when
    submitting the flight information.
    Standard Instrument Arrival Route procedure for the revised destination.
    .Landing Limits: The landing qualification of the flight, considering crew
    and equipment.
    .Standard Instrument Arrival Designator: The textual designator of the
    Standard Instrument
    Arrival (STAR)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FeatureType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, arrivalFleetPrioritization=None, arrivalSequenceNumber=None, earliestInBlockTime=None, filedRevisedDestinationStar=None, landingLimits=None, standardInstrumentArrival=None, approachFix=None, approachTime=None, arrivalAerodrome=None, arrivalAerodromeAlternate=None, arrivalAerodromeOriginal=None, arrivalFix=None, arrivalFixTime=None, filedRevisedDestinationAerodrome=None, runwayPositionAndTime=None, standPositionAndTime=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FlightArrivalType, self).__init__(centre, source, system, timestamp, extensiontype_,  **kwargs_)
        self.arrivalFleetPrioritization = _cast(None, arrivalFleetPrioritization)
        self.arrivalFleetPrioritization_nsprefix_ = None
        self.arrivalSequenceNumber = _cast(None, arrivalSequenceNumber)
        self.arrivalSequenceNumber_nsprefix_ = None
        self.earliestInBlockTime = _cast(None, earliestInBlockTime)
        self.earliestInBlockTime_nsprefix_ = None
        self.filedRevisedDestinationStar = _cast(None, filedRevisedDestinationStar)
        self.filedRevisedDestinationStar_nsprefix_ = None
        self.landingLimits = _cast(None, landingLimits)
        self.landingLimits_nsprefix_ = None
        self.standardInstrumentArrival = _cast(None, standardInstrumentArrival)
        self.standardInstrumentArrival_nsprefix_ = None
        self.approachFix = approachFix
        self.approachFix_nsprefix_ = None
        self.approachTime = approachTime
        self.approachTime_nsprefix_ = None
        self.arrivalAerodrome = arrivalAerodrome
        self.arrivalAerodrome_nsprefix_ = None
        if arrivalAerodromeAlternate is None:
            self.arrivalAerodromeAlternate = []
        else:
            self.arrivalAerodromeAlternate = arrivalAerodromeAlternate
        self.arrivalAerodromeAlternate_nsprefix_ = None
        self.arrivalAerodromeOriginal = arrivalAerodromeOriginal
        self.arrivalAerodromeOriginal_nsprefix_ = None
        self.arrivalFix = arrivalFix
        self.arrivalFix_nsprefix_ = None
        self.arrivalFixTime = arrivalFixTime
        self.arrivalFixTime_nsprefix_ = None
        self.filedRevisedDestinationAerodrome = filedRevisedDestinationAerodrome
        self.filedRevisedDestinationAerodrome_nsprefix_ = None
        self.runwayPositionAndTime = runwayPositionAndTime
        self.runwayPositionAndTime_nsprefix_ = None
        self.standPositionAndTime = standPositionAndTime
        self.standPositionAndTime_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlightArrivalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlightArrivalType.subclass:
            return FlightArrivalType.subclass(*args_, **kwargs_)
        else:
            return FlightArrivalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_approachFix(self):
        return self.approachFix
    def set_approachFix(self, approachFix):
        self.approachFix = approachFix
    def set_approachFix_with_type(self, value):
        self.approachFix = value
        value.original_tagname_ = 'approachFix'
        value.extensiontype_ = value.__class__.__name__
    def get_approachTime(self):
        return self.approachTime
    def set_approachTime(self, approachTime):
        self.approachTime = approachTime
    def get_arrivalAerodrome(self):
        return self.arrivalAerodrome
    def set_arrivalAerodrome(self, arrivalAerodrome):
        self.arrivalAerodrome = arrivalAerodrome
    def set_arrivalAerodrome_with_type(self, value):
        self.arrivalAerodrome = value
        value.original_tagname_ = 'arrivalAerodrome'
        value.extensiontype_ = value.__class__.__name__
    def get_arrivalAerodromeAlternate(self):
        return self.arrivalAerodromeAlternate
    def set_arrivalAerodromeAlternate(self, arrivalAerodromeAlternate):
        self.arrivalAerodromeAlternate = arrivalAerodromeAlternate
    def set_arrivalAerodromeAlternate_with_type(self, value):
        self.arrivalAerodromeAlternate = value
        value.original_tagname_ = 'arrivalAerodromeAlternate'
        value.extensiontype_ = value.__class__.__name__
    def add_arrivalAerodromeAlternate(self, value):
        self.arrivalAerodromeAlternate.append(value)
    def add_arrivalAerodromeAlternate_with_type(self, value):
        self.arrivalAerodromeAlternate.append(value)
        value.original_tagname_ = 'arrivalAerodromeAlternate'
        value.extensiontype_ = value.__class__.__name__
    def insert_arrivalAerodromeAlternate_at(self, index, value):
        self.arrivalAerodromeAlternate.insert(index, value)
    def replace_arrivalAerodromeAlternate_at(self, index, value):
        self.arrivalAerodromeAlternate[index] = value
    def get_arrivalAerodromeOriginal(self):
        return self.arrivalAerodromeOriginal
    def set_arrivalAerodromeOriginal(self, arrivalAerodromeOriginal):
        self.arrivalAerodromeOriginal = arrivalAerodromeOriginal
    def set_arrivalAerodromeOriginal_with_type(self, value):
        self.arrivalAerodromeOriginal = value
        value.original_tagname_ = 'arrivalAerodromeOriginal'
        value.extensiontype_ = value.__class__.__name__
    def get_arrivalFix(self):
        return self.arrivalFix
    def set_arrivalFix(self, arrivalFix):
        self.arrivalFix = arrivalFix
    def set_arrivalFix_with_type(self, value):
        self.arrivalFix = value
        value.original_tagname_ = 'arrivalFix'
        value.extensiontype_ = value.__class__.__name__
    def get_arrivalFixTime(self):
        return self.arrivalFixTime
    def set_arrivalFixTime(self, arrivalFixTime):
        self.arrivalFixTime = arrivalFixTime
    def get_filedRevisedDestinationAerodrome(self):
        return self.filedRevisedDestinationAerodrome
    def set_filedRevisedDestinationAerodrome(self, filedRevisedDestinationAerodrome):
        self.filedRevisedDestinationAerodrome = filedRevisedDestinationAerodrome
    def set_filedRevisedDestinationAerodrome_with_type(self, value):
        self.filedRevisedDestinationAerodrome = value
        value.original_tagname_ = 'filedRevisedDestinationAerodrome'
        value.extensiontype_ = value.__class__.__name__
    def get_runwayPositionAndTime(self):
        return self.runwayPositionAndTime
    def set_runwayPositionAndTime(self, runwayPositionAndTime):
        self.runwayPositionAndTime = runwayPositionAndTime
    def get_standPositionAndTime(self):
        return self.standPositionAndTime
    def set_standPositionAndTime(self, standPositionAndTime):
        self.standPositionAndTime = standPositionAndTime
    def get_arrivalFleetPrioritization(self):
        return self.arrivalFleetPrioritization
    def set_arrivalFleetPrioritization(self, arrivalFleetPrioritization):
        self.arrivalFleetPrioritization = arrivalFleetPrioritization
    def get_arrivalSequenceNumber(self):
        return self.arrivalSequenceNumber
    def set_arrivalSequenceNumber(self, arrivalSequenceNumber):
        self.arrivalSequenceNumber = arrivalSequenceNumber
    def get_earliestInBlockTime(self):
        return self.earliestInBlockTime
    def set_earliestInBlockTime(self, earliestInBlockTime):
        self.earliestInBlockTime = earliestInBlockTime
    def get_filedRevisedDestinationStar(self):
        return self.filedRevisedDestinationStar
    def set_filedRevisedDestinationStar(self, filedRevisedDestinationStar):
        self.filedRevisedDestinationStar = filedRevisedDestinationStar
    def get_landingLimits(self):
        return self.landingLimits
    def set_landingLimits(self, landingLimits):
        self.landingLimits = landingLimits
    def get_standardInstrumentArrival(self):
        return self.standardInstrumentArrival
    def set_standardInstrumentArrival(self, standardInstrumentArrival):
        self.standardInstrumentArrival = standardInstrumentArrival
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_FleetPriorityType(self, value):
        # Validate type fb:FleetPriorityType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on FleetPriorityType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on FleetPriorityType' % {"value": value, "lineno": lineno} )
                result = False
    def validate_CountType(self, value):
        # Validate type fb:CountType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on CountType' % {"value": value, "lineno": lineno} )
                result = False
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_StandardInstrumentRouteDesignatorType(self, value):
        # Validate type fb:StandardInstrumentRouteDesignatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_LandingLimitsType(self, value):
        # Validate type fx:LandingLimitsType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['I', 'II', 'III', 'IIIA', 'IIIB', 'IIIC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on LandingLimitsType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.approachFix is not None or
            self.approachTime is not None or
            self.arrivalAerodrome is not None or
            self.arrivalAerodromeAlternate or
            self.arrivalAerodromeOriginal is not None or
            self.arrivalFix is not None or
            self.arrivalFixTime is not None or
            self.filedRevisedDestinationAerodrome is not None or
            self.runwayPositionAndTime is not None or
            self.standPositionAndTime is not None or
            super(FlightArrivalType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='FlightArrivalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlightArrivalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlightArrivalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlightArrivalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='FlightArrivalType'):
        super(FlightArrivalType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlightArrivalType')
        if self.arrivalFleetPrioritization is not None and 'arrivalFleetPrioritization' not in already_processed:
            already_processed.add('arrivalFleetPrioritization')
            outfile.write(' arrivalFleetPrioritization="%s"' % self.gds_format_integer(self.arrivalFleetPrioritization, input_name='arrivalFleetPrioritization'))
        if self.arrivalSequenceNumber is not None and 'arrivalSequenceNumber' not in already_processed:
            already_processed.add('arrivalSequenceNumber')
            outfile.write(' arrivalSequenceNumber="%s"' % self.gds_format_integer(self.arrivalSequenceNumber, input_name='arrivalSequenceNumber'))
        if self.earliestInBlockTime is not None and 'earliestInBlockTime' not in already_processed:
            already_processed.add('earliestInBlockTime')
            outfile.write(' earliestInBlockTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.earliestInBlockTime), input_name='earliestInBlockTime')), ))
        if self.filedRevisedDestinationStar is not None and 'filedRevisedDestinationStar' not in already_processed:
            already_processed.add('filedRevisedDestinationStar')
            outfile.write(' filedRevisedDestinationStar=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.filedRevisedDestinationStar), input_name='filedRevisedDestinationStar')), ))
        if self.landingLimits is not None and 'landingLimits' not in already_processed:
            already_processed.add('landingLimits')
            outfile.write(' landingLimits=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.landingLimits), input_name='landingLimits')), ))
        if self.standardInstrumentArrival is not None and 'standardInstrumentArrival' not in already_processed:
            already_processed.add('standardInstrumentArrival')
            outfile.write(' standardInstrumentArrival=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.standardInstrumentArrival), input_name='standardInstrumentArrival')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='FlightArrivalType', fromsubclass_=False, pretty_print=True):
        super(FlightArrivalType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.approachFix is not None:
            self.approachFix.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.approachTime is not None:
            namespaceprefix_ = self.approachTime_nsprefix_ + ':' if (UseCapturedNS_ and self.approachTime_nsprefix_) else ''
            self.approachTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='approachTime', pretty_print=pretty_print)
        if self.arrivalAerodrome is not None:
            self.arrivalAerodrome.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        for arrivalAerodromeAlternate_ in self.arrivalAerodromeAlternate:
            arrivalAerodromeAlternate_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.arrivalAerodromeOriginal is not None:
            self.arrivalAerodromeOriginal.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.arrivalFix is not None:
            self.arrivalFix.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.arrivalFixTime is not None:
            namespaceprefix_ = self.arrivalFixTime_nsprefix_ + ':' if (UseCapturedNS_ and self.arrivalFixTime_nsprefix_) else ''
            self.arrivalFixTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arrivalFixTime', pretty_print=pretty_print)
        if self.filedRevisedDestinationAerodrome is not None:
            self.filedRevisedDestinationAerodrome.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.runwayPositionAndTime is not None:
            namespaceprefix_ = self.runwayPositionAndTime_nsprefix_ + ':' if (UseCapturedNS_ and self.runwayPositionAndTime_nsprefix_) else ''
            self.runwayPositionAndTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='runwayPositionAndTime', pretty_print=pretty_print)
        if self.standPositionAndTime is not None:
            namespaceprefix_ = self.standPositionAndTime_nsprefix_ + ':' if (UseCapturedNS_ and self.standPositionAndTime_nsprefix_) else ''
            self.standPositionAndTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='standPositionAndTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('arrivalFleetPrioritization', node)
        if value is not None and 'arrivalFleetPrioritization' not in already_processed:
            already_processed.add('arrivalFleetPrioritization')
            self.arrivalFleetPrioritization = self.gds_parse_integer(value, node, 'arrivalFleetPrioritization')
            self.validate_FleetPriorityType(self.arrivalFleetPrioritization)    # validate type FleetPriorityType
        value = find_attr_value_('arrivalSequenceNumber', node)
        if value is not None and 'arrivalSequenceNumber' not in already_processed:
            already_processed.add('arrivalSequenceNumber')
            self.arrivalSequenceNumber = self.gds_parse_integer(value, node, 'arrivalSequenceNumber')
            self.validate_CountType(self.arrivalSequenceNumber)    # validate type CountType
        value = find_attr_value_('earliestInBlockTime', node)
        if value is not None and 'earliestInBlockTime' not in already_processed:
            already_processed.add('earliestInBlockTime')
            try:
                self.earliestInBlockTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (earliestInBlockTime): %s' % exp)
            self.validate_TimeType(self.earliestInBlockTime)    # validate type TimeType
        value = find_attr_value_('filedRevisedDestinationStar', node)
        if value is not None and 'filedRevisedDestinationStar' not in already_processed:
            already_processed.add('filedRevisedDestinationStar')
            self.filedRevisedDestinationStar = value
            self.validate_StandardInstrumentRouteDesignatorType(self.filedRevisedDestinationStar)    # validate type StandardInstrumentRouteDesignatorType
        value = find_attr_value_('landingLimits', node)
        if value is not None and 'landingLimits' not in already_processed:
            already_processed.add('landingLimits')
            self.landingLimits = value
            self.validate_LandingLimitsType(self.landingLimits)    # validate type LandingLimitsType
        value = find_attr_value_('standardInstrumentArrival', node)
        if value is not None and 'standardInstrumentArrival' not in already_processed:
            already_processed.add('standardInstrumentArrival')
            self.standardInstrumentArrival = value
            self.validate_StandardInstrumentRouteDesignatorType(self.standardInstrumentArrival)    # validate type StandardInstrumentRouteDesignatorType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(FlightArrivalType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'approachFix':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <approachFix> element')
            self.approachFix = obj_
            obj_.original_tagname_ = 'approachFix'
        elif nodeName_ == 'approachTime':
            class_obj_ = self.get_class_obj_(child_, MultiTimeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.approachTime = obj_
            obj_.original_tagname_ = 'approachTime'
        elif nodeName_ == 'arrivalAerodrome':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <arrivalAerodrome> element')
            self.arrivalAerodrome = obj_
            obj_.original_tagname_ = 'arrivalAerodrome'
        elif nodeName_ == 'arrivalAerodromeAlternate':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <arrivalAerodromeAlternate> element')
            self.arrivalAerodromeAlternate.append(obj_)
            obj_.original_tagname_ = 'arrivalAerodromeAlternate'
        elif nodeName_ == 'arrivalAerodromeOriginal':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <arrivalAerodromeOriginal> element')
            self.arrivalAerodromeOriginal = obj_
            obj_.original_tagname_ = 'arrivalAerodromeOriginal'
        elif nodeName_ == 'arrivalFix':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <arrivalFix> element')
            self.arrivalFix = obj_
            obj_.original_tagname_ = 'arrivalFix'
        elif nodeName_ == 'arrivalFixTime':
            class_obj_ = self.get_class_obj_(child_, MultiTimeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arrivalFixTime = obj_
            obj_.original_tagname_ = 'arrivalFixTime'
        elif nodeName_ == 'filedRevisedDestinationAerodrome':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <filedRevisedDestinationAerodrome> element')
            self.filedRevisedDestinationAerodrome = obj_
            obj_.original_tagname_ = 'filedRevisedDestinationAerodrome'
        elif nodeName_ == 'runwayPositionAndTime':
            obj_ = RunwayPositionAndTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.runwayPositionAndTime = obj_
            obj_.original_tagname_ = 'runwayPositionAndTime'
        elif nodeName_ == 'standPositionAndTime':
            obj_ = StandPositionAndTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.standPositionAndTime = obj_
            obj_.original_tagname_ = 'standPositionAndTime'
        super(FlightArrivalType, self).buildChildren(child_, node, nodeName_, True)
# end class FlightArrivalType


class DepartureActivityTimesType(GeneratedsSuper):
    """Groups various TimeSequences associated with departure activities."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, boardingTime=None, deIcingTime=None, groundHandlingTime=None, startupTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.boardingTime = boardingTime
        self.boardingTime_nsprefix_ = None
        self.deIcingTime = deIcingTime
        self.deIcingTime_nsprefix_ = None
        self.groundHandlingTime = groundHandlingTime
        self.groundHandlingTime_nsprefix_ = None
        self.startupTime = startupTime
        self.startupTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DepartureActivityTimesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DepartureActivityTimesType.subclass:
            return DepartureActivityTimesType.subclass(*args_, **kwargs_)
        else:
            return DepartureActivityTimesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_boardingTime(self):
        return self.boardingTime
    def set_boardingTime(self, boardingTime):
        self.boardingTime = boardingTime
    def get_deIcingTime(self):
        return self.deIcingTime
    def set_deIcingTime(self, deIcingTime):
        self.deIcingTime = deIcingTime
    def get_groundHandlingTime(self):
        return self.groundHandlingTime
    def set_groundHandlingTime(self, groundHandlingTime):
        self.groundHandlingTime = groundHandlingTime
    def get_startupTime(self):
        return self.startupTime
    def set_startupTime(self, startupTime):
        self.startupTime = startupTime
    def hasContent_(self):
        if (
            self.boardingTime is not None or
            self.deIcingTime is not None or
            self.groundHandlingTime is not None or
            self.startupTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='DepartureActivityTimesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DepartureActivityTimesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DepartureActivityTimesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DepartureActivityTimesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='DepartureActivityTimesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='DepartureActivityTimesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.boardingTime is not None:
            namespaceprefix_ = self.boardingTime_nsprefix_ + ':' if (UseCapturedNS_ and self.boardingTime_nsprefix_) else ''
            self.boardingTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='boardingTime', pretty_print=pretty_print)
        if self.deIcingTime is not None:
            namespaceprefix_ = self.deIcingTime_nsprefix_ + ':' if (UseCapturedNS_ and self.deIcingTime_nsprefix_) else ''
            self.deIcingTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deIcingTime', pretty_print=pretty_print)
        if self.groundHandlingTime is not None:
            namespaceprefix_ = self.groundHandlingTime_nsprefix_ + ':' if (UseCapturedNS_ and self.groundHandlingTime_nsprefix_) else ''
            self.groundHandlingTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='groundHandlingTime', pretty_print=pretty_print)
        if self.startupTime is not None:
            namespaceprefix_ = self.startupTime_nsprefix_ + ':' if (UseCapturedNS_ and self.startupTime_nsprefix_) else ''
            self.startupTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='startupTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'boardingTime':
            obj_ = TimeSequenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.boardingTime = obj_
            obj_.original_tagname_ = 'boardingTime'
        elif nodeName_ == 'deIcingTime':
            obj_ = TimeSequenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deIcingTime = obj_
            obj_.original_tagname_ = 'deIcingTime'
        elif nodeName_ == 'groundHandlingTime':
            obj_ = TimeSequenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.groundHandlingTime = obj_
            obj_.original_tagname_ = 'groundHandlingTime'
        elif nodeName_ == 'startupTime':
            obj_ = TimeSequenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.startupTime = obj_
            obj_.original_tagname_ = 'startupTime'
# end class DepartureActivityTimesType


class FlightDepartureType(FeatureType):
    """Groups information pertaining to the flight's departure.
    .Fleet Prioritization - Departure: The relative priority of a flight,
    within a flight
    operator s fleet of aircraft, defined for a portion or the entire departure
    phase
    of flight.
    .Departure Slot: A time slot at an airport that identifies a point in time
    when an
    aircraft is constrained to depart from the airport.
    .Off Block Time - Earliest: The earliest time an aircraft can push back or
    taxi from
    the stand.
    .Standard Instrument Departure Designator: This is the name of a published
    procedure
    extending from the departure runway to the start of the en route part of
    the aircraft's
    route."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FeatureType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, departureFleetPrioritization=None, departureSlot=None, earliestOffBlockTime=None, standardInstrumentDeparture=None, departureAerodrome=None, departureFix=None, departureFixTime=None, departureTimes=None, offBlockReadyTime=None, runwayPositionAndTime=None, standPositionAndTime=None, takeoffAlternateAerodrome=None, takeoffWeight=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FlightDepartureType, self).__init__(centre, source, system, timestamp, extensiontype_,  **kwargs_)
        self.departureFleetPrioritization = _cast(None, departureFleetPrioritization)
        self.departureFleetPrioritization_nsprefix_ = None
        self.departureSlot = _cast(None, departureSlot)
        self.departureSlot_nsprefix_ = None
        self.earliestOffBlockTime = _cast(None, earliestOffBlockTime)
        self.earliestOffBlockTime_nsprefix_ = None
        self.standardInstrumentDeparture = _cast(None, standardInstrumentDeparture)
        self.standardInstrumentDeparture_nsprefix_ = None
        self.departureAerodrome = departureAerodrome
        self.departureAerodrome_nsprefix_ = None
        self.departureFix = departureFix
        self.departureFix_nsprefix_ = None
        self.departureFixTime = departureFixTime
        self.departureFixTime_nsprefix_ = None
        self.departureTimes = departureTimes
        self.departureTimes_nsprefix_ = None
        self.offBlockReadyTime = offBlockReadyTime
        self.offBlockReadyTime_nsprefix_ = None
        self.runwayPositionAndTime = runwayPositionAndTime
        self.runwayPositionAndTime_nsprefix_ = None
        self.standPositionAndTime = standPositionAndTime
        self.standPositionAndTime_nsprefix_ = None
        if takeoffAlternateAerodrome is None:
            self.takeoffAlternateAerodrome = []
        else:
            self.takeoffAlternateAerodrome = takeoffAlternateAerodrome
        self.takeoffAlternateAerodrome_nsprefix_ = None
        self.takeoffWeight = takeoffWeight
        self.takeoffWeight_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlightDepartureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlightDepartureType.subclass:
            return FlightDepartureType.subclass(*args_, **kwargs_)
        else:
            return FlightDepartureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_departureAerodrome(self):
        return self.departureAerodrome
    def set_departureAerodrome(self, departureAerodrome):
        self.departureAerodrome = departureAerodrome
    def set_departureAerodrome_with_type(self, value):
        self.departureAerodrome = value
        value.original_tagname_ = 'departureAerodrome'
        value.extensiontype_ = value.__class__.__name__
    def get_departureFix(self):
        return self.departureFix
    def set_departureFix(self, departureFix):
        self.departureFix = departureFix
    def set_departureFix_with_type(self, value):
        self.departureFix = value
        value.original_tagname_ = 'departureFix'
        value.extensiontype_ = value.__class__.__name__
    def get_departureFixTime(self):
        return self.departureFixTime
    def set_departureFixTime(self, departureFixTime):
        self.departureFixTime = departureFixTime
    def get_departureTimes(self):
        return self.departureTimes
    def set_departureTimes(self, departureTimes):
        self.departureTimes = departureTimes
    def get_offBlockReadyTime(self):
        return self.offBlockReadyTime
    def set_offBlockReadyTime(self, offBlockReadyTime):
        self.offBlockReadyTime = offBlockReadyTime
    def get_runwayPositionAndTime(self):
        return self.runwayPositionAndTime
    def set_runwayPositionAndTime(self, runwayPositionAndTime):
        self.runwayPositionAndTime = runwayPositionAndTime
    def get_standPositionAndTime(self):
        return self.standPositionAndTime
    def set_standPositionAndTime(self, standPositionAndTime):
        self.standPositionAndTime = standPositionAndTime
    def get_takeoffAlternateAerodrome(self):
        return self.takeoffAlternateAerodrome
    def set_takeoffAlternateAerodrome(self, takeoffAlternateAerodrome):
        self.takeoffAlternateAerodrome = takeoffAlternateAerodrome
    def set_takeoffAlternateAerodrome_with_type(self, value):
        self.takeoffAlternateAerodrome = value
        value.original_tagname_ = 'takeoffAlternateAerodrome'
        value.extensiontype_ = value.__class__.__name__
    def add_takeoffAlternateAerodrome(self, value):
        self.takeoffAlternateAerodrome.append(value)
    def add_takeoffAlternateAerodrome_with_type(self, value):
        self.takeoffAlternateAerodrome.append(value)
        value.original_tagname_ = 'takeoffAlternateAerodrome'
        value.extensiontype_ = value.__class__.__name__
    def insert_takeoffAlternateAerodrome_at(self, index, value):
        self.takeoffAlternateAerodrome.insert(index, value)
    def replace_takeoffAlternateAerodrome_at(self, index, value):
        self.takeoffAlternateAerodrome[index] = value
    def get_takeoffWeight(self):
        return self.takeoffWeight
    def set_takeoffWeight(self, takeoffWeight):
        self.takeoffWeight = takeoffWeight
    def get_departureFleetPrioritization(self):
        return self.departureFleetPrioritization
    def set_departureFleetPrioritization(self, departureFleetPrioritization):
        self.departureFleetPrioritization = departureFleetPrioritization
    def get_departureSlot(self):
        return self.departureSlot
    def set_departureSlot(self, departureSlot):
        self.departureSlot = departureSlot
    def get_earliestOffBlockTime(self):
        return self.earliestOffBlockTime
    def set_earliestOffBlockTime(self, earliestOffBlockTime):
        self.earliestOffBlockTime = earliestOffBlockTime
    def get_standardInstrumentDeparture(self):
        return self.standardInstrumentDeparture
    def set_standardInstrumentDeparture(self, standardInstrumentDeparture):
        self.standardInstrumentDeparture = standardInstrumentDeparture
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_FleetPriorityType(self, value):
        # Validate type fb:FleetPriorityType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on FleetPriorityType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on FleetPriorityType' % {"value": value, "lineno": lineno} )
                result = False
    def validate_SlotAssignmentType(self, value):
        # Validate type fb:SlotAssignmentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_StandardInstrumentRouteDesignatorType(self, value):
        # Validate type fb:StandardInstrumentRouteDesignatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.departureAerodrome is not None or
            self.departureFix is not None or
            self.departureFixTime is not None or
            self.departureTimes is not None or
            self.offBlockReadyTime is not None or
            self.runwayPositionAndTime is not None or
            self.standPositionAndTime is not None or
            self.takeoffAlternateAerodrome or
            self.takeoffWeight is not None or
            super(FlightDepartureType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='FlightDepartureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlightDepartureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlightDepartureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlightDepartureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='FlightDepartureType'):
        super(FlightDepartureType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlightDepartureType')
        if self.departureFleetPrioritization is not None and 'departureFleetPrioritization' not in already_processed:
            already_processed.add('departureFleetPrioritization')
            outfile.write(' departureFleetPrioritization="%s"' % self.gds_format_integer(self.departureFleetPrioritization, input_name='departureFleetPrioritization'))
        if self.departureSlot is not None and 'departureSlot' not in already_processed:
            already_processed.add('departureSlot')
            outfile.write(' departureSlot=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.departureSlot), input_name='departureSlot')), ))
        if self.earliestOffBlockTime is not None and 'earliestOffBlockTime' not in already_processed:
            already_processed.add('earliestOffBlockTime')
            outfile.write(' earliestOffBlockTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.earliestOffBlockTime), input_name='earliestOffBlockTime')), ))
        if self.standardInstrumentDeparture is not None and 'standardInstrumentDeparture' not in already_processed:
            already_processed.add('standardInstrumentDeparture')
            outfile.write(' standardInstrumentDeparture=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.standardInstrumentDeparture), input_name='standardInstrumentDeparture')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='FlightDepartureType', fromsubclass_=False, pretty_print=True):
        super(FlightDepartureType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.departureAerodrome is not None:
            self.departureAerodrome.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.departureFix is not None:
            self.departureFix.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.departureFixTime is not None:
            namespaceprefix_ = self.departureFixTime_nsprefix_ + ':' if (UseCapturedNS_ and self.departureFixTime_nsprefix_) else ''
            self.departureFixTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='departureFixTime', pretty_print=pretty_print)
        if self.departureTimes is not None:
            namespaceprefix_ = self.departureTimes_nsprefix_ + ':' if (UseCapturedNS_ and self.departureTimes_nsprefix_) else ''
            self.departureTimes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='departureTimes', pretty_print=pretty_print)
        if self.offBlockReadyTime is not None:
            namespaceprefix_ = self.offBlockReadyTime_nsprefix_ + ':' if (UseCapturedNS_ and self.offBlockReadyTime_nsprefix_) else ''
            self.offBlockReadyTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offBlockReadyTime', pretty_print=pretty_print)
        if self.runwayPositionAndTime is not None:
            namespaceprefix_ = self.runwayPositionAndTime_nsprefix_ + ':' if (UseCapturedNS_ and self.runwayPositionAndTime_nsprefix_) else ''
            self.runwayPositionAndTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='runwayPositionAndTime', pretty_print=pretty_print)
        if self.standPositionAndTime is not None:
            namespaceprefix_ = self.standPositionAndTime_nsprefix_ + ':' if (UseCapturedNS_ and self.standPositionAndTime_nsprefix_) else ''
            self.standPositionAndTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='standPositionAndTime', pretty_print=pretty_print)
        for takeoffAlternateAerodrome_ in self.takeoffAlternateAerodrome:
            takeoffAlternateAerodrome_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.takeoffWeight is not None:
            namespaceprefix_ = self.takeoffWeight_nsprefix_ + ':' if (UseCapturedNS_ and self.takeoffWeight_nsprefix_) else ''
            self.takeoffWeight.export(outfile, level, namespaceprefix_, namespacedef_='', name_='takeoffWeight', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('departureFleetPrioritization', node)
        if value is not None and 'departureFleetPrioritization' not in already_processed:
            already_processed.add('departureFleetPrioritization')
            self.departureFleetPrioritization = self.gds_parse_integer(value, node, 'departureFleetPrioritization')
            self.validate_FleetPriorityType(self.departureFleetPrioritization)    # validate type FleetPriorityType
        value = find_attr_value_('departureSlot', node)
        if value is not None and 'departureSlot' not in already_processed:
            already_processed.add('departureSlot')
            self.departureSlot = value
            self.validate_SlotAssignmentType(self.departureSlot)    # validate type SlotAssignmentType
        value = find_attr_value_('earliestOffBlockTime', node)
        if value is not None and 'earliestOffBlockTime' not in already_processed:
            already_processed.add('earliestOffBlockTime')
            try:
                self.earliestOffBlockTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (earliestOffBlockTime): %s' % exp)
            self.validate_TimeType(self.earliestOffBlockTime)    # validate type TimeType
        value = find_attr_value_('standardInstrumentDeparture', node)
        if value is not None and 'standardInstrumentDeparture' not in already_processed:
            already_processed.add('standardInstrumentDeparture')
            self.standardInstrumentDeparture = value
            self.validate_StandardInstrumentRouteDesignatorType(self.standardInstrumentDeparture)    # validate type StandardInstrumentRouteDesignatorType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(FlightDepartureType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'departureAerodrome':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <departureAerodrome> element')
            self.departureAerodrome = obj_
            obj_.original_tagname_ = 'departureAerodrome'
        elif nodeName_ == 'departureFix':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <departureFix> element')
            self.departureFix = obj_
            obj_.original_tagname_ = 'departureFix'
        elif nodeName_ == 'departureFixTime':
            class_obj_ = self.get_class_obj_(child_, MultiTimeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departureFixTime = obj_
            obj_.original_tagname_ = 'departureFixTime'
        elif nodeName_ == 'departureTimes':
            obj_ = DepartureActivityTimesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departureTimes = obj_
            obj_.original_tagname_ = 'departureTimes'
        elif nodeName_ == 'offBlockReadyTime':
            class_obj_ = self.get_class_obj_(child_, TargetMultiTimeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offBlockReadyTime = obj_
            obj_.original_tagname_ = 'offBlockReadyTime'
        elif nodeName_ == 'runwayPositionAndTime':
            obj_ = RunwayPositionAndTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.runwayPositionAndTime = obj_
            obj_.original_tagname_ = 'runwayPositionAndTime'
        elif nodeName_ == 'standPositionAndTime':
            obj_ = StandPositionAndTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.standPositionAndTime = obj_
            obj_.original_tagname_ = 'standPositionAndTime'
        elif nodeName_ == 'takeoffAlternateAerodrome':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <takeoffAlternateAerodrome> element')
            self.takeoffAlternateAerodrome.append(obj_)
            obj_.original_tagname_ = 'takeoffAlternateAerodrome'
        elif nodeName_ == 'takeoffWeight':
            obj_ = WeightType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.takeoffWeight = obj_
            obj_.original_tagname_ = 'takeoffWeight'
        super(FlightDepartureType, self).buildChildren(child_, node, nodeName_, True)
# end class FlightDepartureType


class FlightEmergencyType(FeatureType):
    """Groups emergency information (description, phase, position, etc) for the
    flight.
    .Action Taken By Reporting Unit: A description of the actions taken by the
    reporting
    Air Traffic Service (ATS) unit, in the event of search and rescue.
    .Emergency Description: A short, plain-language description of the nature
    of the
    emergency.
    .Other Search and Rescue Information: Other pertinent information not
    captured elsewhere
    needed to notify appropriate organizations regarding aircraft in need of
    search and
    rescue.
    .Emergency Phase: Stage of emergency the flight is currently under or an
    indication
    the emergency has been cancelled, as designated by an ATS unit."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FeatureType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, actionTaken=None, emergencyDescription=None, otherInformation=None, phase=None, contact=None, originator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FlightEmergencyType, self).__init__(centre, source, system, timestamp,  **kwargs_)
        self.actionTaken = _cast(None, actionTaken)
        self.actionTaken_nsprefix_ = None
        self.emergencyDescription = _cast(None, emergencyDescription)
        self.emergencyDescription_nsprefix_ = None
        self.otherInformation = _cast(None, otherInformation)
        self.otherInformation_nsprefix_ = None
        self.phase = _cast(None, phase)
        self.phase_nsprefix_ = None
        self.contact = contact
        self.contact_nsprefix_ = None
        self.originator = originator
        self.originator_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlightEmergencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlightEmergencyType.subclass:
            return FlightEmergencyType.subclass(*args_, **kwargs_)
        else:
            return FlightEmergencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_contact(self):
        return self.contact
    def set_contact(self, contact):
        self.contact = contact
    def get_originator(self):
        return self.originator
    def set_originator(self, originator):
        self.originator = originator
    def get_actionTaken(self):
        return self.actionTaken
    def set_actionTaken(self, actionTaken):
        self.actionTaken = actionTaken
    def get_emergencyDescription(self):
        return self.emergencyDescription
    def set_emergencyDescription(self, emergencyDescription):
        self.emergencyDescription = emergencyDescription
    def get_otherInformation(self):
        return self.otherInformation
    def set_otherInformation(self, otherInformation):
        self.otherInformation = otherInformation
    def get_phase(self):
        return self.phase
    def set_phase(self, phase):
        self.phase = phase
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_EmergencyPhaseType(self, value):
        # Validate type fx:EmergencyPhaseType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INCERFA', 'ALERFA', 'DETRESFA', 'CANCELLED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EmergencyPhaseType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.contact is not None or
            self.originator is not None or
            super(FlightEmergencyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='FlightEmergencyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlightEmergencyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlightEmergencyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlightEmergencyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='FlightEmergencyType'):
        super(FlightEmergencyType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlightEmergencyType')
        if self.actionTaken is not None and 'actionTaken' not in already_processed:
            already_processed.add('actionTaken')
            outfile.write(' actionTaken=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actionTaken), input_name='actionTaken')), ))
        if self.emergencyDescription is not None and 'emergencyDescription' not in already_processed:
            already_processed.add('emergencyDescription')
            outfile.write(' emergencyDescription=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.emergencyDescription), input_name='emergencyDescription')), ))
        if self.otherInformation is not None and 'otherInformation' not in already_processed:
            already_processed.add('otherInformation')
            outfile.write(' otherInformation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.otherInformation), input_name='otherInformation')), ))
        if self.phase is not None and 'phase' not in already_processed:
            already_processed.add('phase')
            outfile.write(' phase=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.phase), input_name='phase')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='FlightEmergencyType', fromsubclass_=False, pretty_print=True):
        super(FlightEmergencyType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.contact is not None:
            namespaceprefix_ = self.contact_nsprefix_ + ':' if (UseCapturedNS_ and self.contact_nsprefix_) else ''
            self.contact.export(outfile, level, namespaceprefix_, namespacedef_='', name_='contact', pretty_print=pretty_print)
        if self.originator is not None:
            namespaceprefix_ = self.originator_nsprefix_ + ':' if (UseCapturedNS_ and self.originator_nsprefix_) else ''
            self.originator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='originator', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('actionTaken', node)
        if value is not None and 'actionTaken' not in already_processed:
            already_processed.add('actionTaken')
            self.actionTaken = value
            self.validate_FreeTextType(self.actionTaken)    # validate type FreeTextType
        value = find_attr_value_('emergencyDescription', node)
        if value is not None and 'emergencyDescription' not in already_processed:
            already_processed.add('emergencyDescription')
            self.emergencyDescription = value
            self.validate_FreeTextType(self.emergencyDescription)    # validate type FreeTextType
        value = find_attr_value_('otherInformation', node)
        if value is not None and 'otherInformation' not in already_processed:
            already_processed.add('otherInformation')
            self.otherInformation = value
            self.validate_FreeTextType(self.otherInformation)    # validate type FreeTextType
        value = find_attr_value_('phase', node)
        if value is not None and 'phase' not in already_processed:
            already_processed.add('phase')
            self.phase = value
            self.validate_EmergencyPhaseType(self.phase)    # validate type EmergencyPhaseType
        super(FlightEmergencyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contact':
            obj_ = LastContactType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contact = obj_
            obj_.original_tagname_ = 'contact'
        elif nodeName_ == 'originator':
            obj_ = IdentifiedUnitReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.originator = obj_
            obj_.original_tagname_ = 'originator'
        super(FlightEmergencyType, self).buildChildren(child_, node, nodeName_, True)
# end class FlightEmergencyType


class LastContactType(FeatureType):
    """.Last Contact Unit: The last ATS unit which had two-way contact with the
    aircraft.
    .Last Contact Time: The time of the last two-way contact between the
    aircraft and
    an ATS unit. The time is given in UTC.
    .Last Contact Unit: The last ATS unit which had two-way contact with the
    aircraft."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FeatureType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, lastContactTime=None, lastContactUnit=None, contactFrequency=None, position=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LastContactType, self).__init__(centre, source, system, timestamp,  **kwargs_)
        self.lastContactTime = _cast(None, lastContactTime)
        self.lastContactTime_nsprefix_ = None
        self.lastContactUnit = _cast(None, lastContactUnit)
        self.lastContactUnit_nsprefix_ = None
        self.contactFrequency = contactFrequency
        self.contactFrequency_nsprefix_ = None
        self.position = position
        self.position_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LastContactType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LastContactType.subclass:
            return LastContactType.subclass(*args_, **kwargs_)
        else:
            return LastContactType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_contactFrequency(self):
        return self.contactFrequency
    def set_contactFrequency(self, contactFrequency):
        self.contactFrequency = contactFrequency
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def get_lastContactTime(self):
        return self.lastContactTime
    def set_lastContactTime(self, lastContactTime):
        self.lastContactTime = lastContactTime
    def get_lastContactUnit(self):
        return self.lastContactUnit
    def set_lastContactUnit(self, lastContactUnit):
        self.lastContactUnit = lastContactUnit
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_AtcUnitNameType(self, value):
        # Validate type ff:AtcUnitNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_AtcUnitNameType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AtcUnitNameType_patterns_, ))
    validate_AtcUnitNameType_patterns_ = [['^(([A-Z]{4})|([A-Za-z0-9]{1,}))$']]
    def hasContent_(self):
        if (
            self.contactFrequency is not None or
            self.position is not None or
            super(LastContactType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='LastContactType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LastContactType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LastContactType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LastContactType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='LastContactType'):
        super(LastContactType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LastContactType')
        if self.lastContactTime is not None and 'lastContactTime' not in already_processed:
            already_processed.add('lastContactTime')
            outfile.write(' lastContactTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lastContactTime), input_name='lastContactTime')), ))
        if self.lastContactUnit is not None and 'lastContactUnit' not in already_processed:
            already_processed.add('lastContactUnit')
            outfile.write(' lastContactUnit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lastContactUnit), input_name='lastContactUnit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='LastContactType', fromsubclass_=False, pretty_print=True):
        super(LastContactType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.contactFrequency is not None:
            namespaceprefix_ = self.contactFrequency_nsprefix_ + ':' if (UseCapturedNS_ and self.contactFrequency_nsprefix_) else ''
            self.contactFrequency.export(outfile, level, namespaceprefix_, namespacedef_='', name_='contactFrequency', pretty_print=pretty_print)
        if self.position is not None:
            namespaceprefix_ = self.position_nsprefix_ + ':' if (UseCapturedNS_ and self.position_nsprefix_) else ''
            self.position.export(outfile, level, namespaceprefix_, namespacedef_='', name_='position', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lastContactTime', node)
        if value is not None and 'lastContactTime' not in already_processed:
            already_processed.add('lastContactTime')
            try:
                self.lastContactTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (lastContactTime): %s' % exp)
            self.validate_TimeType(self.lastContactTime)    # validate type TimeType
        value = find_attr_value_('lastContactUnit', node)
        if value is not None and 'lastContactUnit' not in already_processed:
            already_processed.add('lastContactUnit')
            self.lastContactUnit = value
            self.validate_AtcUnitNameType(self.lastContactUnit)    # validate type AtcUnitNameType
        super(LastContactType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contactFrequency':
            obj_ = RadioFrequencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contactFrequency = obj_
            obj_.original_tagname_ = 'contactFrequency'
        elif nodeName_ == 'position':
            obj_ = LastPositionReportType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
        super(LastContactType, self).buildChildren(child_, node, nodeName_, True)
# end class LastContactType


class LastPositionReportType(GeneratedsSuper):
    """.Last Known Position Report: The position of the aircraft last known to
    ATS and a
    corresponding timestamp.
    .Last Known Position Report - Determination Method: A plain-language
    description
    of the method used to determine the last known position of an aircraft.
    Timestamp corresponding to the last known position."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, determinationMethod=None, timeAtPosition=None, position=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.determinationMethod = _cast(None, determinationMethod)
        self.determinationMethod_nsprefix_ = None
        self.timeAtPosition = _cast(None, timeAtPosition)
        self.timeAtPosition_nsprefix_ = None
        self.position = position
        self.position_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LastPositionReportType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LastPositionReportType.subclass:
            return LastPositionReportType.subclass(*args_, **kwargs_)
        else:
            return LastPositionReportType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def set_position_with_type(self, value):
        self.position = value
        value.original_tagname_ = 'position'
        value.extensiontype_ = value.__class__.__name__
    def get_determinationMethod(self):
        return self.determinationMethod
    def set_determinationMethod(self, determinationMethod):
        self.determinationMethod = determinationMethod
    def get_timeAtPosition(self):
        return self.timeAtPosition
    def set_timeAtPosition(self, timeAtPosition):
        self.timeAtPosition = timeAtPosition
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.position is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='LastPositionReportType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LastPositionReportType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LastPositionReportType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LastPositionReportType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='LastPositionReportType'):
        if self.determinationMethod is not None and 'determinationMethod' not in already_processed:
            already_processed.add('determinationMethod')
            outfile.write(' determinationMethod=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.determinationMethod), input_name='determinationMethod')), ))
        if self.timeAtPosition is not None and 'timeAtPosition' not in already_processed:
            already_processed.add('timeAtPosition')
            outfile.write(' timeAtPosition=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.timeAtPosition), input_name='timeAtPosition')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='LastPositionReportType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.position is not None:
            self.position.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('determinationMethod', node)
        if value is not None and 'determinationMethod' not in already_processed:
            already_processed.add('determinationMethod')
            self.determinationMethod = value
            self.validate_FreeTextType(self.determinationMethod)    # validate type FreeTextType
        value = find_attr_value_('timeAtPosition', node)
        if value is not None and 'timeAtPosition' not in already_processed:
            already_processed.add('timeAtPosition')
            try:
                self.timeAtPosition = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timeAtPosition): %s' % exp)
            self.validate_TimeType(self.timeAtPosition)    # validate type TimeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'position':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <position> element')
            self.position = obj_
            obj_.original_tagname_ = 'position'
# end class LastPositionReportType


class RadioCommunicationFailureType(FeatureType):
    """Groups information regarding loss of radio communication capabilities.
    .Radio Failure Remarks: Pertinent information needed to notify appropriate
    organizations
    regarding loss of radio communication capabilities.
    .Remaining Communication Capabilities: The remaining communication
    capability of
    the aircraft following radio failure."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FeatureType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, radioFailureRemarks=None, remainingComCapability=None, contact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RadioCommunicationFailureType, self).__init__(centre, source, system, timestamp,  **kwargs_)
        self.radioFailureRemarks = _cast(None, radioFailureRemarks)
        self.radioFailureRemarks_nsprefix_ = None
        self.remainingComCapability = _cast(None, remainingComCapability)
        self.remainingComCapability_nsprefix_ = None
        self.contact = contact
        self.contact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadioCommunicationFailureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadioCommunicationFailureType.subclass:
            return RadioCommunicationFailureType.subclass(*args_, **kwargs_)
        else:
            return RadioCommunicationFailureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_contact(self):
        return self.contact
    def set_contact(self, contact):
        self.contact = contact
    def get_radioFailureRemarks(self):
        return self.radioFailureRemarks
    def set_radioFailureRemarks(self, radioFailureRemarks):
        self.radioFailureRemarks = radioFailureRemarks
    def get_remainingComCapability(self):
        return self.remainingComCapability
    def set_remainingComCapability(self, remainingComCapability):
        self.remainingComCapability = remainingComCapability
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.contact is not None or
            super(RadioCommunicationFailureType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='RadioCommunicationFailureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RadioCommunicationFailureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RadioCommunicationFailureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RadioCommunicationFailureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='RadioCommunicationFailureType'):
        super(RadioCommunicationFailureType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RadioCommunicationFailureType')
        if self.radioFailureRemarks is not None and 'radioFailureRemarks' not in already_processed:
            already_processed.add('radioFailureRemarks')
            outfile.write(' radioFailureRemarks=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.radioFailureRemarks), input_name='radioFailureRemarks')), ))
        if self.remainingComCapability is not None and 'remainingComCapability' not in already_processed:
            already_processed.add('remainingComCapability')
            outfile.write(' remainingComCapability=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.remainingComCapability), input_name='remainingComCapability')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='RadioCommunicationFailureType', fromsubclass_=False, pretty_print=True):
        super(RadioCommunicationFailureType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.contact is not None:
            namespaceprefix_ = self.contact_nsprefix_ + ':' if (UseCapturedNS_ and self.contact_nsprefix_) else ''
            self.contact.export(outfile, level, namespaceprefix_, namespacedef_='', name_='contact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('radioFailureRemarks', node)
        if value is not None and 'radioFailureRemarks' not in already_processed:
            already_processed.add('radioFailureRemarks')
            self.radioFailureRemarks = value
            self.validate_FreeTextType(self.radioFailureRemarks)    # validate type FreeTextType
        value = find_attr_value_('remainingComCapability', node)
        if value is not None and 'remainingComCapability' not in already_processed:
            already_processed.add('remainingComCapability')
            self.remainingComCapability = value
            self.validate_FreeTextType(self.remainingComCapability)    # validate type FreeTextType
        super(RadioCommunicationFailureType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contact':
            obj_ = LastContactType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contact = obj_
            obj_.original_tagname_ = 'contact'
        super(RadioCommunicationFailureType, self).buildChildren(child_, node, nodeName_, True)
# end class RadioCommunicationFailureType


class AltitudeInTransitionType(AltitudeType):
    """.Boundary Crossing Level - Transition/Coordinated: An altitude (flight
    level) at
    or above/below which an aircraft will cross the associated boundary point.
    .Boundary Crossing Level - Transition - Proposed: The proposed altitude
    (flight level)
    at or above/below which an aircraft will cross the associated boundary
    point, as
    requested by the accepting controller from the transferring controller.
    .Boundary Crossing Level - Transition: An altitude (flight level) at or
    above/below
    which (specified in Boundary Crossing Condition) an aircraft will cross the
    associated
    boundary point.
    .Boundary Crossing Level - Transition/Coordinated: An altitude (flight
    level) at
    or above/below which an aircraft will cross the associated boundary point.
    .Boundary Crossing Level - Transition - Proposed: The proposed altitude
    (flight level)
    at or above/below which an aircraft will cross the associated boundary
    point, as
    requested by the accepting controller from the transferring controller."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AltitudeType
    def __init__(self, ref=None, uom=None, crossingCondition=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AltitudeInTransitionType, self).__init__(ref, uom, valueOf_,  **kwargs_)
        self.crossingCondition = _cast(None, crossingCondition)
        self.crossingCondition_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AltitudeInTransitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AltitudeInTransitionType.subclass:
            return AltitudeInTransitionType.subclass(*args_, **kwargs_)
        else:
            return AltitudeInTransitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_crossingCondition(self):
        return self.crossingCondition
    def set_crossingCondition(self, crossingCondition):
        self.crossingCondition = crossingCondition
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_BoundaryCrossingConditionType(self, value):
        # Validate type fx:BoundaryCrossingConditionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AT_OR_ABOVE', 'AT_OR_BELOW']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BoundaryCrossingConditionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AltitudeInTransitionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='AltitudeInTransitionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AltitudeInTransitionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AltitudeInTransitionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AltitudeInTransitionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='AltitudeInTransitionType'):
        super(AltitudeInTransitionType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AltitudeInTransitionType')
        if self.crossingCondition is not None and 'crossingCondition' not in already_processed:
            already_processed.add('crossingCondition')
            outfile.write(' crossingCondition=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.crossingCondition), input_name='crossingCondition')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='AltitudeInTransitionType', fromsubclass_=False, pretty_print=True):
        super(AltitudeInTransitionType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('crossingCondition', node)
        if value is not None and 'crossingCondition' not in already_processed:
            already_processed.add('crossingCondition')
            self.crossingCondition = value
            self.validate_BoundaryCrossingConditionType(self.crossingCondition)    # validate type BoundaryCrossingConditionType
        super(AltitudeInTransitionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AltitudeInTransitionType


class BoundaryCrossingType(GeneratedsSuper):
    """Abstract Boundary Crossing contains shared data between the
    BoundaryCrossingProposed
    and BoundaryCrossingCoordinated classes.
    .Boundary Crossing Time - Proposed: The estimated time when the flight will
    cross
    the Boundary Crossing Point - Proposed, as requested by the accepting
    controller
    from the transferring controller.
    .Boundary Crossing Time/Coordinated: The estimated time at which a flight
    will cross
    the associated boundary crossing point."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, crossingTime=None, altitude=None, altitudeInTransition=None, crossingPoint=None, crossingSpeed=None, offtrack=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.crossingTime = _cast(None, crossingTime)
        self.crossingTime_nsprefix_ = None
        self.altitude = altitude
        self.altitude_nsprefix_ = None
        self.altitudeInTransition = altitudeInTransition
        self.altitudeInTransition_nsprefix_ = None
        self.crossingPoint = crossingPoint
        self.crossingPoint_nsprefix_ = None
        self.crossingSpeed = crossingSpeed
        self.crossingSpeed_nsprefix_ = None
        self.offtrack = offtrack
        self.offtrack_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoundaryCrossingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoundaryCrossingType.subclass:
            return BoundaryCrossingType.subclass(*args_, **kwargs_)
        else:
            return BoundaryCrossingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_altitude(self):
        return self.altitude
    def set_altitude(self, altitude):
        self.altitude = altitude
    def get_altitudeInTransition(self):
        return self.altitudeInTransition
    def set_altitudeInTransition(self, altitudeInTransition):
        self.altitudeInTransition = altitudeInTransition
    def get_crossingPoint(self):
        return self.crossingPoint
    def set_crossingPoint(self, crossingPoint):
        self.crossingPoint = crossingPoint
    def set_crossingPoint_with_type(self, value):
        self.crossingPoint = value
        value.original_tagname_ = 'crossingPoint'
        value.extensiontype_ = value.__class__.__name__
    def get_crossingSpeed(self):
        return self.crossingSpeed
    def set_crossingSpeed(self, crossingSpeed):
        self.crossingSpeed = crossingSpeed
    def get_offtrack(self):
        return self.offtrack
    def set_offtrack(self, offtrack):
        self.offtrack = offtrack
    def get_crossingTime(self):
        return self.crossingTime
    def set_crossingTime(self, crossingTime):
        self.crossingTime = crossingTime
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.altitude is not None or
            self.altitudeInTransition is not None or
            self.crossingPoint is not None or
            self.crossingSpeed is not None or
            self.offtrack is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='BoundaryCrossingType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BoundaryCrossingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BoundaryCrossingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BoundaryCrossingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='BoundaryCrossingType'):
        if self.crossingTime is not None and 'crossingTime' not in already_processed:
            already_processed.add('crossingTime')
            outfile.write(' crossingTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.crossingTime), input_name='crossingTime')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='BoundaryCrossingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.altitude is not None:
            namespaceprefix_ = self.altitude_nsprefix_ + ':' if (UseCapturedNS_ and self.altitude_nsprefix_) else ''
            self.altitude.export(outfile, level, namespaceprefix_, namespacedef_='', name_='altitude', pretty_print=pretty_print)
        if self.altitudeInTransition is not None:
            namespaceprefix_ = self.altitudeInTransition_nsprefix_ + ':' if (UseCapturedNS_ and self.altitudeInTransition_nsprefix_) else ''
            self.altitudeInTransition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='altitudeInTransition', pretty_print=pretty_print)
        if self.crossingPoint is not None:
            self.crossingPoint.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.crossingSpeed is not None:
            namespaceprefix_ = self.crossingSpeed_nsprefix_ + ':' if (UseCapturedNS_ and self.crossingSpeed_nsprefix_) else ''
            self.crossingSpeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='crossingSpeed', pretty_print=pretty_print)
        if self.offtrack is not None:
            namespaceprefix_ = self.offtrack_nsprefix_ + ':' if (UseCapturedNS_ and self.offtrack_nsprefix_) else ''
            self.offtrack.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offtrack', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('crossingTime', node)
        if value is not None and 'crossingTime' not in already_processed:
            already_processed.add('crossingTime')
            try:
                self.crossingTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (crossingTime): %s' % exp)
            self.validate_TimeType(self.crossingTime)    # validate type TimeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'altitude':
            obj_ = AltitudeChoiceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.altitude = obj_
            obj_.original_tagname_ = 'altitude'
        elif nodeName_ == 'altitudeInTransition':
            obj_ = AltitudeInTransitionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.altitudeInTransition = obj_
            obj_.original_tagname_ = 'altitudeInTransition'
        elif nodeName_ == 'crossingPoint':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <crossingPoint> element')
            self.crossingPoint = obj_
            obj_.original_tagname_ = 'crossingPoint'
        elif nodeName_ == 'crossingSpeed':
            obj_ = AirspeedChoiceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.crossingSpeed = obj_
            obj_.original_tagname_ = 'crossingSpeed'
        elif nodeName_ == 'offtrack':
            obj_ = LateralOfftrackType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offtrack = obj_
            obj_.original_tagname_ = 'offtrack'
# end class BoundaryCrossingType


class HandoffType(GeneratedsSuper):
    """An action taken to transfer the radar identification of an aircraft from
    one controller
    to another controller if the aircraft will enter the receiving controller's
    airspace
    and radio communications with the aircraft will be transferred."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, coordinationStatus=None, receivingUnit=None, transferringUnit=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.coordinationStatus = coordinationStatus
        self.coordinationStatus_nsprefix_ = None
        self.receivingUnit = receivingUnit
        self.receivingUnit_nsprefix_ = None
        self.transferringUnit = transferringUnit
        self.transferringUnit_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HandoffType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HandoffType.subclass:
            return HandoffType.subclass(*args_, **kwargs_)
        else:
            return HandoffType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_coordinationStatus(self):
        return self.coordinationStatus
    def set_coordinationStatus(self, coordinationStatus):
        self.coordinationStatus = coordinationStatus
    def get_receivingUnit(self):
        return self.receivingUnit
    def set_receivingUnit(self, receivingUnit):
        self.receivingUnit = receivingUnit
    def set_receivingUnit_with_type(self, value):
        self.receivingUnit = value
        value.original_tagname_ = 'receivingUnit'
        value.extensiontype_ = value.__class__.__name__
    def get_transferringUnit(self):
        return self.transferringUnit
    def set_transferringUnit(self, transferringUnit):
        self.transferringUnit = transferringUnit
    def set_transferringUnit_with_type(self, value):
        self.transferringUnit = value
        value.original_tagname_ = 'transferringUnit'
        value.extensiontype_ = value.__class__.__name__
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.coordinationStatus is not None or
            self.receivingUnit is not None or
            self.transferringUnit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='HandoffType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HandoffType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HandoffType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HandoffType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='HandoffType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='HandoffType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.coordinationStatus is not None:
            namespaceprefix_ = self.coordinationStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.coordinationStatus_nsprefix_) else ''
            self.coordinationStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coordinationStatus', pretty_print=pretty_print)
        if self.receivingUnit is not None:
            self.receivingUnit.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.transferringUnit is not None:
            self.transferringUnit.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'coordinationStatus':
            obj_ = CoordinationStatusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coordinationStatus = obj_
            obj_.original_tagname_ = 'coordinationStatus'
        elif nodeName_ == 'receivingUnit':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <receivingUnit> element')
            self.receivingUnit = obj_
            obj_.original_tagname_ = 'receivingUnit'
        elif nodeName_ == 'transferringUnit':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <transferringUnit> element')
            self.transferringUnit = obj_
            obj_.original_tagname_ = 'transferringUnit'
# end class HandoffType


class UnitBoundaryType(AtcUnitReferenceType):
    """Represents an Unit boundary that will be traversed En Route.
    .Unit Boundary: Identifies the unit whose boundary the flight is expected
    to traverse,
    based on the planned route of flight and altitude.
    .Unit Boundary Indicator: An indicator of the status of the boundary
    crossing in
    the Unit Boundary List as a past crossing, the current or next crossing, or
    a future
    crossing."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AtcUnitReferenceType
    def __init__(self, delegated=None, sectorIdentifier=None, unitBoundaryIndicator=None, boundaryCrossingCoordinated=None, boundaryCrossingProposed=None, downstreamUnit=None, handoff=None, upstreamUnit=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(UnitBoundaryType, self).__init__(delegated, sectorIdentifier, extensiontype_,  **kwargs_)
        self.unitBoundaryIndicator = _cast(None, unitBoundaryIndicator)
        self.unitBoundaryIndicator_nsprefix_ = None
        self.boundaryCrossingCoordinated = boundaryCrossingCoordinated
        self.boundaryCrossingCoordinated_nsprefix_ = None
        self.boundaryCrossingProposed = boundaryCrossingProposed
        self.boundaryCrossingProposed_nsprefix_ = None
        self.downstreamUnit = downstreamUnit
        self.downstreamUnit_nsprefix_ = None
        self.handoff = handoff
        self.handoff_nsprefix_ = None
        self.upstreamUnit = upstreamUnit
        self.upstreamUnit_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitBoundaryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitBoundaryType.subclass:
            return UnitBoundaryType.subclass(*args_, **kwargs_)
        else:
            return UnitBoundaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_boundaryCrossingCoordinated(self):
        return self.boundaryCrossingCoordinated
    def set_boundaryCrossingCoordinated(self, boundaryCrossingCoordinated):
        self.boundaryCrossingCoordinated = boundaryCrossingCoordinated
    def get_boundaryCrossingProposed(self):
        return self.boundaryCrossingProposed
    def set_boundaryCrossingProposed(self, boundaryCrossingProposed):
        self.boundaryCrossingProposed = boundaryCrossingProposed
    def get_downstreamUnit(self):
        return self.downstreamUnit
    def set_downstreamUnit(self, downstreamUnit):
        self.downstreamUnit = downstreamUnit
    def set_downstreamUnit_with_type(self, value):
        self.downstreamUnit = value
        value.original_tagname_ = 'downstreamUnit'
        value.extensiontype_ = value.__class__.__name__
    def get_handoff(self):
        return self.handoff
    def set_handoff(self, handoff):
        self.handoff = handoff
    def get_upstreamUnit(self):
        return self.upstreamUnit
    def set_upstreamUnit(self, upstreamUnit):
        self.upstreamUnit = upstreamUnit
    def set_upstreamUnit_with_type(self, value):
        self.upstreamUnit = value
        value.original_tagname_ = 'upstreamUnit'
        value.extensiontype_ = value.__class__.__name__
    def get_unitBoundaryIndicator(self):
        return self.unitBoundaryIndicator
    def set_unitBoundaryIndicator(self, unitBoundaryIndicator):
        self.unitBoundaryIndicator = unitBoundaryIndicator
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_UnitBoundaryIndicatorType(self, value):
        # Validate type fx:UnitBoundaryIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PAST', 'CURRENT', 'FUTURE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on UnitBoundaryIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.boundaryCrossingCoordinated is not None or
            self.boundaryCrossingProposed is not None or
            self.downstreamUnit is not None or
            self.handoff is not None or
            self.upstreamUnit is not None or
            super(UnitBoundaryType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='UnitBoundaryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnitBoundaryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnitBoundaryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UnitBoundaryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='UnitBoundaryType'):
        super(UnitBoundaryType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnitBoundaryType')
        if self.unitBoundaryIndicator is not None and 'unitBoundaryIndicator' not in already_processed:
            already_processed.add('unitBoundaryIndicator')
            outfile.write(' unitBoundaryIndicator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unitBoundaryIndicator), input_name='unitBoundaryIndicator')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='UnitBoundaryType', fromsubclass_=False, pretty_print=True):
        super(UnitBoundaryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.boundaryCrossingCoordinated is not None:
            namespaceprefix_ = self.boundaryCrossingCoordinated_nsprefix_ + ':' if (UseCapturedNS_ and self.boundaryCrossingCoordinated_nsprefix_) else ''
            self.boundaryCrossingCoordinated.export(outfile, level, namespaceprefix_, namespacedef_='', name_='boundaryCrossingCoordinated', pretty_print=pretty_print)
        if self.boundaryCrossingProposed is not None:
            namespaceprefix_ = self.boundaryCrossingProposed_nsprefix_ + ':' if (UseCapturedNS_ and self.boundaryCrossingProposed_nsprefix_) else ''
            self.boundaryCrossingProposed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='boundaryCrossingProposed', pretty_print=pretty_print)
        if self.downstreamUnit is not None:
            self.downstreamUnit.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.handoff is not None:
            namespaceprefix_ = self.handoff_nsprefix_ + ':' if (UseCapturedNS_ and self.handoff_nsprefix_) else ''
            self.handoff.export(outfile, level, namespaceprefix_, namespacedef_='', name_='handoff', pretty_print=pretty_print)
        if self.upstreamUnit is not None:
            self.upstreamUnit.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitBoundaryIndicator', node)
        if value is not None and 'unitBoundaryIndicator' not in already_processed:
            already_processed.add('unitBoundaryIndicator')
            self.unitBoundaryIndicator = value
            self.validate_UnitBoundaryIndicatorType(self.unitBoundaryIndicator)    # validate type UnitBoundaryIndicatorType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(UnitBoundaryType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'boundaryCrossingCoordinated':
            obj_ = BoundaryCrossingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.boundaryCrossingCoordinated = obj_
            obj_.original_tagname_ = 'boundaryCrossingCoordinated'
        elif nodeName_ == 'boundaryCrossingProposed':
            obj_ = BoundaryCrossingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.boundaryCrossingProposed = obj_
            obj_.original_tagname_ = 'boundaryCrossingProposed'
        elif nodeName_ == 'downstreamUnit':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <downstreamUnit> element')
            self.downstreamUnit = obj_
            obj_.original_tagname_ = 'downstreamUnit'
        elif nodeName_ == 'handoff':
            class_obj_ = self.get_class_obj_(child_, HandoffType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.handoff = obj_
            obj_.original_tagname_ = 'handoff'
        elif nodeName_ == 'upstreamUnit':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <upstreamUnit> element')
            self.upstreamUnit = obj_
            obj_.original_tagname_ = 'upstreamUnit'
        super(UnitBoundaryType, self).buildChildren(child_, node, nodeName_, True)
# end class UnitBoundaryType


class CoordinationStatusType(GeneratedsSuper):
    """.Coordination Status: The status of Coordination and Transfer of Control
    between
    the currently Controlling Air Traffic Service Unit (ATSU) to the downstream
    to be
    Controlling ATSU.
    .Abrogation Reason: If the Coordination Status is abrogated, indicating
    coordination
    is abolished by authoritative action, the reason the coordination was
    terminated.
    .Coordination Status: The status of Coordination and Transfer of Control
    between
    the currently Controlling Air Traffic Service Unit (ATSU) to the downstream
    to be
    Controlling ATSU.
    .Reason for Non-Standard Coordination: In case of non-standard
    coordination, the
    reason for non-standard coordination is indicated.
    .Release Conditions: When the flight is released from the agreed transfer
    conditions,
    contains the Release conditions specified by the transferring ATSUs. The
    Release
    conditions indicate the type of manoeuvres the flight is released to
    perform."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, abrogationReason=None, coordinationStatus=None, nonStandardCommunicationReason=None, releaseConditions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.abrogationReason = _cast(None, abrogationReason)
        self.abrogationReason_nsprefix_ = None
        self.coordinationStatus = _cast(None, coordinationStatus)
        self.coordinationStatus_nsprefix_ = None
        self.nonStandardCommunicationReason = _cast(None, nonStandardCommunicationReason)
        self.nonStandardCommunicationReason_nsprefix_ = None
        self.releaseConditions = _cast(None, releaseConditions)
        self.releaseConditions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoordinationStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordinationStatusType.subclass:
            return CoordinationStatusType.subclass(*args_, **kwargs_)
        else:
            return CoordinationStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_abrogationReason(self):
        return self.abrogationReason
    def set_abrogationReason(self, abrogationReason):
        self.abrogationReason = abrogationReason
    def get_coordinationStatus(self):
        return self.coordinationStatus
    def set_coordinationStatus(self, coordinationStatus):
        self.coordinationStatus = coordinationStatus
    def get_nonStandardCommunicationReason(self):
        return self.nonStandardCommunicationReason
    def set_nonStandardCommunicationReason(self, nonStandardCommunicationReason):
        self.nonStandardCommunicationReason = nonStandardCommunicationReason
    def get_releaseConditions(self):
        return self.releaseConditions
    def set_releaseConditions(self, releaseConditions):
        self.releaseConditions = releaseConditions
    def validate_AbrogationReasonCodeType(self, value):
        # Validate type fx:AbrogationReasonCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['TFL', 'ROUTE', 'CANCELLATION', 'DELAY', 'HOLD']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AbrogationReasonCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_CoordinationStatusCodeType(self, value):
        # Validate type fx:CoordinationStatusCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['NOTIFIED', 'OFFERED', 'RENEGOTIATE_REQUESTED', 'RENEGOTIATE_REJECTED', 'COORDINATED', 'REJECTED', 'REQUESTED_ON_FREQUENCY', 'ASSUMED', 'BACKWARD_COORDINATING', 'BACKWARD_COORDINATING_REJECTED', 'BACKWARD_COORDINATING_ACCEPTED', 'ABROGATED', 'ATSU_SKIPPED', 'FREQUENCY_CHANGED', 'RELEASE_REQUESTED', 'RELEASE_REJECTED', 'RELEASED', 'MANUALLY_REFERRED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CoordinationStatusCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_NonStandardCoordinationReasonType(self, value):
        # Validate type fx:NonStandardCoordinationReasonType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LATE_ACTIVATION', 'LATERAL_DEVIATION', 'LATE_REVISION', 'NON_STANDARD_TFL', 'NON_STANDARD_EQUIPMENT', 'NON_STANDARD_SSR_CODE', 'TRANSITION_POINT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NonStandardCoordinationReasonType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ReleaseConditionsType(self, value):
        # Validate type fx:ReleaseConditionsType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CLIMB', 'DESCENT', 'TURNS', 'FULL']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ReleaseConditionsType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='CoordinationStatusType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CoordinationStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CoordinationStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CoordinationStatusType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='CoordinationStatusType'):
        if self.abrogationReason is not None and 'abrogationReason' not in already_processed:
            already_processed.add('abrogationReason')
            outfile.write(' abrogationReason=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.abrogationReason), input_name='abrogationReason')), ))
        if self.coordinationStatus is not None and 'coordinationStatus' not in already_processed:
            already_processed.add('coordinationStatus')
            outfile.write(' coordinationStatus=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.coordinationStatus), input_name='coordinationStatus')), ))
        if self.nonStandardCommunicationReason is not None and 'nonStandardCommunicationReason' not in already_processed:
            already_processed.add('nonStandardCommunicationReason')
            outfile.write(' nonStandardCommunicationReason=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nonStandardCommunicationReason), input_name='nonStandardCommunicationReason')), ))
        if self.releaseConditions is not None and 'releaseConditions' not in already_processed:
            already_processed.add('releaseConditions')
            outfile.write(' releaseConditions=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.releaseConditions), input_name='releaseConditions')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='CoordinationStatusType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('abrogationReason', node)
        if value is not None and 'abrogationReason' not in already_processed:
            already_processed.add('abrogationReason')
            self.abrogationReason = value
            self.validate_AbrogationReasonCodeType(self.abrogationReason)    # validate type AbrogationReasonCodeType
        value = find_attr_value_('coordinationStatus', node)
        if value is not None and 'coordinationStatus' not in already_processed:
            already_processed.add('coordinationStatus')
            self.coordinationStatus = value
            self.validate_CoordinationStatusCodeType(self.coordinationStatus)    # validate type CoordinationStatusCodeType
        value = find_attr_value_('nonStandardCommunicationReason', node)
        if value is not None and 'nonStandardCommunicationReason' not in already_processed:
            already_processed.add('nonStandardCommunicationReason')
            self.nonStandardCommunicationReason = value
            self.validate_NonStandardCoordinationReasonType(self.nonStandardCommunicationReason)    # validate type NonStandardCoordinationReasonType
        value = find_attr_value_('releaseConditions', node)
        if value is not None and 'releaseConditions' not in already_processed:
            already_processed.add('releaseConditions')
            self.releaseConditions = value
            self.validate_ReleaseConditionsType(self.releaseConditions)    # validate type ReleaseConditionsType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CoordinationStatusType


class CpdlcConnectionType(GeneratedsSuper):
    """Groups information regarding CPDLC connection between air traffic
    control units
    .ATN Logon Parameters: The ATN logon parameters allow the ground unit to
    log on
    to the data link equipped aircraft to use the data link applications.
    .CPDLC Connection Status: Provides the aircraft s Controller Pilot Data
    Link Communications
    (CPDLC) Connection status and optional frequency information.
    .FANS/1A Logon Parameters: The information necessary to establish CPDLC
    and/or ADS-C
    connections with a FANS equipped aircraft.
    .Frequency Usage: The usage of the frequency.
    .CPDLC Start Request Indicator: For a flight crossing the boundary from one
    facility
    to the next, notifies the data link equipped unit it can send a CPDLC Start
    Request
    to the aircraft, because the aircraft is authorized to accept a CPDLC
    connection
    request from the receiving unit."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, atnLogonParameters=None, connectionStatus=None, fans1ALogonParameters=None, frequencyUsage=None, sendCpldcIndicator=None, receivingUnitFrequency=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.atnLogonParameters = _cast(None, atnLogonParameters)
        self.atnLogonParameters_nsprefix_ = None
        self.connectionStatus = _cast(None, connectionStatus)
        self.connectionStatus_nsprefix_ = None
        self.fans1ALogonParameters = _cast(None, fans1ALogonParameters)
        self.fans1ALogonParameters_nsprefix_ = None
        self.frequencyUsage = _cast(None, frequencyUsage)
        self.frequencyUsage_nsprefix_ = None
        self.sendCpldcIndicator = _cast(None, sendCpldcIndicator)
        self.sendCpldcIndicator_nsprefix_ = None
        self.receivingUnitFrequency = receivingUnitFrequency
        self.receivingUnitFrequency_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CpdlcConnectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CpdlcConnectionType.subclass:
            return CpdlcConnectionType.subclass(*args_, **kwargs_)
        else:
            return CpdlcConnectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_receivingUnitFrequency(self):
        return self.receivingUnitFrequency
    def set_receivingUnitFrequency(self, receivingUnitFrequency):
        self.receivingUnitFrequency = receivingUnitFrequency
    def get_atnLogonParameters(self):
        return self.atnLogonParameters
    def set_atnLogonParameters(self, atnLogonParameters):
        self.atnLogonParameters = atnLogonParameters
    def get_connectionStatus(self):
        return self.connectionStatus
    def set_connectionStatus(self, connectionStatus):
        self.connectionStatus = connectionStatus
    def get_fans1ALogonParameters(self):
        return self.fans1ALogonParameters
    def set_fans1ALogonParameters(self, fans1ALogonParameters):
        self.fans1ALogonParameters = fans1ALogonParameters
    def get_frequencyUsage(self):
        return self.frequencyUsage
    def set_frequencyUsage(self, frequencyUsage):
        self.frequencyUsage = frequencyUsage
    def get_sendCpldcIndicator(self):
        return self.sendCpldcIndicator
    def set_sendCpldcIndicator(self, sendCpldcIndicator):
        self.sendCpldcIndicator = sendCpldcIndicator
    def validate_AtnLogonParametersType(self, value):
        # Validate type fx:AtnLogonParametersType, a restriction on fb:ParametersType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on AtnLogonParametersType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 49:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on AtnLogonParametersType' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_CpdlcConnectionStatusType(self, value):
        # Validate type fx:CpdlcConnectionStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['NO_CONNECTION', 'CONNECTION_FAILED', 'CONNECTION_ESTABLISHED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CpdlcConnectionStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_Fans1ALogonParametersType(self, value):
        # Validate type fx:Fans1ALogonParametersType, a restriction on fb:ParametersType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Fans1ALogonParametersType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 49:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Fans1ALogonParametersType' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_FrequencyUsageType(self, value):
        # Validate type fx:FrequencyUsageType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['VOICE', 'CPDLC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FrequencyUsageType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_CpdlcStartRequestIndicatorType(self, value):
        # Validate type fx:CpdlcStartRequestIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SEND_CPDLC_START_REQUEST']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CpdlcStartRequestIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.receivingUnitFrequency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='CpdlcConnectionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CpdlcConnectionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CpdlcConnectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CpdlcConnectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='CpdlcConnectionType'):
        if self.atnLogonParameters is not None and 'atnLogonParameters' not in already_processed:
            already_processed.add('atnLogonParameters')
            outfile.write(' atnLogonParameters=%s' % (quote_attrib(self.atnLogonParameters), ))
        if self.connectionStatus is not None and 'connectionStatus' not in already_processed:
            already_processed.add('connectionStatus')
            outfile.write(' connectionStatus=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.connectionStatus), input_name='connectionStatus')), ))
        if self.fans1ALogonParameters is not None and 'fans1ALogonParameters' not in already_processed:
            already_processed.add('fans1ALogonParameters')
            outfile.write(' fans1ALogonParameters=%s' % (quote_attrib(self.fans1ALogonParameters), ))
        if self.frequencyUsage is not None and 'frequencyUsage' not in already_processed:
            already_processed.add('frequencyUsage')
            outfile.write(' frequencyUsage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.frequencyUsage), input_name='frequencyUsage')), ))
        if self.sendCpldcIndicator is not None and 'sendCpldcIndicator' not in already_processed:
            already_processed.add('sendCpldcIndicator')
            outfile.write(' sendCpldcIndicator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sendCpldcIndicator), input_name='sendCpldcIndicator')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='CpdlcConnectionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.receivingUnitFrequency is not None:
            namespaceprefix_ = self.receivingUnitFrequency_nsprefix_ + ':' if (UseCapturedNS_ and self.receivingUnitFrequency_nsprefix_) else ''
            self.receivingUnitFrequency.export(outfile, level, namespaceprefix_, namespacedef_='', name_='receivingUnitFrequency', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('atnLogonParameters', node)
        if value is not None and 'atnLogonParameters' not in already_processed:
            already_processed.add('atnLogonParameters')
            self.atnLogonParameters = value
            self.validate_AtnLogonParametersType(self.atnLogonParameters)    # validate type AtnLogonParametersType
        value = find_attr_value_('connectionStatus', node)
        if value is not None and 'connectionStatus' not in already_processed:
            already_processed.add('connectionStatus')
            self.connectionStatus = value
            self.validate_CpdlcConnectionStatusType(self.connectionStatus)    # validate type CpdlcConnectionStatusType
        value = find_attr_value_('fans1ALogonParameters', node)
        if value is not None and 'fans1ALogonParameters' not in already_processed:
            already_processed.add('fans1ALogonParameters')
            self.fans1ALogonParameters = value
            self.validate_Fans1ALogonParametersType(self.fans1ALogonParameters)    # validate type Fans1ALogonParametersType
        value = find_attr_value_('frequencyUsage', node)
        if value is not None and 'frequencyUsage' not in already_processed:
            already_processed.add('frequencyUsage')
            self.frequencyUsage = value
            self.validate_FrequencyUsageType(self.frequencyUsage)    # validate type FrequencyUsageType
        value = find_attr_value_('sendCpldcIndicator', node)
        if value is not None and 'sendCpldcIndicator' not in already_processed:
            already_processed.add('sendCpldcIndicator')
            self.sendCpldcIndicator = value
            self.validate_CpdlcStartRequestIndicatorType(self.sendCpldcIndicator)    # validate type CpdlcStartRequestIndicatorType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'receivingUnitFrequency':
            obj_ = RadioFrequencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.receivingUnitFrequency = obj_
            obj_.original_tagname_ = 'receivingUnitFrequency'
# end class CpdlcConnectionType


class AirspaceConstraintType(GeneratedsSuper):
    """Represents an airspace that has been constrained such as flow
    constrained area with
    associated controlled time.
    Constrained Airspace associated with the airspace controlled entry time."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, constrainedAirspace=None, airspaceControlledEntryTime=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.constrainedAirspace = _cast(None, constrainedAirspace)
        self.constrainedAirspace_nsprefix_ = None
        if isinstance(airspaceControlledEntryTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(airspaceControlledEntryTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = airspaceControlledEntryTime
        self.airspaceControlledEntryTime = initvalue_
        self.airspaceControlledEntryTime_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AirspaceConstraintType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AirspaceConstraintType.subclass:
            return AirspaceConstraintType.subclass(*args_, **kwargs_)
        else:
            return AirspaceConstraintType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_airspaceControlledEntryTime(self):
        return self.airspaceControlledEntryTime
    def set_airspaceControlledEntryTime(self, airspaceControlledEntryTime):
        self.airspaceControlledEntryTime = airspaceControlledEntryTime
    def get_constrainedAirspace(self):
        return self.constrainedAirspace
    def set_constrainedAirspace(self, constrainedAirspace):
        self.constrainedAirspace = constrainedAirspace
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_TimeType(self, value):
        result = True
        # Validate type TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_ConstrainedAirspaceType(self, value):
        # Validate type fb:ConstrainedAirspaceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.airspaceControlledEntryTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='AirspaceConstraintType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AirspaceConstraintType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AirspaceConstraintType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AirspaceConstraintType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='AirspaceConstraintType'):
        if self.constrainedAirspace is not None and 'constrainedAirspace' not in already_processed:
            already_processed.add('constrainedAirspace')
            outfile.write(' constrainedAirspace=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.constrainedAirspace), input_name='constrainedAirspace')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='AirspaceConstraintType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.airspaceControlledEntryTime is not None:
            namespaceprefix_ = self.airspaceControlledEntryTime_nsprefix_ + ':' if (UseCapturedNS_ and self.airspaceControlledEntryTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sairspaceControlledEntryTime>%s</%sairspaceControlledEntryTime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.airspaceControlledEntryTime, input_name='airspaceControlledEntryTime'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('constrainedAirspace', node)
        if value is not None and 'constrainedAirspace' not in already_processed:
            already_processed.add('constrainedAirspace')
            self.constrainedAirspace = value
            self.validate_ConstrainedAirspaceType(self.constrainedAirspace)    # validate type ConstrainedAirspaceType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'airspaceControlledEntryTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.airspaceControlledEntryTime = dval_
            self.airspaceControlledEntryTime_nsprefix_ = child_.prefix
            # validate type TimeType
            self.validate_TimeType(self.airspaceControlledEntryTime)
# end class AirspaceConstraintType


class BeaconCodeAssignmentType(GeneratedsSuper):
    """Contains information about current, previous and next beacon code
    assignments along
    with the beacon code assigning facility.
    .Beacon Code: The assigned four-character numeric code transmitted by the
    aircraft
    transponder in response to a secondary surveillance radar interrogation
    signal which
    is used to assist air traffic controllers to identify aircraft."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, currentBeaconCode=None, previousBeaconCode=None, reassignedBeaconCode=None, reassigningUnit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.currentBeaconCode = currentBeaconCode
        self.currentBeaconCode_nsprefix_ = None
        self.previousBeaconCode = previousBeaconCode
        self.previousBeaconCode_nsprefix_ = None
        self.reassignedBeaconCode = reassignedBeaconCode
        self.reassignedBeaconCode_nsprefix_ = None
        self.reassigningUnit = reassigningUnit
        self.reassigningUnit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BeaconCodeAssignmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BeaconCodeAssignmentType.subclass:
            return BeaconCodeAssignmentType.subclass(*args_, **kwargs_)
        else:
            return BeaconCodeAssignmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_currentBeaconCode(self):
        return self.currentBeaconCode
    def set_currentBeaconCode(self, currentBeaconCode):
        self.currentBeaconCode = currentBeaconCode
    def get_previousBeaconCode(self):
        return self.previousBeaconCode
    def set_previousBeaconCode(self, previousBeaconCode):
        self.previousBeaconCode = previousBeaconCode
    def get_reassignedBeaconCode(self):
        return self.reassignedBeaconCode
    def set_reassignedBeaconCode(self, reassignedBeaconCode):
        self.reassignedBeaconCode = reassignedBeaconCode
    def get_reassigningUnit(self):
        return self.reassigningUnit
    def set_reassigningUnit(self, reassigningUnit):
        self.reassigningUnit = reassigningUnit
    def set_reassigningUnit_with_type(self, value):
        self.reassigningUnit = value
        value.original_tagname_ = 'reassigningUnit'
        value.extensiontype_ = value.__class__.__name__
    def hasContent_(self):
        if (
            self.currentBeaconCode is not None or
            self.previousBeaconCode is not None or
            self.reassignedBeaconCode is not None or
            self.reassigningUnit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='BeaconCodeAssignmentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BeaconCodeAssignmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BeaconCodeAssignmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BeaconCodeAssignmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='BeaconCodeAssignmentType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='BeaconCodeAssignmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currentBeaconCode is not None:
            namespaceprefix_ = self.currentBeaconCode_nsprefix_ + ':' if (UseCapturedNS_ and self.currentBeaconCode_nsprefix_) else ''
            self.currentBeaconCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='currentBeaconCode', pretty_print=pretty_print)
        if self.previousBeaconCode is not None:
            namespaceprefix_ = self.previousBeaconCode_nsprefix_ + ':' if (UseCapturedNS_ and self.previousBeaconCode_nsprefix_) else ''
            self.previousBeaconCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='previousBeaconCode', pretty_print=pretty_print)
        if self.reassignedBeaconCode is not None:
            namespaceprefix_ = self.reassignedBeaconCode_nsprefix_ + ':' if (UseCapturedNS_ and self.reassignedBeaconCode_nsprefix_) else ''
            self.reassignedBeaconCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reassignedBeaconCode', pretty_print=pretty_print)
        if self.reassigningUnit is not None:
            self.reassigningUnit.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currentBeaconCode':
            obj_ = BeaconCodeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currentBeaconCode = obj_
            obj_.original_tagname_ = 'currentBeaconCode'
        elif nodeName_ == 'previousBeaconCode':
            obj_ = BeaconCodeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.previousBeaconCode = obj_
            obj_.original_tagname_ = 'previousBeaconCode'
        elif nodeName_ == 'reassignedBeaconCode':
            obj_ = BeaconCodeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reassignedBeaconCode = obj_
            obj_.original_tagname_ = 'reassignedBeaconCode'
        elif nodeName_ == 'reassigningUnit':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <reassigningUnit> element')
            self.reassigningUnit = obj_
            obj_.original_tagname_ = 'reassigningUnit'
# end class BeaconCodeAssignmentType


class ClearedFlightInformationType(GeneratedsSuper):
    """Groups cleared information about the fight"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, clearedFlightLevel=None, clearedSpeed=None, directRouting=None, heading=None, offtrackClearance=None, rateOfClimbDescend=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.clearedFlightLevel = clearedFlightLevel
        self.clearedFlightLevel_nsprefix_ = None
        self.clearedSpeed = clearedSpeed
        self.clearedSpeed_nsprefix_ = None
        self.directRouting = directRouting
        self.directRouting_nsprefix_ = None
        self.heading = heading
        self.heading_nsprefix_ = None
        self.offtrackClearance = offtrackClearance
        self.offtrackClearance_nsprefix_ = None
        self.rateOfClimbDescend = rateOfClimbDescend
        self.rateOfClimbDescend_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClearedFlightInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClearedFlightInformationType.subclass:
            return ClearedFlightInformationType.subclass(*args_, **kwargs_)
        else:
            return ClearedFlightInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_clearedFlightLevel(self):
        return self.clearedFlightLevel
    def set_clearedFlightLevel(self, clearedFlightLevel):
        self.clearedFlightLevel = clearedFlightLevel
    def get_clearedSpeed(self):
        return self.clearedSpeed
    def set_clearedSpeed(self, clearedSpeed):
        self.clearedSpeed = clearedSpeed
    def get_directRouting(self):
        return self.directRouting
    def set_directRouting(self, directRouting):
        self.directRouting = directRouting
    def get_heading(self):
        return self.heading
    def set_heading(self, heading):
        self.heading = heading
    def get_offtrackClearance(self):
        return self.offtrackClearance
    def set_offtrackClearance(self, offtrackClearance):
        self.offtrackClearance = offtrackClearance
    def get_rateOfClimbDescend(self):
        return self.rateOfClimbDescend
    def set_rateOfClimbDescend(self, rateOfClimbDescend):
        self.rateOfClimbDescend = rateOfClimbDescend
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.clearedFlightLevel is not None or
            self.clearedSpeed is not None or
            self.directRouting is not None or
            self.heading is not None or
            self.offtrackClearance is not None or
            self.rateOfClimbDescend is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='ClearedFlightInformationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClearedFlightInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClearedFlightInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClearedFlightInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='ClearedFlightInformationType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='ClearedFlightInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.clearedFlightLevel is not None:
            namespaceprefix_ = self.clearedFlightLevel_nsprefix_ + ':' if (UseCapturedNS_ and self.clearedFlightLevel_nsprefix_) else ''
            self.clearedFlightLevel.export(outfile, level, namespaceprefix_, namespacedef_='', name_='clearedFlightLevel', pretty_print=pretty_print)
        if self.clearedSpeed is not None:
            namespaceprefix_ = self.clearedSpeed_nsprefix_ + ':' if (UseCapturedNS_ and self.clearedSpeed_nsprefix_) else ''
            self.clearedSpeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='clearedSpeed', pretty_print=pretty_print)
        if self.directRouting is not None:
            namespaceprefix_ = self.directRouting_nsprefix_ + ':' if (UseCapturedNS_ and self.directRouting_nsprefix_) else ''
            self.directRouting.export(outfile, level, namespaceprefix_, namespacedef_='', name_='directRouting', pretty_print=pretty_print)
        if self.heading is not None:
            namespaceprefix_ = self.heading_nsprefix_ + ':' if (UseCapturedNS_ and self.heading_nsprefix_) else ''
            self.heading.export(outfile, level, namespaceprefix_, namespacedef_='', name_='heading', pretty_print=pretty_print)
        if self.offtrackClearance is not None:
            namespaceprefix_ = self.offtrackClearance_nsprefix_ + ':' if (UseCapturedNS_ and self.offtrackClearance_nsprefix_) else ''
            self.offtrackClearance.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offtrackClearance', pretty_print=pretty_print)
        if self.rateOfClimbDescend is not None:
            namespaceprefix_ = self.rateOfClimbDescend_nsprefix_ + ':' if (UseCapturedNS_ and self.rateOfClimbDescend_nsprefix_) else ''
            self.rateOfClimbDescend.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rateOfClimbDescend', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'clearedFlightLevel':
            obj_ = AltitudeChoiceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.clearedFlightLevel = obj_
            obj_.original_tagname_ = 'clearedFlightLevel'
        elif nodeName_ == 'clearedSpeed':
            obj_ = AirspeedChoiceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.clearedSpeed = obj_
            obj_.original_tagname_ = 'clearedSpeed'
        elif nodeName_ == 'directRouting':
            obj_ = DirectRoutingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.directRouting = obj_
            obj_.original_tagname_ = 'directRouting'
        elif nodeName_ == 'heading':
            obj_ = DirectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.heading = obj_
            obj_.original_tagname_ = 'heading'
        elif nodeName_ == 'offtrackClearance':
            obj_ = LateralOfftrackType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offtrackClearance = obj_
            obj_.original_tagname_ = 'offtrackClearance'
        elif nodeName_ == 'rateOfClimbDescend':
            obj_ = VerticalRateType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rateOfClimbDescend = obj_
            obj_.original_tagname_ = 'rateOfClimbDescend'
# end class ClearedFlightInformationType


class ControlElementType(GeneratedsSuper):
    """.Control Element: The constrained aerodrome or airspace element (subject
    to a Traffic
    Management Initiative/Regulation) indicating the reason for a flight being
    controlled."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, airspace=None, arrivalAerodrome=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.airspace = airspace
        self.airspace_nsprefix_ = None
        self.arrivalAerodrome = arrivalAerodrome
        self.validate_AerodromeIcaoCodeType(self.arrivalAerodrome)
        self.arrivalAerodrome_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ControlElementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ControlElementType.subclass:
            return ControlElementType.subclass(*args_, **kwargs_)
        else:
            return ControlElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_airspace(self):
        return self.airspace
    def set_airspace(self, airspace):
        self.airspace = airspace
    def get_arrivalAerodrome(self):
        return self.arrivalAerodrome
    def set_arrivalAerodrome(self, arrivalAerodrome):
        self.arrivalAerodrome = arrivalAerodrome
    def validate_AerodromeIcaoCodeType(self, value):
        result = True
        # Validate type AerodromeIcaoCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_AerodromeIcaoCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AerodromeIcaoCodeType_patterns_, ))
                result = False
        return result
    validate_AerodromeIcaoCodeType_patterns_ = [['^([A-Z]{4})$']]
    def hasContent_(self):
        if (
            self.airspace is not None or
            self.arrivalAerodrome is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='ControlElementType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ControlElementType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ControlElementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ControlElementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='ControlElementType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='ControlElementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.airspace is not None:
            namespaceprefix_ = self.airspace_nsprefix_ + ':' if (UseCapturedNS_ and self.airspace_nsprefix_) else ''
            self.airspace.export(outfile, level, namespaceprefix_, namespacedef_='', name_='airspace', pretty_print=pretty_print)
        if self.arrivalAerodrome is not None:
            namespaceprefix_ = self.arrivalAerodrome_nsprefix_ + ':' if (UseCapturedNS_ and self.arrivalAerodrome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sarrivalAerodrome>%s</%sarrivalAerodrome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.arrivalAerodrome), input_name='arrivalAerodrome')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'airspace':
            class_obj_ = self.get_class_obj_(child_, AirspaceConstraintType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.airspace = obj_
            obj_.original_tagname_ = 'airspace'
        elif nodeName_ == 'arrivalAerodrome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'arrivalAerodrome')
            value_ = self.gds_validate_string(value_, node, 'arrivalAerodrome')
            self.arrivalAerodrome = value_
            self.arrivalAerodrome_nsprefix_ = child_.prefix
            # validate type AerodromeIcaoCodeType
            self.validate_AerodromeIcaoCodeType(self.arrivalAerodrome)
# end class ControlElementType


class DirectRoutingType(GeneratedsSuper):
    """.Cleared Direct To: Contains the optional starting location from which
    the direct
    clearance is granted and the position the aircraft has been cleared
    directly to."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, from_=None, to=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.from_ = from_
        self.from__nsprefix_ = None
        self.to = to
        self.to_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DirectRoutingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DirectRoutingType.subclass:
            return DirectRoutingType.subclass(*args_, **kwargs_)
        else:
            return DirectRoutingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_from(self):
        return self.from_
    def set_from(self, from_):
        self.from_ = from_
    def set_from_with_type(self, value):
        self.from_ = value
        value.original_tagname_ = 'from'
        value.extensiontype_ = value.__class__.__name__
    def get_to(self):
        return self.to
    def set_to(self, to):
        self.to = to
    def set_to_with_type(self, value):
        self.to = value
        value.original_tagname_ = 'to'
        value.extensiontype_ = value.__class__.__name__
    def hasContent_(self):
        if (
            self.from_ is not None or
            self.to is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='DirectRoutingType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DirectRoutingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DirectRoutingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DirectRoutingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='DirectRoutingType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='DirectRoutingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.from_ is not None:
            self.from_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.to is not None:
            self.to.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'from':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <from_> element')
            self.from_ = obj_
            obj_.original_tagname_ = 'from'
        elif nodeName_ == 'to':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <to> element')
            self.to = obj_
            obj_.original_tagname_ = 'to'
# end class DirectRoutingType


class EnRouteType(FeatureType):
    """Groups the en route information about the flight such as the current
    position, coordination
    between air traffic units, and boundary crossing throughout the duration of
    the flight.
    The relative priority of a flight, within a flight operator’s fleet of
    aircraft,
    defined for a portion or the entire en route phase of flight"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FeatureType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, fleetPrioritization=None, alternateAerodrome=None, beaconCodeAssignment=None, boundaryCrossings=None, cleared=None, controlElement=None, cpdlcConnection=None, pointout=None, position=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EnRouteType, self).__init__(centre, source, system, timestamp, extensiontype_,  **kwargs_)
        self.fleetPrioritization = _cast(None, fleetPrioritization)
        self.fleetPrioritization_nsprefix_ = None
        if alternateAerodrome is None:
            self.alternateAerodrome = []
        else:
            self.alternateAerodrome = alternateAerodrome
        self.alternateAerodrome_nsprefix_ = None
        self.beaconCodeAssignment = beaconCodeAssignment
        self.beaconCodeAssignment_nsprefix_ = None
        if boundaryCrossings is None:
            self.boundaryCrossings = []
        else:
            self.boundaryCrossings = boundaryCrossings
        self.boundaryCrossings_nsprefix_ = None
        self.cleared = cleared
        self.cleared_nsprefix_ = None
        if controlElement is None:
            self.controlElement = []
        else:
            self.controlElement = controlElement
        self.controlElement_nsprefix_ = None
        self.cpdlcConnection = cpdlcConnection
        self.cpdlcConnection_nsprefix_ = None
        self.pointout = pointout
        self.pointout_nsprefix_ = None
        self.position = position
        self.position_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnRouteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnRouteType.subclass:
            return EnRouteType.subclass(*args_, **kwargs_)
        else:
            return EnRouteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alternateAerodrome(self):
        return self.alternateAerodrome
    def set_alternateAerodrome(self, alternateAerodrome):
        self.alternateAerodrome = alternateAerodrome
    def set_alternateAerodrome_with_type(self, value):
        self.alternateAerodrome = value
        value.original_tagname_ = 'alternateAerodrome'
        value.extensiontype_ = value.__class__.__name__
    def add_alternateAerodrome(self, value):
        self.alternateAerodrome.append(value)
    def add_alternateAerodrome_with_type(self, value):
        self.alternateAerodrome.append(value)
        value.original_tagname_ = 'alternateAerodrome'
        value.extensiontype_ = value.__class__.__name__
    def insert_alternateAerodrome_at(self, index, value):
        self.alternateAerodrome.insert(index, value)
    def replace_alternateAerodrome_at(self, index, value):
        self.alternateAerodrome[index] = value
    def get_beaconCodeAssignment(self):
        return self.beaconCodeAssignment
    def set_beaconCodeAssignment(self, beaconCodeAssignment):
        self.beaconCodeAssignment = beaconCodeAssignment
    def get_boundaryCrossings(self):
        return self.boundaryCrossings
    def set_boundaryCrossings(self, boundaryCrossings):
        self.boundaryCrossings = boundaryCrossings
    def add_boundaryCrossings(self, value):
        self.boundaryCrossings.append(value)
    def insert_boundaryCrossings_at(self, index, value):
        self.boundaryCrossings.insert(index, value)
    def replace_boundaryCrossings_at(self, index, value):
        self.boundaryCrossings[index] = value
    def get_cleared(self):
        return self.cleared
    def set_cleared(self, cleared):
        self.cleared = cleared
    def get_controlElement(self):
        return self.controlElement
    def set_controlElement(self, controlElement):
        self.controlElement = controlElement
    def add_controlElement(self, value):
        self.controlElement.append(value)
    def insert_controlElement_at(self, index, value):
        self.controlElement.insert(index, value)
    def replace_controlElement_at(self, index, value):
        self.controlElement[index] = value
    def get_cpdlcConnection(self):
        return self.cpdlcConnection
    def set_cpdlcConnection(self, cpdlcConnection):
        self.cpdlcConnection = cpdlcConnection
    def get_pointout(self):
        return self.pointout
    def set_pointout(self, pointout):
        self.pointout = pointout
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def get_fleetPrioritization(self):
        return self.fleetPrioritization
    def set_fleetPrioritization(self, fleetPrioritization):
        self.fleetPrioritization = fleetPrioritization
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_FleetPriorityType(self, value):
        # Validate type fb:FleetPriorityType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on FleetPriorityType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on FleetPriorityType' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.alternateAerodrome or
            self.beaconCodeAssignment is not None or
            self.boundaryCrossings or
            self.cleared is not None or
            self.controlElement or
            self.cpdlcConnection is not None or
            self.pointout is not None or
            self.position is not None or
            super(EnRouteType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='EnRouteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnRouteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnRouteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EnRouteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='EnRouteType'):
        super(EnRouteType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnRouteType')
        if self.fleetPrioritization is not None and 'fleetPrioritization' not in already_processed:
            already_processed.add('fleetPrioritization')
            outfile.write(' fleetPrioritization="%s"' % self.gds_format_integer(self.fleetPrioritization, input_name='fleetPrioritization'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='EnRouteType', fromsubclass_=False, pretty_print=True):
        super(EnRouteType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alternateAerodrome_ in self.alternateAerodrome:
            alternateAerodrome_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.beaconCodeAssignment is not None:
            namespaceprefix_ = self.beaconCodeAssignment_nsprefix_ + ':' if (UseCapturedNS_ and self.beaconCodeAssignment_nsprefix_) else ''
            self.beaconCodeAssignment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='beaconCodeAssignment', pretty_print=pretty_print)
        for boundaryCrossings_ in self.boundaryCrossings:
            namespaceprefix_ = self.boundaryCrossings_nsprefix_ + ':' if (UseCapturedNS_ and self.boundaryCrossings_nsprefix_) else ''
            boundaryCrossings_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='boundaryCrossings', pretty_print=pretty_print)
        if self.cleared is not None:
            namespaceprefix_ = self.cleared_nsprefix_ + ':' if (UseCapturedNS_ and self.cleared_nsprefix_) else ''
            self.cleared.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cleared', pretty_print=pretty_print)
        for controlElement_ in self.controlElement:
            namespaceprefix_ = self.controlElement_nsprefix_ + ':' if (UseCapturedNS_ and self.controlElement_nsprefix_) else ''
            controlElement_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='controlElement', pretty_print=pretty_print)
        if self.cpdlcConnection is not None:
            namespaceprefix_ = self.cpdlcConnection_nsprefix_ + ':' if (UseCapturedNS_ and self.cpdlcConnection_nsprefix_) else ''
            self.cpdlcConnection.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cpdlcConnection', pretty_print=pretty_print)
        if self.pointout is not None:
            namespaceprefix_ = self.pointout_nsprefix_ + ':' if (UseCapturedNS_ and self.pointout_nsprefix_) else ''
            self.pointout.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pointout', pretty_print=pretty_print)
        if self.position is not None:
            namespaceprefix_ = self.position_nsprefix_ + ':' if (UseCapturedNS_ and self.position_nsprefix_) else ''
            self.position.export(outfile, level, namespaceprefix_, namespacedef_='', name_='position', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fleetPrioritization', node)
        if value is not None and 'fleetPrioritization' not in already_processed:
            already_processed.add('fleetPrioritization')
            self.fleetPrioritization = self.gds_parse_integer(value, node, 'fleetPrioritization')
            self.validate_FleetPriorityType(self.fleetPrioritization)    # validate type FleetPriorityType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EnRouteType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'alternateAerodrome':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <alternateAerodrome> element')
            self.alternateAerodrome.append(obj_)
            obj_.original_tagname_ = 'alternateAerodrome'
        elif nodeName_ == 'beaconCodeAssignment':
            obj_ = BeaconCodeAssignmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.beaconCodeAssignment = obj_
            obj_.original_tagname_ = 'beaconCodeAssignment'
        elif nodeName_ == 'boundaryCrossings':
            class_obj_ = self.get_class_obj_(child_, UnitBoundaryType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.boundaryCrossings.append(obj_)
            obj_.original_tagname_ = 'boundaryCrossings'
        elif nodeName_ == 'cleared':
            class_obj_ = self.get_class_obj_(child_, ClearedFlightInformationType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cleared = obj_
            obj_.original_tagname_ = 'cleared'
        elif nodeName_ == 'controlElement':
            obj_ = ControlElementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.controlElement.append(obj_)
            obj_.original_tagname_ = 'controlElement'
        elif nodeName_ == 'cpdlcConnection':
            obj_ = CpdlcConnectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cpdlcConnection = obj_
            obj_.original_tagname_ = 'cpdlcConnection'
        elif nodeName_ == 'pointout':
            obj_ = PointoutType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pointout = obj_
            obj_.original_tagname_ = 'pointout'
        elif nodeName_ == 'position':
            class_obj_ = self.get_class_obj_(child_, AircraftPositionType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
        super(EnRouteType, self).buildChildren(child_, node, nodeName_, True)
# end class EnRouteType


class PointoutType(GeneratedsSuper):
    """A physical or automated action taken by a controller to transfer the
    radar identification
    of an aircraft to another controller if the aircraft will or may enter the
    airspace
    or protected airspace of another controller and radio communications will
    not be
    transferred."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, originatingUnit=None, receivingUnit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.originatingUnit = originatingUnit
        self.originatingUnit_nsprefix_ = None
        if receivingUnit is None:
            self.receivingUnit = []
        else:
            self.receivingUnit = receivingUnit
        self.receivingUnit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PointoutType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PointoutType.subclass:
            return PointoutType.subclass(*args_, **kwargs_)
        else:
            return PointoutType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_originatingUnit(self):
        return self.originatingUnit
    def set_originatingUnit(self, originatingUnit):
        self.originatingUnit = originatingUnit
    def set_originatingUnit_with_type(self, value):
        self.originatingUnit = value
        value.original_tagname_ = 'originatingUnit'
        value.extensiontype_ = value.__class__.__name__
    def get_receivingUnit(self):
        return self.receivingUnit
    def set_receivingUnit(self, receivingUnit):
        self.receivingUnit = receivingUnit
    def set_receivingUnit_with_type(self, value):
        self.receivingUnit = value
        value.original_tagname_ = 'receivingUnit'
        value.extensiontype_ = value.__class__.__name__
    def add_receivingUnit(self, value):
        self.receivingUnit.append(value)
    def add_receivingUnit_with_type(self, value):
        self.receivingUnit.append(value)
        value.original_tagname_ = 'receivingUnit'
        value.extensiontype_ = value.__class__.__name__
    def insert_receivingUnit_at(self, index, value):
        self.receivingUnit.insert(index, value)
    def replace_receivingUnit_at(self, index, value):
        self.receivingUnit[index] = value
    def hasContent_(self):
        if (
            self.originatingUnit is not None or
            self.receivingUnit
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='PointoutType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PointoutType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PointoutType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PointoutType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='PointoutType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='PointoutType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originatingUnit is not None:
            self.originatingUnit.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        for receivingUnit_ in self.receivingUnit:
            receivingUnit_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'originatingUnit':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <originatingUnit> element')
            self.originatingUnit = obj_
            obj_.original_tagname_ = 'originatingUnit'
        elif nodeName_ == 'receivingUnit':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <receivingUnit> element')
            self.receivingUnit.append(obj_)
            obj_.original_tagname_ = 'receivingUnit'
# end class PointoutType


class ActualSpeedType(GeneratedsSuper):
    """.Speed - Actual: The actual speed of the aircraft, collected via various
    methods."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, calculated=None, pilotReported=None, surveillance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.calculated = calculated
        self.calculated_nsprefix_ = None
        self.pilotReported = pilotReported
        self.pilotReported_nsprefix_ = None
        self.surveillance = surveillance
        self.surveillance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActualSpeedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActualSpeedType.subclass:
            return ActualSpeedType.subclass(*args_, **kwargs_)
        else:
            return ActualSpeedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_calculated(self):
        return self.calculated
    def set_calculated(self, calculated):
        self.calculated = calculated
    def get_pilotReported(self):
        return self.pilotReported
    def set_pilotReported(self, pilotReported):
        self.pilotReported = pilotReported
    def get_surveillance(self):
        return self.surveillance
    def set_surveillance(self, surveillance):
        self.surveillance = surveillance
    def hasContent_(self):
        if (
            self.calculated is not None or
            self.pilotReported is not None or
            self.surveillance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='ActualSpeedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActualSpeedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActualSpeedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ActualSpeedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='ActualSpeedType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='ActualSpeedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculated is not None:
            namespaceprefix_ = self.calculated_nsprefix_ + ':' if (UseCapturedNS_ and self.calculated_nsprefix_) else ''
            self.calculated.export(outfile, level, namespaceprefix_, namespacedef_='', name_='calculated', pretty_print=pretty_print)
        if self.pilotReported is not None:
            namespaceprefix_ = self.pilotReported_nsprefix_ + ':' if (UseCapturedNS_ and self.pilotReported_nsprefix_) else ''
            self.pilotReported.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pilotReported', pretty_print=pretty_print)
        if self.surveillance is not None:
            namespaceprefix_ = self.surveillance_nsprefix_ + ':' if (UseCapturedNS_ and self.surveillance_nsprefix_) else ''
            self.surveillance.export(outfile, level, namespaceprefix_, namespacedef_='', name_='surveillance', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'calculated':
            obj_ = GroundspeedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.calculated = obj_
            obj_.original_tagname_ = 'calculated'
        elif nodeName_ == 'pilotReported':
            obj_ = TrueAirspeedOrMachType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pilotReported = obj_
            obj_.original_tagname_ = 'pilotReported'
        elif nodeName_ == 'surveillance':
            obj_ = GroundspeedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.surveillance = obj_
            obj_.original_tagname_ = 'surveillance'
# end class ActualSpeedType


class AircraftPositionType(FeatureType):
    """Contains the current position and associated data of the aircraft.
    .Current Position Time: The time associated with the Current Position of an
    active
    flight, from the radar surveillance report or progress report.
    .Current Position Report Source: The source of the current position report
    information."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FeatureType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, positionTime=None, reportSource=None, actualSpeed=None, altitude=None, followingPosition=None, nextPosition=None, position=None, track=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AircraftPositionType, self).__init__(centre, source, system, timestamp, extensiontype_,  **kwargs_)
        self.positionTime = _cast(None, positionTime)
        self.positionTime_nsprefix_ = None
        self.reportSource = _cast(None, reportSource)
        self.reportSource_nsprefix_ = None
        self.actualSpeed = actualSpeed
        self.actualSpeed_nsprefix_ = None
        self.altitude = altitude
        self.altitude_nsprefix_ = None
        self.followingPosition = followingPosition
        self.followingPosition_nsprefix_ = None
        self.nextPosition = nextPosition
        self.nextPosition_nsprefix_ = None
        self.position = position
        self.position_nsprefix_ = None
        self.track = track
        self.track_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AircraftPositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AircraftPositionType.subclass:
            return AircraftPositionType.subclass(*args_, **kwargs_)
        else:
            return AircraftPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_actualSpeed(self):
        return self.actualSpeed
    def set_actualSpeed(self, actualSpeed):
        self.actualSpeed = actualSpeed
    def get_altitude(self):
        return self.altitude
    def set_altitude(self, altitude):
        self.altitude = altitude
    def get_followingPosition(self):
        return self.followingPosition
    def set_followingPosition(self, followingPosition):
        self.followingPosition = followingPosition
    def get_nextPosition(self):
        return self.nextPosition
    def set_nextPosition(self, nextPosition):
        self.nextPosition = nextPosition
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def set_position_with_type(self, value):
        self.position = value
        value.original_tagname_ = 'position'
        value.extensiontype_ = value.__class__.__name__
    def get_track(self):
        return self.track
    def set_track(self, track):
        self.track = track
    def get_positionTime(self):
        return self.positionTime
    def set_positionTime(self, positionTime):
        self.positionTime = positionTime
    def get_reportSource(self):
        return self.reportSource
    def set_reportSource(self, reportSource):
        self.reportSource = reportSource
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_PositionReportSourceType(self, value):
        # Validate type fx:PositionReportSourceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PROGRESS_REPORT', 'SURVEILLANCE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PositionReportSourceType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.actualSpeed is not None or
            self.altitude is not None or
            self.followingPosition is not None or
            self.nextPosition is not None or
            self.position is not None or
            self.track is not None or
            super(AircraftPositionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='AircraftPositionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AircraftPositionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AircraftPositionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AircraftPositionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='AircraftPositionType'):
        super(AircraftPositionType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AircraftPositionType')
        if self.positionTime is not None and 'positionTime' not in already_processed:
            already_processed.add('positionTime')
            outfile.write(' positionTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.positionTime), input_name='positionTime')), ))
        if self.reportSource is not None and 'reportSource' not in already_processed:
            already_processed.add('reportSource')
            outfile.write(' reportSource=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reportSource), input_name='reportSource')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='AircraftPositionType', fromsubclass_=False, pretty_print=True):
        super(AircraftPositionType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.actualSpeed is not None:
            namespaceprefix_ = self.actualSpeed_nsprefix_ + ':' if (UseCapturedNS_ and self.actualSpeed_nsprefix_) else ''
            self.actualSpeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='actualSpeed', pretty_print=pretty_print)
        if self.altitude is not None:
            namespaceprefix_ = self.altitude_nsprefix_ + ':' if (UseCapturedNS_ and self.altitude_nsprefix_) else ''
            self.altitude.export(outfile, level, namespaceprefix_, namespacedef_='', name_='altitude', pretty_print=pretty_print)
        if self.followingPosition is not None:
            namespaceprefix_ = self.followingPosition_nsprefix_ + ':' if (UseCapturedNS_ and self.followingPosition_nsprefix_) else ''
            self.followingPosition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='followingPosition', pretty_print=pretty_print)
        if self.nextPosition is not None:
            namespaceprefix_ = self.nextPosition_nsprefix_ + ':' if (UseCapturedNS_ and self.nextPosition_nsprefix_) else ''
            self.nextPosition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nextPosition', pretty_print=pretty_print)
        if self.position is not None:
            self.position.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.track is not None:
            namespaceprefix_ = self.track_nsprefix_ + ':' if (UseCapturedNS_ and self.track_nsprefix_) else ''
            self.track.export(outfile, level, namespaceprefix_, namespacedef_='', name_='track', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('positionTime', node)
        if value is not None and 'positionTime' not in already_processed:
            already_processed.add('positionTime')
            try:
                self.positionTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (positionTime): %s' % exp)
            self.validate_TimeType(self.positionTime)    # validate type TimeType
        value = find_attr_value_('reportSource', node)
        if value is not None and 'reportSource' not in already_processed:
            already_processed.add('reportSource')
            self.reportSource = value
            self.validate_PositionReportSourceType(self.reportSource)    # validate type PositionReportSourceType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AircraftPositionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'actualSpeed':
            obj_ = ActualSpeedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.actualSpeed = obj_
            obj_.original_tagname_ = 'actualSpeed'
        elif nodeName_ == 'altitude':
            class_obj_ = self.get_class_obj_(child_, AltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.altitude = obj_
            obj_.original_tagname_ = 'altitude'
        elif nodeName_ == 'followingPosition':
            obj_ = PlannedReportingPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.followingPosition = obj_
            obj_.original_tagname_ = 'followingPosition'
        elif nodeName_ == 'nextPosition':
            obj_ = PlannedReportingPositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nextPosition = obj_
            obj_.original_tagname_ = 'nextPosition'
        elif nodeName_ == 'position':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <position> element')
            self.position = obj_
            obj_.original_tagname_ = 'position'
        elif nodeName_ == 'track':
            obj_ = DirectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.track = obj_
            obj_.original_tagname_ = 'track'
        super(AircraftPositionType, self).buildChildren(child_, node, nodeName_, True)
# end class AircraftPositionType


class PlannedReportingPositionType(GeneratedsSuper):
    """.Aircraft Planned Reporting Position: Estimated future position,
    altitude and time
    of the aircraft transmitted in a non-radar airspace position report.
    Estimated time associated with the planned reporting position.
    .Next Future Reporting Position Time - Estimated: Estimated time at the
    next future
    position of the aircraft transmitted in a non-radar airspace position
    report.
    .Following Future Reporting Position Time - Estimated: Estimated time at
    the second
    future position of the aircraft transmitted in a non-radar airspace
    position report."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, positionEstimatedTime=None, position=None, positionAltitude=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.positionEstimatedTime = _cast(None, positionEstimatedTime)
        self.positionEstimatedTime_nsprefix_ = None
        self.position = position
        self.position_nsprefix_ = None
        self.positionAltitude = positionAltitude
        self.positionAltitude_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlannedReportingPositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlannedReportingPositionType.subclass:
            return PlannedReportingPositionType.subclass(*args_, **kwargs_)
        else:
            return PlannedReportingPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def set_position_with_type(self, value):
        self.position = value
        value.original_tagname_ = 'position'
        value.extensiontype_ = value.__class__.__name__
    def get_positionAltitude(self):
        return self.positionAltitude
    def set_positionAltitude(self, positionAltitude):
        self.positionAltitude = positionAltitude
    def get_positionEstimatedTime(self):
        return self.positionEstimatedTime
    def set_positionEstimatedTime(self, positionEstimatedTime):
        self.positionEstimatedTime = positionEstimatedTime
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.position is not None or
            self.positionAltitude is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='PlannedReportingPositionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PlannedReportingPositionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PlannedReportingPositionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PlannedReportingPositionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='PlannedReportingPositionType'):
        if self.positionEstimatedTime is not None and 'positionEstimatedTime' not in already_processed:
            already_processed.add('positionEstimatedTime')
            outfile.write(' positionEstimatedTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.positionEstimatedTime), input_name='positionEstimatedTime')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='PlannedReportingPositionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.position is not None:
            self.position.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.positionAltitude is not None:
            namespaceprefix_ = self.positionAltitude_nsprefix_ + ':' if (UseCapturedNS_ and self.positionAltitude_nsprefix_) else ''
            self.positionAltitude.export(outfile, level, namespaceprefix_, namespacedef_='', name_='positionAltitude', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('positionEstimatedTime', node)
        if value is not None and 'positionEstimatedTime' not in already_processed:
            already_processed.add('positionEstimatedTime')
            try:
                self.positionEstimatedTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (positionEstimatedTime): %s' % exp)
            self.validate_TimeType(self.positionEstimatedTime)    # validate type TimeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'position':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <position> element')
            self.position = obj_
            obj_.original_tagname_ = 'position'
        elif nodeName_ == 'positionAltitude':
            class_obj_ = self.get_class_obj_(child_, AltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.positionAltitude = obj_
            obj_.original_tagname_ = 'positionAltitude'
# end class PlannedReportingPositionType


class AircraftOperatorType(GeneratedsSuper):
    """Contains information about the identify of aircraft operator.
    .Flight Plan Filer: The name of the unit, agency or person filing the
    flight plan.
    .Flight Operator Category: The category of the flight operator operating
    the flight."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, operatorCategory=None, operatingOrganization=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.operatorCategory = _cast(None, operatorCategory)
        self.operatorCategory_nsprefix_ = None
        self.operatingOrganization = operatingOrganization
        self.operatingOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AircraftOperatorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AircraftOperatorType.subclass:
            return AircraftOperatorType.subclass(*args_, **kwargs_)
        else:
            return AircraftOperatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operatingOrganization(self):
        return self.operatingOrganization
    def set_operatingOrganization(self, operatingOrganization):
        self.operatingOrganization = operatingOrganization
    def get_operatorCategory(self):
        return self.operatorCategory
    def set_operatorCategory(self, operatorCategory):
        self.operatorCategory = operatorCategory
    def validate_OperatorCategoryType(self, value):
        # Validate type fx:OperatorCategoryType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AIR_CARRIER', 'FREIGHT_CARGO_CARRIER', 'GENERAL_AVIATION', 'MILITARY', 'AIR_TAXI', 'OTHER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OperatorCategoryType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.operatingOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='AircraftOperatorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AircraftOperatorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AircraftOperatorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AircraftOperatorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='AircraftOperatorType'):
        if self.operatorCategory is not None and 'operatorCategory' not in already_processed:
            already_processed.add('operatorCategory')
            outfile.write(' operatorCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.operatorCategory), input_name='operatorCategory')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='AircraftOperatorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.operatingOrganization is not None:
            namespaceprefix_ = self.operatingOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.operatingOrganization_nsprefix_) else ''
            self.operatingOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='operatingOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operatorCategory', node)
        if value is not None and 'operatorCategory' not in already_processed:
            already_processed.add('operatorCategory')
            self.operatorCategory = value
            self.validate_OperatorCategoryType(self.operatorCategory)    # validate type OperatorCategoryType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'operatingOrganization':
            obj_ = PersonOrOrganizationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.operatingOrganization = obj_
            obj_.original_tagname_ = 'operatingOrganization'
# end class AircraftOperatorType


class EnRouteDiversionType(GeneratedsSuper):
    """Contains information about the En Route Diversion of the flight such as
    diversion
    recovery."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, diversionRecoveryInformation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.diversionRecoveryInformation = diversionRecoveryInformation
        self.diversionRecoveryInformation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnRouteDiversionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnRouteDiversionType.subclass:
            return EnRouteDiversionType.subclass(*args_, **kwargs_)
        else:
            return EnRouteDiversionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_diversionRecoveryInformation(self):
        return self.diversionRecoveryInformation
    def set_diversionRecoveryInformation(self, diversionRecoveryInformation):
        self.diversionRecoveryInformation = diversionRecoveryInformation
    def hasContent_(self):
        if (
            self.diversionRecoveryInformation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='EnRouteDiversionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnRouteDiversionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnRouteDiversionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EnRouteDiversionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='EnRouteDiversionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='EnRouteDiversionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.diversionRecoveryInformation is not None:
            namespaceprefix_ = self.diversionRecoveryInformation_nsprefix_ + ':' if (UseCapturedNS_ and self.diversionRecoveryInformation_nsprefix_) else ''
            self.diversionRecoveryInformation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='diversionRecoveryInformation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'diversionRecoveryInformation':
            obj_ = GloballyUniqueFlightIdentifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.diversionRecoveryInformation = obj_
            obj_.original_tagname_ = 'diversionRecoveryInformation'
# end class EnRouteDiversionType


class FlightType(FeatureType):
    """Central object of the FIXM Logical Model. Groups all information about
    the flight.
    .Flight Information Filer: The name of the unit, agency or person filing
    the flight
    plan.
    .Flight Type: Indication of the rule under which an air traffic controller
    provides
    categorical handling of a flight.
    .Remarks: Plain language remarks providing additional information about the
    flight
    (e.g., requested flight level changes after takeoff)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FeatureType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, flightFiler=None, flightType=None, remarks=None, agreed=None, aircraftDescription=None, arrival=None, controllingUnit=None, dangerousGoods=None, departure=None, emergency=None, enRoute=None, enRouteDiversion=None, extensions=None, flightIdentification=None, flightStatus=None, gufi=None, negotiating=None, operator=None, originator=None, radioCommunicationFailure=None, rankedTrajectories=None, routeToRevisedDestination=None, specialHandling=None, supplementalData=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FlightType, self).__init__(centre, source, system, timestamp, extensiontype_,  **kwargs_)
        self.flightFiler = _cast(None, flightFiler)
        self.flightFiler_nsprefix_ = None
        self.flightType = _cast(None, flightType)
        self.flightType_nsprefix_ = None
        self.remarks = _cast(None, remarks)
        self.remarks_nsprefix_ = None
        self.agreed = agreed
        self.agreed_nsprefix_ = None
        self.aircraftDescription = aircraftDescription
        self.aircraftDescription_nsprefix_ = None
        self.arrival = arrival
        self.arrival_nsprefix_ = None
        self.controllingUnit = controllingUnit
        self.controllingUnit_nsprefix_ = None
        if dangerousGoods is None:
            self.dangerousGoods = []
        else:
            self.dangerousGoods = dangerousGoods
        self.dangerousGoods_nsprefix_ = None
        self.departure = departure
        self.departure_nsprefix_ = None
        self.emergency = emergency
        self.emergency_nsprefix_ = None
        self.enRoute = enRoute
        self.enRoute_nsprefix_ = None
        self.enRouteDiversion = enRouteDiversion
        self.enRouteDiversion_nsprefix_ = None
        if extensions is None:
            self.extensions = []
        else:
            self.extensions = extensions
        self.extensions_nsprefix_ = None
        self.flightIdentification = flightIdentification
        self.flightIdentification_nsprefix_ = None
        self.flightStatus = flightStatus
        self.flightStatus_nsprefix_ = None
        self.gufi = gufi
        self.gufi_nsprefix_ = None
        self.negotiating = negotiating
        self.negotiating_nsprefix_ = None
        self.operator = operator
        self.operator_nsprefix_ = None
        self.originator = originator
        self.originator_nsprefix_ = None
        self.radioCommunicationFailure = radioCommunicationFailure
        self.radioCommunicationFailure_nsprefix_ = None
        if rankedTrajectories is None:
            self.rankedTrajectories = []
        else:
            self.rankedTrajectories = rankedTrajectories
        self.rankedTrajectories_nsprefix_ = None
        self.routeToRevisedDestination = routeToRevisedDestination
        self.routeToRevisedDestination_nsprefix_ = None
        self.specialHandling = specialHandling
        self.validate_specialHandlingType(self.specialHandling)
        self.specialHandling_nsprefix_ = None
        self.supplementalData = supplementalData
        self.supplementalData_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlightType.subclass:
            return FlightType.subclass(*args_, **kwargs_)
        else:
            return FlightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_agreed(self):
        return self.agreed
    def set_agreed(self, agreed):
        self.agreed = agreed
    def get_aircraftDescription(self):
        return self.aircraftDescription
    def set_aircraftDescription(self, aircraftDescription):
        self.aircraftDescription = aircraftDescription
    def get_arrival(self):
        return self.arrival
    def set_arrival(self, arrival):
        self.arrival = arrival
    def get_controllingUnit(self):
        return self.controllingUnit
    def set_controllingUnit(self, controllingUnit):
        self.controllingUnit = controllingUnit
    def set_controllingUnit_with_type(self, value):
        self.controllingUnit = value
        value.original_tagname_ = 'controllingUnit'
        value.extensiontype_ = value.__class__.__name__
    def get_dangerousGoods(self):
        return self.dangerousGoods
    def set_dangerousGoods(self, dangerousGoods):
        self.dangerousGoods = dangerousGoods
    def add_dangerousGoods(self, value):
        self.dangerousGoods.append(value)
    def insert_dangerousGoods_at(self, index, value):
        self.dangerousGoods.insert(index, value)
    def replace_dangerousGoods_at(self, index, value):
        self.dangerousGoods[index] = value
    def get_departure(self):
        return self.departure
    def set_departure(self, departure):
        self.departure = departure
    def get_emergency(self):
        return self.emergency
    def set_emergency(self, emergency):
        self.emergency = emergency
    def get_enRoute(self):
        return self.enRoute
    def set_enRoute(self, enRoute):
        self.enRoute = enRoute
    def get_enRouteDiversion(self):
        return self.enRouteDiversion
    def set_enRouteDiversion(self, enRouteDiversion):
        self.enRouteDiversion = enRouteDiversion
    def get_extensions(self):
        return self.extensions
    def set_extensions(self, extensions):
        self.extensions = extensions
    def add_extensions(self, value):
        self.extensions.append(value)
    def insert_extensions_at(self, index, value):
        self.extensions.insert(index, value)
    def replace_extensions_at(self, index, value):
        self.extensions[index] = value
    def get_flightIdentification(self):
        return self.flightIdentification
    def set_flightIdentification(self, flightIdentification):
        self.flightIdentification = flightIdentification
    def get_flightStatus(self):
        return self.flightStatus
    def set_flightStatus(self, flightStatus):
        self.flightStatus = flightStatus
    def get_gufi(self):
        return self.gufi
    def set_gufi(self, gufi):
        self.gufi = gufi
    def get_negotiating(self):
        return self.negotiating
    def set_negotiating(self, negotiating):
        self.negotiating = negotiating
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_originator(self):
        return self.originator
    def set_originator(self, originator):
        self.originator = originator
    def get_radioCommunicationFailure(self):
        return self.radioCommunicationFailure
    def set_radioCommunicationFailure(self, radioCommunicationFailure):
        self.radioCommunicationFailure = radioCommunicationFailure
    def get_rankedTrajectories(self):
        return self.rankedTrajectories
    def set_rankedTrajectories(self, rankedTrajectories):
        self.rankedTrajectories = rankedTrajectories
    def add_rankedTrajectories(self, value):
        self.rankedTrajectories.append(value)
    def insert_rankedTrajectories_at(self, index, value):
        self.rankedTrajectories.insert(index, value)
    def replace_rankedTrajectories_at(self, index, value):
        self.rankedTrajectories[index] = value
    def get_routeToRevisedDestination(self):
        return self.routeToRevisedDestination
    def set_routeToRevisedDestination(self, routeToRevisedDestination):
        self.routeToRevisedDestination = routeToRevisedDestination
    def get_specialHandling(self):
        return self.specialHandling
    def set_specialHandling(self, specialHandling):
        self.specialHandling = specialHandling
    def get_supplementalData(self):
        return self.supplementalData
    def set_supplementalData(self, supplementalData):
        self.supplementalData = supplementalData
    def get_flightFiler(self):
        return self.flightFiler
    def set_flightFiler(self, flightFiler):
        self.flightFiler = flightFiler
    def get_flightType(self):
        return self.flightType
    def set_flightType(self, flightType):
        self.flightType = flightType
    def get_remarks(self):
        return self.remarks
    def set_remarks(self, remarks):
        self.remarks = remarks
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_specialHandlingType(self, value):
        result = True
        # Validate type specialHandlingType, a restriction on fx:SpecialHandlingCodeType.
        pass
        return result
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_TypeOfFlightType(self, value):
        # Validate type fx:TypeOfFlightType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MILITARY', 'GENERAL', 'NON_SCHEDULED', 'SCHEDULED', 'OTHER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TypeOfFlightType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.agreed is not None or
            self.aircraftDescription is not None or
            self.arrival is not None or
            self.controllingUnit is not None or
            self.dangerousGoods or
            self.departure is not None or
            self.emergency is not None or
            self.enRoute is not None or
            self.enRouteDiversion is not None or
            self.extensions or
            self.flightIdentification is not None or
            self.flightStatus is not None or
            self.gufi is not None or
            self.negotiating is not None or
            self.operator is not None or
            self.originator is not None or
            self.radioCommunicationFailure is not None or
            self.rankedTrajectories or
            self.routeToRevisedDestination is not None or
            self.specialHandling is not None or
            self.supplementalData is not None or
            super(FlightType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='FlightType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlightType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlightType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlightType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='FlightType'):
        super(FlightType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlightType')
        if self.flightFiler is not None and 'flightFiler' not in already_processed:
            already_processed.add('flightFiler')
            outfile.write(' flightFiler=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.flightFiler), input_name='flightFiler')), ))
        if self.flightType is not None and 'flightType' not in already_processed:
            already_processed.add('flightType')
            outfile.write(' flightType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.flightType), input_name='flightType')), ))
        if self.remarks is not None and 'remarks' not in already_processed:
            already_processed.add('remarks')
            outfile.write(' remarks=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.remarks), input_name='remarks')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='FlightType', fromsubclass_=False, pretty_print=True):
        super(FlightType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.agreed is not None:
            namespaceprefix_ = self.agreed_nsprefix_ + ':' if (UseCapturedNS_ and self.agreed_nsprefix_) else ''
            self.agreed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='agreed', pretty_print=pretty_print)
        if self.aircraftDescription is not None:
            namespaceprefix_ = self.aircraftDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.aircraftDescription_nsprefix_) else ''
            self.aircraftDescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='aircraftDescription', pretty_print=pretty_print)
        if self.arrival is not None:
            namespaceprefix_ = self.arrival_nsprefix_ + ':' if (UseCapturedNS_ and self.arrival_nsprefix_) else ''
            self.arrival.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arrival', pretty_print=pretty_print)
        if self.controllingUnit is not None:
            self.controllingUnit.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        for dangerousGoods_ in self.dangerousGoods:
            namespaceprefix_ = self.dangerousGoods_nsprefix_ + ':' if (UseCapturedNS_ and self.dangerousGoods_nsprefix_) else ''
            dangerousGoods_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dangerousGoods', pretty_print=pretty_print)
        if self.departure is not None:
            namespaceprefix_ = self.departure_nsprefix_ + ':' if (UseCapturedNS_ and self.departure_nsprefix_) else ''
            self.departure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='departure', pretty_print=pretty_print)
        if self.emergency is not None:
            namespaceprefix_ = self.emergency_nsprefix_ + ':' if (UseCapturedNS_ and self.emergency_nsprefix_) else ''
            self.emergency.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emergency', pretty_print=pretty_print)
        if self.enRoute is not None:
            namespaceprefix_ = self.enRoute_nsprefix_ + ':' if (UseCapturedNS_ and self.enRoute_nsprefix_) else ''
            self.enRoute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enRoute', pretty_print=pretty_print)
        if self.enRouteDiversion is not None:
            namespaceprefix_ = self.enRouteDiversion_nsprefix_ + ':' if (UseCapturedNS_ and self.enRouteDiversion_nsprefix_) else ''
            self.enRouteDiversion.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enRouteDiversion', pretty_print=pretty_print)
        for extensions_ in self.extensions:
            namespaceprefix_ = self.extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.extensions_nsprefix_) else ''
            extensions_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extensions', pretty_print=pretty_print)
        if self.flightIdentification is not None:
            namespaceprefix_ = self.flightIdentification_nsprefix_ + ':' if (UseCapturedNS_ and self.flightIdentification_nsprefix_) else ''
            self.flightIdentification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='flightIdentification', pretty_print=pretty_print)
        if self.flightStatus is not None:
            namespaceprefix_ = self.flightStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.flightStatus_nsprefix_) else ''
            self.flightStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='flightStatus', pretty_print=pretty_print)
        if self.gufi is not None:
            namespaceprefix_ = self.gufi_nsprefix_ + ':' if (UseCapturedNS_ and self.gufi_nsprefix_) else ''
            self.gufi.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gufi', pretty_print=pretty_print)
        if self.negotiating is not None:
            namespaceprefix_ = self.negotiating_nsprefix_ + ':' if (UseCapturedNS_ and self.negotiating_nsprefix_) else ''
            self.negotiating.export(outfile, level, namespaceprefix_, namespacedef_='', name_='negotiating', pretty_print=pretty_print)
        if self.operator is not None:
            namespaceprefix_ = self.operator_nsprefix_ + ':' if (UseCapturedNS_ and self.operator_nsprefix_) else ''
            self.operator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='operator', pretty_print=pretty_print)
        if self.originator is not None:
            namespaceprefix_ = self.originator_nsprefix_ + ':' if (UseCapturedNS_ and self.originator_nsprefix_) else ''
            self.originator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='originator', pretty_print=pretty_print)
        if self.radioCommunicationFailure is not None:
            namespaceprefix_ = self.radioCommunicationFailure_nsprefix_ + ':' if (UseCapturedNS_ and self.radioCommunicationFailure_nsprefix_) else ''
            self.radioCommunicationFailure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='radioCommunicationFailure', pretty_print=pretty_print)
        for rankedTrajectories_ in self.rankedTrajectories:
            namespaceprefix_ = self.rankedTrajectories_nsprefix_ + ':' if (UseCapturedNS_ and self.rankedTrajectories_nsprefix_) else ''
            rankedTrajectories_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rankedTrajectories', pretty_print=pretty_print)
        if self.routeToRevisedDestination is not None:
            namespaceprefix_ = self.routeToRevisedDestination_nsprefix_ + ':' if (UseCapturedNS_ and self.routeToRevisedDestination_nsprefix_) else ''
            self.routeToRevisedDestination.export(outfile, level, namespaceprefix_, namespacedef_='', name_='routeToRevisedDestination', pretty_print=pretty_print)
        if self.specialHandling is not None:
            namespaceprefix_ = self.specialHandling_nsprefix_ + ':' if (UseCapturedNS_ and self.specialHandling_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sspecialHandling>%s</%sspecialHandling>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(' '.join(self.specialHandling)), input_name='specialHandling')), namespaceprefix_ , eol_))
        if self.supplementalData is not None:
            namespaceprefix_ = self.supplementalData_nsprefix_ + ':' if (UseCapturedNS_ and self.supplementalData_nsprefix_) else ''
            self.supplementalData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='supplementalData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('flightFiler', node)
        if value is not None and 'flightFiler' not in already_processed:
            already_processed.add('flightFiler')
            self.flightFiler = value
            self.validate_FreeTextType(self.flightFiler)    # validate type FreeTextType
        value = find_attr_value_('flightType', node)
        if value is not None and 'flightType' not in already_processed:
            already_processed.add('flightType')
            self.flightType = value
            self.validate_TypeOfFlightType(self.flightType)    # validate type TypeOfFlightType
        value = find_attr_value_('remarks', node)
        if value is not None and 'remarks' not in already_processed:
            already_processed.add('remarks')
            self.remarks = value
            self.validate_FreeTextType(self.remarks)    # validate type FreeTextType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(FlightType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'agreed':
            obj_ = TrajectoryRoutePairType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.agreed = obj_
            obj_.original_tagname_ = 'agreed'
        elif nodeName_ == 'aircraftDescription':
            obj_ = AircraftTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.aircraftDescription = obj_
            obj_.original_tagname_ = 'aircraftDescription'
        elif nodeName_ == 'arrival':
            class_obj_ = self.get_class_obj_(child_, FlightArrivalType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arrival = obj_
            obj_.original_tagname_ = 'arrival'
        elif nodeName_ == 'controllingUnit':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <controllingUnit> element')
            self.controllingUnit = obj_
            obj_.original_tagname_ = 'controllingUnit'
        elif nodeName_ == 'dangerousGoods':
            obj_ = DangerousGoodsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dangerousGoods.append(obj_)
            obj_.original_tagname_ = 'dangerousGoods'
        elif nodeName_ == 'departure':
            class_obj_ = self.get_class_obj_(child_, FlightDepartureType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departure = obj_
            obj_.original_tagname_ = 'departure'
        elif nodeName_ == 'emergency':
            obj_ = FlightEmergencyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.emergency = obj_
            obj_.original_tagname_ = 'emergency'
        elif nodeName_ == 'enRoute':
            class_obj_ = self.get_class_obj_(child_, EnRouteType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enRoute = obj_
            obj_.original_tagname_ = 'enRoute'
        elif nodeName_ == 'enRouteDiversion':
            obj_ = EnRouteDiversionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enRouteDiversion = obj_
            obj_.original_tagname_ = 'enRouteDiversion'
        elif nodeName_ == 'extensions':
            obj_ = ExtensionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extensions.append(obj_)
            obj_.original_tagname_ = 'extensions'
        elif nodeName_ == 'flightIdentification':
            class_obj_ = self.get_class_obj_(child_, FlightIdentificationType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.flightIdentification = obj_
            obj_.original_tagname_ = 'flightIdentification'
        elif nodeName_ == 'flightStatus':
            class_obj_ = self.get_class_obj_(child_, FlightStatusType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.flightStatus = obj_
            obj_.original_tagname_ = 'flightStatus'
        elif nodeName_ == 'gufi':
            obj_ = GloballyUniqueFlightIdentifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gufi = obj_
            obj_.original_tagname_ = 'gufi'
        elif nodeName_ == 'negotiating':
            obj_ = TrajectoryRoutePairType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.negotiating = obj_
            obj_.original_tagname_ = 'negotiating'
        elif nodeName_ == 'operator':
            obj_ = AircraftOperatorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.operator = obj_
            obj_.original_tagname_ = 'operator'
        elif nodeName_ == 'originator':
            obj_ = OriginatorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.originator = obj_
            obj_.original_tagname_ = 'originator'
        elif nodeName_ == 'radioCommunicationFailure':
            obj_ = RadioCommunicationFailureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.radioCommunicationFailure = obj_
            obj_.original_tagname_ = 'radioCommunicationFailure'
        elif nodeName_ == 'rankedTrajectories':
            class_obj_ = self.get_class_obj_(child_, RankedTrajectoryType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rankedTrajectories.append(obj_)
            obj_.original_tagname_ = 'rankedTrajectories'
        elif nodeName_ == 'routeToRevisedDestination':
            obj_ = TrajectoryRoutePairType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.routeToRevisedDestination = obj_
            obj_.original_tagname_ = 'routeToRevisedDestination'
        elif nodeName_ == 'specialHandling':
            value_ = child_.text
            self.specialHandling = value_
            self.specialHandling_nsprefix_ = child_.prefix
            # validate type specialHandlingType
            self.validate_specialHandlingType(self.specialHandling)
        elif nodeName_ == 'supplementalData':
            class_obj_ = self.get_class_obj_(child_, SupplementalDataType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supplementalData = obj_
            obj_.original_tagname_ = 'supplementalData'
        super(FlightType, self).buildChildren(child_, node, nodeName_, True)
# end class FlightType


class FlightIdentificationType(GeneratedsSuper):
    """Groups flight identifying data such as the aircraft and carrier
    information.
    .Aircraft Identification: Name used by Air Traffic Services units to
    identify and
    communicate with an aircraft.
    .Major Carrier Identifier: The identification of the carrier who has
    contracted out
    the operation of the flight to a sub-carrier."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, aircraftIdentification=None, majorCarrierIdentifier=None, marketingCarrierFlightIdentifier=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.aircraftIdentification = _cast(None, aircraftIdentification)
        self.aircraftIdentification_nsprefix_ = None
        self.majorCarrierIdentifier = _cast(None, majorCarrierIdentifier)
        self.majorCarrierIdentifier_nsprefix_ = None
        self.marketingCarrierFlightIdentifier = marketingCarrierFlightIdentifier
        self.validate_marketingCarrierFlightIdentifierType(self.marketingCarrierFlightIdentifier)
        self.marketingCarrierFlightIdentifier_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlightIdentificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlightIdentificationType.subclass:
            return FlightIdentificationType.subclass(*args_, **kwargs_)
        else:
            return FlightIdentificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_marketingCarrierFlightIdentifier(self):
        return self.marketingCarrierFlightIdentifier
    def set_marketingCarrierFlightIdentifier(self, marketingCarrierFlightIdentifier):
        self.marketingCarrierFlightIdentifier = marketingCarrierFlightIdentifier
    def get_aircraftIdentification(self):
        return self.aircraftIdentification
    def set_aircraftIdentification(self, aircraftIdentification):
        self.aircraftIdentification = aircraftIdentification
    def get_majorCarrierIdentifier(self):
        return self.majorCarrierIdentifier
    def set_majorCarrierIdentifier(self, majorCarrierIdentifier):
        self.majorCarrierIdentifier = majorCarrierIdentifier
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_marketingCarrierFlightIdentifierType(self, value):
        result = True
        # Validate type marketingCarrierFlightIdentifierType, a restriction on fb:FlightIdentifierType.
        pass
        return result
    def validate_FlightIdentifierType(self, value):
        # Validate type fb:FlightIdentifierType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_FlightIdentifierType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_FlightIdentifierType_patterns_, ))
    validate_FlightIdentifierType_patterns_ = [['^([A-Z0-9]{1,7})$']]
    def validate_CarrierIdentifierType(self, value):
        # Validate type fb:CarrierIdentifierType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CarrierIdentifierType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CarrierIdentifierType_patterns_, ))
    validate_CarrierIdentifierType_patterns_ = [['^([A-Z]{3})$']]
    def hasContent_(self):
        if (
            self.marketingCarrierFlightIdentifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='FlightIdentificationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlightIdentificationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlightIdentificationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlightIdentificationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='FlightIdentificationType'):
        if self.aircraftIdentification is not None and 'aircraftIdentification' not in already_processed:
            already_processed.add('aircraftIdentification')
            outfile.write(' aircraftIdentification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aircraftIdentification), input_name='aircraftIdentification')), ))
        if self.majorCarrierIdentifier is not None and 'majorCarrierIdentifier' not in already_processed:
            already_processed.add('majorCarrierIdentifier')
            outfile.write(' majorCarrierIdentifier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.majorCarrierIdentifier), input_name='majorCarrierIdentifier')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='FlightIdentificationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.marketingCarrierFlightIdentifier is not None:
            namespaceprefix_ = self.marketingCarrierFlightIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.marketingCarrierFlightIdentifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smarketingCarrierFlightIdentifier>%s</%smarketingCarrierFlightIdentifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(' '.join(self.marketingCarrierFlightIdentifier)), input_name='marketingCarrierFlightIdentifier')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aircraftIdentification', node)
        if value is not None and 'aircraftIdentification' not in already_processed:
            already_processed.add('aircraftIdentification')
            self.aircraftIdentification = value
            self.validate_FlightIdentifierType(self.aircraftIdentification)    # validate type FlightIdentifierType
        value = find_attr_value_('majorCarrierIdentifier', node)
        if value is not None and 'majorCarrierIdentifier' not in already_processed:
            already_processed.add('majorCarrierIdentifier')
            self.majorCarrierIdentifier = value
            self.validate_CarrierIdentifierType(self.majorCarrierIdentifier)    # validate type CarrierIdentifierType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'marketingCarrierFlightIdentifier':
            value_ = child_.text
            self.marketingCarrierFlightIdentifier = value_
            self.marketingCarrierFlightIdentifier_nsprefix_ = child_.prefix
            # validate type marketingCarrierFlightIdentifierType
            self.validate_marketingCarrierFlightIdentifierType(self.marketingCarrierFlightIdentifier)
# end class FlightIdentificationType


class OriginatorType(GeneratedsSuper):
    """.Flight Plan Originator: The originator's eight-letter AFTN address, or
    other appropriate
    contact details, in cases where the originator of the flight plan may not
    be readily
    identified."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, aftnAddress=None, flightOriginator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.aftnAddress = aftnAddress
        self.validate_AftnAddressType(self.aftnAddress)
        self.aftnAddress_nsprefix_ = None
        self.flightOriginator = flightOriginator
        self.validate_FreeTextType(self.flightOriginator)
        self.flightOriginator_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OriginatorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OriginatorType.subclass:
            return OriginatorType.subclass(*args_, **kwargs_)
        else:
            return OriginatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_aftnAddress(self):
        return self.aftnAddress
    def set_aftnAddress(self, aftnAddress):
        self.aftnAddress = aftnAddress
    def get_flightOriginator(self):
        return self.flightOriginator
    def set_flightOriginator(self, flightOriginator):
        self.flightOriginator = flightOriginator
    def validate_AftnAddressType(self, value):
        result = True
        # Validate type AftnAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_FreeTextType(self, value):
        result = True
        # Validate type FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.aftnAddress is not None or
            self.flightOriginator is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='OriginatorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OriginatorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OriginatorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OriginatorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='OriginatorType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='OriginatorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.aftnAddress is not None:
            namespaceprefix_ = self.aftnAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.aftnAddress_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saftnAddress>%s</%saftnAddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.aftnAddress), input_name='aftnAddress')), namespaceprefix_ , eol_))
        if self.flightOriginator is not None:
            namespaceprefix_ = self.flightOriginator_nsprefix_ + ':' if (UseCapturedNS_ and self.flightOriginator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sflightOriginator>%s</%sflightOriginator>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.flightOriginator), input_name='flightOriginator')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'aftnAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'aftnAddress')
            value_ = self.gds_validate_string(value_, node, 'aftnAddress')
            self.aftnAddress = value_
            self.aftnAddress_nsprefix_ = child_.prefix
            # validate type AftnAddressType
            self.validate_AftnAddressType(self.aftnAddress)
        elif nodeName_ == 'flightOriginator':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'flightOriginator')
            value_ = self.gds_validate_string(value_, node, 'flightOriginator')
            self.flightOriginator = value_
            self.flightOriginator_nsprefix_ = child_.prefix
            # validate type FreeTextType
            self.validate_FreeTextType(self.flightOriginator)
# end class OriginatorType


class SupplementalDataType(GeneratedsSuper):
    """Contains the supplemental data about the flight.
    .Fuel Endurance: The estimated maximum length of time the aircraft can
    spend in the
    cruise phase of flight, determined by the amount of fuel at takeoff.
    .Number of Persons on Board: The total number of persons (passengers and
    crew) on
    board the aircraft."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, fuelEndurance=None, personsOnBoard=None, pilotInCommand=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fuelEndurance = _cast(None, fuelEndurance)
        self.fuelEndurance_nsprefix_ = None
        self.personsOnBoard = _cast(None, personsOnBoard)
        self.personsOnBoard_nsprefix_ = None
        self.pilotInCommand = pilotInCommand
        self.pilotInCommand_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupplementalDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupplementalDataType.subclass:
            return SupplementalDataType.subclass(*args_, **kwargs_)
        else:
            return SupplementalDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_pilotInCommand(self):
        return self.pilotInCommand
    def set_pilotInCommand(self, pilotInCommand):
        self.pilotInCommand = pilotInCommand
    def get_fuelEndurance(self):
        return self.fuelEndurance
    def set_fuelEndurance(self, fuelEndurance):
        self.fuelEndurance = fuelEndurance
    def get_personsOnBoard(self):
        return self.personsOnBoard
    def set_personsOnBoard(self, personsOnBoard):
        self.personsOnBoard = personsOnBoard
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_DurationType(self, value):
        # Validate type ff:DurationType, a restriction on xs:duration.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_CountType(self, value):
        # Validate type fb:CountType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on CountType' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.pilotInCommand is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='SupplementalDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupplementalDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupplementalDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupplementalDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='SupplementalDataType'):
        if self.fuelEndurance is not None and 'fuelEndurance' not in already_processed:
            already_processed.add('fuelEndurance')
            outfile.write(' fuelEndurance=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fuelEndurance), input_name='fuelEndurance')), ))
        if self.personsOnBoard is not None and 'personsOnBoard' not in already_processed:
            already_processed.add('personsOnBoard')
            outfile.write(' personsOnBoard="%s"' % self.gds_format_integer(self.personsOnBoard, input_name='personsOnBoard'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='SupplementalDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pilotInCommand is not None:
            namespaceprefix_ = self.pilotInCommand_nsprefix_ + ':' if (UseCapturedNS_ and self.pilotInCommand_nsprefix_) else ''
            self.pilotInCommand.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pilotInCommand', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fuelEndurance', node)
        if value is not None and 'fuelEndurance' not in already_processed:
            already_processed.add('fuelEndurance')
            self.fuelEndurance = value
            self.validate_DurationType(self.fuelEndurance)    # validate type DurationType
        value = find_attr_value_('personsOnBoard', node)
        if value is not None and 'personsOnBoard' not in already_processed:
            already_processed.add('personsOnBoard')
            self.personsOnBoard = self.gds_parse_integer(value, node, 'personsOnBoard')
            self.validate_CountType(self.personsOnBoard)    # validate type CountType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'pilotInCommand':
            obj_ = PersonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pilotInCommand = obj_
            obj_.original_tagname_ = 'pilotInCommand'
# end class SupplementalDataType


class RankedTrajectoryType(GeneratedsSuper):
    """.Ranked 4D Route: This is the route associated with a single Ranked 4D
    trajectory
    for a flight. It indicates the intent of the flight and includes the path
    over the
    surface of the earth, the altitude and the speed for the flight.
    .Ranked 4D Trajectory: A series of desired 4D trajectories, with tolerances
    supplied
    if necessary by the airspace user to define when the next ranked trajectory
    should
    be used.
    .Ranked 4D Trajectory Assignment Status: An indication whether the Ranked
    4D trajectory
    has been assigned by the Air Navigation Service Provider (ANSP).
    Unique Identifier used to differentiate the 4D trajectories.
    .Ranked 4D Trajectory Identifier: Unique Identifier used to differentiate
    the 4D
    trajectories.
    .Ranked 4D Trajectory Maximum Acceptable Delay: The maximum acceptable
    delay the
    flight could incur for the Ranked 4D trajectory, if this were the assigned
    4D trajectory."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, assignedIndicator=None, identifier=None, maximumAcceptableDelay=None, routeTrajectoryPair=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.assignedIndicator = _cast(None, assignedIndicator)
        self.assignedIndicator_nsprefix_ = None
        self.identifier = _cast(None, identifier)
        self.identifier_nsprefix_ = None
        self.maximumAcceptableDelay = _cast(None, maximumAcceptableDelay)
        self.maximumAcceptableDelay_nsprefix_ = None
        self.routeTrajectoryPair = routeTrajectoryPair
        self.routeTrajectoryPair_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RankedTrajectoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RankedTrajectoryType.subclass:
            return RankedTrajectoryType.subclass(*args_, **kwargs_)
        else:
            return RankedTrajectoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_routeTrajectoryPair(self):
        return self.routeTrajectoryPair
    def set_routeTrajectoryPair(self, routeTrajectoryPair):
        self.routeTrajectoryPair = routeTrajectoryPair
    def get_assignedIndicator(self):
        return self.assignedIndicator
    def set_assignedIndicator(self, assignedIndicator):
        self.assignedIndicator = assignedIndicator
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def get_maximumAcceptableDelay(self):
        return self.maximumAcceptableDelay
    def set_maximumAcceptableDelay(self, maximumAcceptableDelay):
        self.maximumAcceptableDelay = maximumAcceptableDelay
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_AssignedIndicatorType(self, value):
        # Validate type fx:AssignedIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASSIGNED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AssignedIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_CountType(self, value):
        # Validate type fb:CountType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on CountType' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.routeTrajectoryPair is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='RankedTrajectoryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RankedTrajectoryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RankedTrajectoryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RankedTrajectoryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='RankedTrajectoryType'):
        if self.assignedIndicator is not None and 'assignedIndicator' not in already_processed:
            already_processed.add('assignedIndicator')
            outfile.write(' assignedIndicator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.assignedIndicator), input_name='assignedIndicator')), ))
        if self.identifier is not None and 'identifier' not in already_processed:
            already_processed.add('identifier')
            outfile.write(' identifier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.identifier), input_name='identifier')), ))
        if self.maximumAcceptableDelay is not None and 'maximumAcceptableDelay' not in already_processed:
            already_processed.add('maximumAcceptableDelay')
            outfile.write(' maximumAcceptableDelay="%s"' % self.gds_format_integer(self.maximumAcceptableDelay, input_name='maximumAcceptableDelay'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='RankedTrajectoryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routeTrajectoryPair is not None:
            namespaceprefix_ = self.routeTrajectoryPair_nsprefix_ + ':' if (UseCapturedNS_ and self.routeTrajectoryPair_nsprefix_) else ''
            self.routeTrajectoryPair.export(outfile, level, namespaceprefix_, namespacedef_='', name_='routeTrajectoryPair', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('assignedIndicator', node)
        if value is not None and 'assignedIndicator' not in already_processed:
            already_processed.add('assignedIndicator')
            self.assignedIndicator = value
            self.validate_AssignedIndicatorType(self.assignedIndicator)    # validate type AssignedIndicatorType
        value = find_attr_value_('identifier', node)
        if value is not None and 'identifier' not in already_processed:
            already_processed.add('identifier')
            self.identifier = value
            self.validate_FreeTextType(self.identifier)    # validate type FreeTextType
        value = find_attr_value_('maximumAcceptableDelay', node)
        if value is not None and 'maximumAcceptableDelay' not in already_processed:
            already_processed.add('maximumAcceptableDelay')
            self.maximumAcceptableDelay = self.gds_parse_integer(value, node, 'maximumAcceptableDelay')
            self.validate_CountType(self.maximumAcceptableDelay)    # validate type CountType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'routeTrajectoryPair':
            obj_ = TrajectoryRoutePairType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.routeTrajectoryPair = obj_
            obj_.original_tagname_ = 'routeTrajectoryPair'
# end class RankedTrajectoryType


class MeteorologicalDataType(GeneratedsSuper):
    """.Meteorological Data: In a predicted trajectory, the instantaneous
    temperature and
    wind vector used at the 4D Point for creating the 4D trajectory."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, temperature=None, windDirection=None, windSpeed=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.temperature = temperature
        self.temperature_nsprefix_ = None
        self.windDirection = windDirection
        self.windDirection_nsprefix_ = None
        self.windSpeed = windSpeed
        self.windSpeed_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeteorologicalDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeteorologicalDataType.subclass:
            return MeteorologicalDataType.subclass(*args_, **kwargs_)
        else:
            return MeteorologicalDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_temperature(self):
        return self.temperature
    def set_temperature(self, temperature):
        self.temperature = temperature
    def get_windDirection(self):
        return self.windDirection
    def set_windDirection(self, windDirection):
        self.windDirection = windDirection
    def get_windSpeed(self):
        return self.windSpeed
    def set_windSpeed(self, windSpeed):
        self.windSpeed = windSpeed
    def hasContent_(self):
        if (
            self.temperature is not None or
            self.windDirection is not None or
            self.windSpeed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='MeteorologicalDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeteorologicalDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeteorologicalDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeteorologicalDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='MeteorologicalDataType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='MeteorologicalDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.temperature is not None:
            namespaceprefix_ = self.temperature_nsprefix_ + ':' if (UseCapturedNS_ and self.temperature_nsprefix_) else ''
            self.temperature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='temperature', pretty_print=pretty_print)
        if self.windDirection is not None:
            namespaceprefix_ = self.windDirection_nsprefix_ + ':' if (UseCapturedNS_ and self.windDirection_nsprefix_) else ''
            self.windDirection.export(outfile, level, namespaceprefix_, namespacedef_='', name_='windDirection', pretty_print=pretty_print)
        if self.windSpeed is not None:
            namespaceprefix_ = self.windSpeed_nsprefix_ + ':' if (UseCapturedNS_ and self.windSpeed_nsprefix_) else ''
            self.windSpeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='windSpeed', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'temperature':
            obj_ = TemperatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.temperature = obj_
            obj_.original_tagname_ = 'temperature'
        elif nodeName_ == 'windDirection':
            obj_ = WindDirectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.windDirection = obj_
            obj_.original_tagname_ = 'windDirection'
        elif nodeName_ == 'windSpeed':
            obj_ = WindspeedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.windSpeed = obj_
            obj_.original_tagname_ = 'windSpeed'
# end class MeteorologicalDataType


class Point4DType(GeographicLocationType):
    """.4D Point: Identifies the location, altitude and time of a trajectory
    point.
    Time of the 4D point."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = GeographicLocationType
    def __init__(self, srsName='urn:ogc:def:crs:EPSG::4326', pos=None, time=None, altitude=None, pointRange=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Point4DType, self).__init__(srsName, pos,  **kwargs_)
        self.time = _cast(None, time)
        self.time_nsprefix_ = None
        self.altitude = altitude
        self.altitude_nsprefix_ = None
        self.pointRange = pointRange
        self.pointRange_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Point4DType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Point4DType.subclass:
            return Point4DType.subclass(*args_, **kwargs_)
        else:
            return Point4DType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_altitude(self):
        return self.altitude
    def set_altitude(self, altitude):
        self.altitude = altitude
    def get_pointRange(self):
        return self.pointRange
    def set_pointRange(self, pointRange):
        self.pointRange = pointRange
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.altitude is not None or
            self.pointRange is not None or
            super(Point4DType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='Point4DType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Point4DType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Point4DType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Point4DType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='Point4DType'):
        super(Point4DType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Point4DType')
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            outfile.write(' time=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.time), input_name='time')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='Point4DType', fromsubclass_=False, pretty_print=True):
        super(Point4DType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.altitude is not None:
            namespaceprefix_ = self.altitude_nsprefix_ + ':' if (UseCapturedNS_ and self.altitude_nsprefix_) else ''
            self.altitude.export(outfile, level, namespaceprefix_, namespacedef_='', name_='altitude', pretty_print=pretty_print)
        if self.pointRange is not None:
            namespaceprefix_ = self.pointRange_nsprefix_ + ':' if (UseCapturedNS_ and self.pointRange_nsprefix_) else ''
            self.pointRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pointRange', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.add('time')
            try:
                self.time = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (time): %s' % exp)
            self.validate_TimeType(self.time)    # validate type TimeType
        super(Point4DType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'altitude':
            class_obj_ = self.get_class_obj_(child_, AltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.altitude = obj_
            obj_.original_tagname_ = 'altitude'
        elif nodeName_ == 'pointRange':
            obj_ = PointRangeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pointRange = obj_
            obj_.original_tagname_ = 'pointRange'
        super(Point4DType, self).buildChildren(child_, node, nodeName_, True)
# end class Point4DType


class PointRangeType(GeneratedsSuper):
    """Provides a vertical, lateral or temporal range to a 4D point when
    clearances are
    provided in the form of:
    block altitude clearances
    offsets for deviations due to weather
    assigned speed ranges
    .Point Range: Provides a vertical, lateral or temporal range to a 4D point
    when clearances
    are provided in the form of:block altitude clearancesoffsets for deviations
    due to
    weatherassigned speed ranges"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lateralRange=None, temporalRange=None, verticalRange=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lateralRange = lateralRange
        self.lateralRange_nsprefix_ = None
        self.temporalRange = temporalRange
        self.temporalRange_nsprefix_ = None
        self.verticalRange = verticalRange
        self.verticalRange_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PointRangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PointRangeType.subclass:
            return PointRangeType.subclass(*args_, **kwargs_)
        else:
            return PointRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lateralRange(self):
        return self.lateralRange
    def set_lateralRange(self, lateralRange):
        self.lateralRange = lateralRange
    def get_temporalRange(self):
        return self.temporalRange
    def set_temporalRange(self, temporalRange):
        self.temporalRange = temporalRange
    def get_verticalRange(self):
        return self.verticalRange
    def set_verticalRange(self, verticalRange):
        self.verticalRange = verticalRange
    def hasContent_(self):
        if (
            self.lateralRange is not None or
            self.temporalRange is not None or
            self.verticalRange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='PointRangeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PointRangeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PointRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PointRangeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='PointRangeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='PointRangeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lateralRange is not None:
            namespaceprefix_ = self.lateralRange_nsprefix_ + ':' if (UseCapturedNS_ and self.lateralRange_nsprefix_) else ''
            self.lateralRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lateralRange', pretty_print=pretty_print)
        if self.temporalRange is not None:
            namespaceprefix_ = self.temporalRange_nsprefix_ + ':' if (UseCapturedNS_ and self.temporalRange_nsprefix_) else ''
            self.temporalRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='temporalRange', pretty_print=pretty_print)
        if self.verticalRange is not None:
            namespaceprefix_ = self.verticalRange_nsprefix_ + ':' if (UseCapturedNS_ and self.verticalRange_nsprefix_) else ''
            self.verticalRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='verticalRange', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lateralRange':
            obj_ = LateralOfftrackType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lateralRange = obj_
            obj_.original_tagname_ = 'lateralRange'
        elif nodeName_ == 'temporalRange':
            obj_ = TemporalRangeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.temporalRange = obj_
            obj_.original_tagname_ = 'temporalRange'
        elif nodeName_ == 'verticalRange':
            obj_ = VerticalRangeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.verticalRange = obj_
            obj_.original_tagname_ = 'verticalRange'
# end class PointRangeType


class TemporalRangeType(GeneratedsSuper):
    """Temporal range resulting from assigned speed range.
    lower bound of the temporal range.
    Upper bound of the temporal range."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, earliest=None, latest=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.earliest = _cast(None, earliest)
        self.earliest_nsprefix_ = None
        self.latest = _cast(None, latest)
        self.latest_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemporalRangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemporalRangeType.subclass:
            return TemporalRangeType.subclass(*args_, **kwargs_)
        else:
            return TemporalRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_earliest(self):
        return self.earliest
    def set_earliest(self, earliest):
        self.earliest = earliest
    def get_latest(self):
        return self.latest
    def set_latest(self, latest):
        self.latest = latest
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='TemporalRangeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TemporalRangeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TemporalRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TemporalRangeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='TemporalRangeType'):
        if self.earliest is not None and 'earliest' not in already_processed:
            already_processed.add('earliest')
            outfile.write(' earliest=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.earliest), input_name='earliest')), ))
        if self.latest is not None and 'latest' not in already_processed:
            already_processed.add('latest')
            outfile.write(' latest=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.latest), input_name='latest')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='TemporalRangeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('earliest', node)
        if value is not None and 'earliest' not in already_processed:
            already_processed.add('earliest')
            try:
                self.earliest = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (earliest): %s' % exp)
            self.validate_TimeType(self.earliest)    # validate type TimeType
        value = find_attr_value_('latest', node)
        if value is not None and 'latest' not in already_processed:
            already_processed.add('latest')
            try:
                self.latest = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (latest): %s' % exp)
            self.validate_TimeType(self.latest)    # validate type TimeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TemporalRangeType


class TrajectoryType(GeneratedsSuper):
    """For FIXM v3.0, this data type only covers the airborne segment. However,
    future
    versions of FIXM will cover gate-to-gate operations."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, trajectoryPoint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if trajectoryPoint is None:
            self.trajectoryPoint = []
        else:
            self.trajectoryPoint = trajectoryPoint
        self.trajectoryPoint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrajectoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrajectoryType.subclass:
            return TrajectoryType.subclass(*args_, **kwargs_)
        else:
            return TrajectoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_trajectoryPoint(self):
        return self.trajectoryPoint
    def set_trajectoryPoint(self, trajectoryPoint):
        self.trajectoryPoint = trajectoryPoint
    def add_trajectoryPoint(self, value):
        self.trajectoryPoint.append(value)
    def insert_trajectoryPoint_at(self, index, value):
        self.trajectoryPoint.insert(index, value)
    def replace_trajectoryPoint_at(self, index, value):
        self.trajectoryPoint[index] = value
    def hasContent_(self):
        if (
            self.trajectoryPoint
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='TrajectoryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrajectoryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TrajectoryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TrajectoryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='TrajectoryType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='TrajectoryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for trajectoryPoint_ in self.trajectoryPoint:
            namespaceprefix_ = self.trajectoryPoint_nsprefix_ + ':' if (UseCapturedNS_ and self.trajectoryPoint_nsprefix_) else ''
            trajectoryPoint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='trajectoryPoint', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'trajectoryPoint':
            obj_ = TrajectoryPointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.trajectoryPoint.append(obj_)
            obj_.original_tagname_ = 'trajectoryPoint'
# end class TrajectoryType


class TrajectoryChangeType(GeneratedsSuper):
    """Groups information about features crossed associated with the trajectory
    point.
    .Constrained Airspace Entered: For 4D Points of TCP Type crossing point
    into constrained
    airspace , the name or identifier of the Constrained Airspace being
    entered.
    .Special Activity Airspace Entered/Exited: For 4D Points of TCP Type entry
    point
    into special activity airspace or exit point from special activity airspace
    , the name or identifier of the Special Activity Airspace being
    entered/exited."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, constrainedAirspace=None, specialActivityAirspace=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.constrainedAirspace = _cast(None, constrainedAirspace)
        self.constrainedAirspace_nsprefix_ = None
        self.specialActivityAirspace = _cast(None, specialActivityAirspace)
        self.specialActivityAirspace_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrajectoryChangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrajectoryChangeType.subclass:
            return TrajectoryChangeType.subclass(*args_, **kwargs_)
        else:
            return TrajectoryChangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_constrainedAirspace(self):
        return self.constrainedAirspace
    def set_constrainedAirspace(self, constrainedAirspace):
        self.constrainedAirspace = constrainedAirspace
    def get_specialActivityAirspace(self):
        return self.specialActivityAirspace
    def set_specialActivityAirspace(self, specialActivityAirspace):
        self.specialActivityAirspace = specialActivityAirspace
    def validate_ConstrainedAirspaceType(self, value):
        # Validate type fb:ConstrainedAirspaceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='TrajectoryChangeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrajectoryChangeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TrajectoryChangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TrajectoryChangeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='TrajectoryChangeType'):
        if self.constrainedAirspace is not None and 'constrainedAirspace' not in already_processed:
            already_processed.add('constrainedAirspace')
            outfile.write(' constrainedAirspace=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.constrainedAirspace), input_name='constrainedAirspace')), ))
        if self.specialActivityAirspace is not None and 'specialActivityAirspace' not in already_processed:
            already_processed.add('specialActivityAirspace')
            outfile.write(' specialActivityAirspace=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.specialActivityAirspace), input_name='specialActivityAirspace')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='TrajectoryChangeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('constrainedAirspace', node)
        if value is not None and 'constrainedAirspace' not in already_processed:
            already_processed.add('constrainedAirspace')
            self.constrainedAirspace = value
            self.validate_ConstrainedAirspaceType(self.constrainedAirspace)    # validate type ConstrainedAirspaceType
        value = find_attr_value_('specialActivityAirspace', node)
        if value is not None and 'specialActivityAirspace' not in already_processed:
            already_processed.add('specialActivityAirspace')
            self.specialActivityAirspace = value
            self.validate_FreeTextType(self.specialActivityAirspace)    # validate type FreeTextType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TrajectoryChangeType


class TrajectoryPointType(GeneratedsSuper):
    """.Trajectory Point: A container for information pertinent to a single
    point in a trajectory."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, altimeterSetting=None, metData=None, point=None, predictedAirspeed=None, predictedGroundspeed=None, referencePoint=None, trajectoryChange=None, trajectoryChangeType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.altimeterSetting = altimeterSetting
        self.altimeterSetting_nsprefix_ = None
        self.metData = metData
        self.metData_nsprefix_ = None
        self.point = point
        self.point_nsprefix_ = None
        self.predictedAirspeed = predictedAirspeed
        self.predictedAirspeed_nsprefix_ = None
        self.predictedGroundspeed = predictedGroundspeed
        self.predictedGroundspeed_nsprefix_ = None
        self.referencePoint = referencePoint
        self.referencePoint_nsprefix_ = None
        if trajectoryChange is None:
            self.trajectoryChange = []
        else:
            self.trajectoryChange = trajectoryChange
        self.trajectoryChange_nsprefix_ = None
        self.trajectoryChangeType = trajectoryChangeType
        self.validate_trajectoryChangeTypeType(self.trajectoryChangeType)
        self.trajectoryChangeType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrajectoryPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrajectoryPointType.subclass:
            return TrajectoryPointType.subclass(*args_, **kwargs_)
        else:
            return TrajectoryPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_altimeterSetting(self):
        return self.altimeterSetting
    def set_altimeterSetting(self, altimeterSetting):
        self.altimeterSetting = altimeterSetting
    def get_metData(self):
        return self.metData
    def set_metData(self, metData):
        self.metData = metData
    def get_point(self):
        return self.point
    def set_point(self, point):
        self.point = point
    def get_predictedAirspeed(self):
        return self.predictedAirspeed
    def set_predictedAirspeed(self, predictedAirspeed):
        self.predictedAirspeed = predictedAirspeed
    def get_predictedGroundspeed(self):
        return self.predictedGroundspeed
    def set_predictedGroundspeed(self, predictedGroundspeed):
        self.predictedGroundspeed = predictedGroundspeed
    def get_referencePoint(self):
        return self.referencePoint
    def set_referencePoint(self, referencePoint):
        self.referencePoint = referencePoint
    def get_trajectoryChange(self):
        return self.trajectoryChange
    def set_trajectoryChange(self, trajectoryChange):
        self.trajectoryChange = trajectoryChange
    def add_trajectoryChange(self, value):
        self.trajectoryChange.append(value)
    def insert_trajectoryChange_at(self, index, value):
        self.trajectoryChange.insert(index, value)
    def replace_trajectoryChange_at(self, index, value):
        self.trajectoryChange[index] = value
    def get_trajectoryChangeType(self):
        return self.trajectoryChangeType
    def set_trajectoryChangeType(self, trajectoryChangeType):
        self.trajectoryChangeType = trajectoryChangeType
    def validate_trajectoryChangeTypeType(self, value):
        result = True
        # Validate type trajectoryChangeTypeType, a restriction on fx:TrajectoryChangePointTypeType.
        pass
        return result
    def hasContent_(self):
        if (
            self.altimeterSetting is not None or
            self.metData is not None or
            self.point is not None or
            self.predictedAirspeed is not None or
            self.predictedGroundspeed is not None or
            self.referencePoint is not None or
            self.trajectoryChange or
            self.trajectoryChangeType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TrajectoryPointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrajectoryPointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TrajectoryPointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TrajectoryPointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='TrajectoryPointType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TrajectoryPointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.altimeterSetting is not None:
            namespaceprefix_ = self.altimeterSetting_nsprefix_ + ':' if (UseCapturedNS_ and self.altimeterSetting_nsprefix_) else ''
            self.altimeterSetting.export(outfile, level, namespaceprefix_, namespacedef_='', name_='altimeterSetting', pretty_print=pretty_print)
        if self.metData is not None:
            namespaceprefix_ = self.metData_nsprefix_ + ':' if (UseCapturedNS_ and self.metData_nsprefix_) else ''
            self.metData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metData', pretty_print=pretty_print)
        if self.point is not None:
            namespaceprefix_ = self.point_nsprefix_ + ':' if (UseCapturedNS_ and self.point_nsprefix_) else ''
            self.point.export(outfile, level, namespaceprefix_, namespacedef_='', name_='point', pretty_print=pretty_print)
        if self.predictedAirspeed is not None:
            namespaceprefix_ = self.predictedAirspeed_nsprefix_ + ':' if (UseCapturedNS_ and self.predictedAirspeed_nsprefix_) else ''
            self.predictedAirspeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='predictedAirspeed', pretty_print=pretty_print)
        if self.predictedGroundspeed is not None:
            namespaceprefix_ = self.predictedGroundspeed_nsprefix_ + ':' if (UseCapturedNS_ and self.predictedGroundspeed_nsprefix_) else ''
            self.predictedGroundspeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='predictedGroundspeed', pretty_print=pretty_print)
        if self.referencePoint is not None:
            namespaceprefix_ = self.referencePoint_nsprefix_ + ':' if (UseCapturedNS_ and self.referencePoint_nsprefix_) else ''
            self.referencePoint.export(outfile, level, namespaceprefix_, namespacedef_='', name_='referencePoint', pretty_print=pretty_print)
        for trajectoryChange_ in self.trajectoryChange:
            namespaceprefix_ = self.trajectoryChange_nsprefix_ + ':' if (UseCapturedNS_ and self.trajectoryChange_nsprefix_) else ''
            trajectoryChange_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='trajectoryChange', pretty_print=pretty_print)
        if self.trajectoryChangeType is not None:
            namespaceprefix_ = self.trajectoryChangeType_nsprefix_ + ':' if (UseCapturedNS_ and self.trajectoryChangeType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%strajectoryChangeType>%s</%strajectoryChangeType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(' '.join(self.trajectoryChangeType)), input_name='trajectoryChangeType')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'altimeterSetting':
            obj_ = PressureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.altimeterSetting = obj_
            obj_.original_tagname_ = 'altimeterSetting'
        elif nodeName_ == 'metData':
            obj_ = MeteorologicalDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metData = obj_
            obj_.original_tagname_ = 'metData'
        elif nodeName_ == 'point':
            obj_ = Point4DType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.point = obj_
            obj_.original_tagname_ = 'point'
        elif nodeName_ == 'predictedAirspeed':
            obj_ = AirspeedChoiceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.predictedAirspeed = obj_
            obj_.original_tagname_ = 'predictedAirspeed'
        elif nodeName_ == 'predictedGroundspeed':
            obj_ = GroundspeedChoiceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.predictedGroundspeed = obj_
            obj_.original_tagname_ = 'predictedGroundspeed'
        elif nodeName_ == 'referencePoint':
            obj_ = ExpandedRoutePointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.referencePoint = obj_
            obj_.original_tagname_ = 'referencePoint'
        elif nodeName_ == 'trajectoryChange':
            obj_ = TrajectoryChangeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.trajectoryChange.append(obj_)
            obj_.original_tagname_ = 'trajectoryChange'
        elif nodeName_ == 'trajectoryChangeType':
            value_ = child_.text
            self.trajectoryChangeType = value_
            self.trajectoryChangeType_nsprefix_ = child_.prefix
            # validate type trajectoryChangeTypeType
            self.validate_trajectoryChangeTypeType(self.trajectoryChangeType)
# end class TrajectoryPointType


class TrajectoryRoutePairType(GeneratedsSuper):
    """Groups and associates a Route and 4D Trajectory."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, route=None, trajectory=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.route = route
        self.route_nsprefix_ = None
        self.trajectory = trajectory
        self.trajectory_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrajectoryRoutePairType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrajectoryRoutePairType.subclass:
            return TrajectoryRoutePairType.subclass(*args_, **kwargs_)
        else:
            return TrajectoryRoutePairType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_route(self):
        return self.route
    def set_route(self, route):
        self.route = route
    def get_trajectory(self):
        return self.trajectory
    def set_trajectory(self, trajectory):
        self.trajectory = trajectory
    def hasContent_(self):
        if (
            self.route is not None or
            self.trajectory is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='TrajectoryRoutePairType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrajectoryRoutePairType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TrajectoryRoutePairType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TrajectoryRoutePairType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='TrajectoryRoutePairType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='TrajectoryRoutePairType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.route is not None:
            namespaceprefix_ = self.route_nsprefix_ + ':' if (UseCapturedNS_ and self.route_nsprefix_) else ''
            self.route.export(outfile, level, namespaceprefix_, namespacedef_='', name_='route', pretty_print=pretty_print)
        if self.trajectory is not None:
            namespaceprefix_ = self.trajectory_nsprefix_ + ':' if (UseCapturedNS_ and self.trajectory_nsprefix_) else ''
            self.trajectory.export(outfile, level, namespaceprefix_, namespacedef_='', name_='trajectory', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'route':
            class_obj_ = self.get_class_obj_(child_, RouteType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.route = obj_
            obj_.original_tagname_ = 'route'
        elif nodeName_ == 'trajectory':
            obj_ = TrajectoryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.trajectory = obj_
            obj_.original_tagname_ = 'trajectory'
# end class TrajectoryRoutePairType


class AbstractRoutePointType(GeneratedsSuper):
    """An abstract route point containing basic shared data between RoutePoint
    and ExpandedRoutePoint.
    .Route-Change Air Traffic Type: The type of flight value associated with
    the point.
    It is associated with the first point on the route and any subsequent point
    where
    the type of flight value changes.
    .Clearance Limit: The point to which an aircraft is granted an air traffic
    control
    clearance.
    .En Route Delay - Filed: The length of time the flight is expected to be
    delayed
    at a specific point en route.
    .Change Flight Rules: The planned flight rules the aircraft will change to
    upon reaching
    the associated Significant Point along its Route.
    .Route-Change Flight Rules: The planned flight rules the aircraft will
    change to
    upon reaching the associated Significant Point along its Route."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, airTrafficType=None, clearanceLimit=None, delayAtPoint=None, flightRules=None, point=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.airTrafficType = _cast(None, airTrafficType)
        self.airTrafficType_nsprefix_ = None
        self.clearanceLimit = _cast(None, clearanceLimit)
        self.clearanceLimit_nsprefix_ = None
        self.delayAtPoint = _cast(None, delayAtPoint)
        self.delayAtPoint_nsprefix_ = None
        self.flightRules = _cast(None, flightRules)
        self.flightRules_nsprefix_ = None
        self.point = point
        self.point_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractRoutePointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractRoutePointType.subclass:
            return AbstractRoutePointType.subclass(*args_, **kwargs_)
        else:
            return AbstractRoutePointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_point(self):
        return self.point
    def set_point(self, point):
        self.point = point
    def set_point_with_type(self, value):
        self.point = value
        value.original_tagname_ = 'point'
        value.extensiontype_ = value.__class__.__name__
    def get_airTrafficType(self):
        return self.airTrafficType
    def set_airTrafficType(self, airTrafficType):
        self.airTrafficType = airTrafficType
    def get_clearanceLimit(self):
        return self.clearanceLimit
    def set_clearanceLimit(self, clearanceLimit):
        self.clearanceLimit = clearanceLimit
    def get_delayAtPoint(self):
        return self.delayAtPoint
    def set_delayAtPoint(self, delayAtPoint):
        self.delayAtPoint = delayAtPoint
    def get_flightRules(self):
        return self.flightRules
    def set_flightRules(self, flightRules):
        self.flightRules = flightRules
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_AirTrafficTypeType(self, value):
        # Validate type fb:AirTrafficTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OAT', 'GAT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AirTrafficTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ClearanceLimitIndicatorType(self, value):
        # Validate type fx:ClearanceLimitIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CLEARANCE_LIMIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ClearanceLimitIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DurationType(self, value):
        # Validate type ff:DurationType, a restriction on xs:duration.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_FlightRulesType(self, value):
        # Validate type fb:FlightRulesType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['IFR', 'VFR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FlightRulesType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.point is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='AbstractRoutePointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbstractRoutePointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractRoutePointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AbstractRoutePointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='AbstractRoutePointType'):
        if self.airTrafficType is not None and 'airTrafficType' not in already_processed:
            already_processed.add('airTrafficType')
            outfile.write(' airTrafficType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.airTrafficType), input_name='airTrafficType')), ))
        if self.clearanceLimit is not None and 'clearanceLimit' not in already_processed:
            already_processed.add('clearanceLimit')
            outfile.write(' clearanceLimit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clearanceLimit), input_name='clearanceLimit')), ))
        if self.delayAtPoint is not None and 'delayAtPoint' not in already_processed:
            already_processed.add('delayAtPoint')
            outfile.write(' delayAtPoint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delayAtPoint), input_name='delayAtPoint')), ))
        if self.flightRules is not None and 'flightRules' not in already_processed:
            already_processed.add('flightRules')
            outfile.write(' flightRules=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.flightRules), input_name='flightRules')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='AbstractRoutePointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.point is not None:
            self.point.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('airTrafficType', node)
        if value is not None and 'airTrafficType' not in already_processed:
            already_processed.add('airTrafficType')
            self.airTrafficType = value
            self.validate_AirTrafficTypeType(self.airTrafficType)    # validate type AirTrafficTypeType
        value = find_attr_value_('clearanceLimit', node)
        if value is not None and 'clearanceLimit' not in already_processed:
            already_processed.add('clearanceLimit')
            self.clearanceLimit = value
            self.validate_ClearanceLimitIndicatorType(self.clearanceLimit)    # validate type ClearanceLimitIndicatorType
        value = find_attr_value_('delayAtPoint', node)
        if value is not None and 'delayAtPoint' not in already_processed:
            already_processed.add('delayAtPoint')
            self.delayAtPoint = value
            self.validate_DurationType(self.delayAtPoint)    # validate type DurationType
        value = find_attr_value_('flightRules', node)
        if value is not None and 'flightRules' not in already_processed:
            already_processed.add('flightRules')
            self.flightRules = value
            self.validate_FlightRulesType(self.flightRules)    # validate type FlightRulesType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'point':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <point> element')
            self.point = obj_
            obj_.original_tagname_ = 'point'
# end class AbstractRoutePointType


class ElapsedTimeLocationType(GeneratedsSuper):
    """The location associated with estimated elapsed time. It can be a
    longitude, significant
    point of flight information region."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, longitude=None, point=None, region=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.longitude = longitude
        self.validate_LongitudeType(self.longitude)
        self.longitude_nsprefix_ = None
        self.point = point
        self.point_nsprefix_ = None
        self.region = region
        self.region_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElapsedTimeLocationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElapsedTimeLocationType.subclass:
            return ElapsedTimeLocationType.subclass(*args_, **kwargs_)
        else:
            return ElapsedTimeLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_longitude(self):
        return self.longitude
    def set_longitude(self, longitude):
        self.longitude = longitude
    def get_point(self):
        return self.point
    def set_point(self, point):
        self.point = point
    def set_point_with_type(self, value):
        self.point = value
        value.original_tagname_ = 'point'
        value.extensiontype_ = value.__class__.__name__
    def get_region(self):
        return self.region
    def set_region(self, region):
        self.region = region
    def validate_LongitudeType(self, value):
        result = True
        # Validate type LongitudeType, a restriction on ff:UnitOfMeasureType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def hasContent_(self):
        if (
            self.longitude is not None or
            self.point is not None or
            self.region is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='ElapsedTimeLocationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElapsedTimeLocationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElapsedTimeLocationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ElapsedTimeLocationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='ElapsedTimeLocationType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='ElapsedTimeLocationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.longitude is not None:
            namespaceprefix_ = self.longitude_nsprefix_ + ':' if (UseCapturedNS_ and self.longitude_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slongitude>%s</%slongitude>%s' % (namespaceprefix_ , self.gds_format_double(self.longitude, input_name='longitude'), namespaceprefix_ , eol_))
        if self.point is not None:
            self.point.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.region is not None:
            namespaceprefix_ = self.region_nsprefix_ + ':' if (UseCapturedNS_ and self.region_nsprefix_) else ''
            self.region.export(outfile, level, namespaceprefix_, namespacedef_='', name_='region', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'longitude' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'longitude')
            fval_ = self.gds_validate_double(fval_, node, 'longitude')
            self.longitude = fval_
            self.longitude_nsprefix_ = child_.prefix
            # validate type LongitudeType
            self.validate_LongitudeType(self.longitude)
        elif nodeName_ == 'point':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <point> element')
            self.point = obj_
            obj_.original_tagname_ = 'point'
        elif nodeName_ == 'region':
            obj_ = UnitSectorAirspaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.region = obj_
            obj_.original_tagname_ = 'region'
# end class ElapsedTimeLocationType


class EstimatedElapsedTimeType(GeneratedsSuper):
    """.Elapsed Time - Estimated: The estimated amount of time from takeoff to
    reach a significant
    point or Flight Information Region (FIR) boundary along the route of
    flight.
    The estimated amount of elapsed time."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, elapsedTime=None, location=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.elapsedTime = _cast(None, elapsedTime)
        self.elapsedTime_nsprefix_ = None
        self.location = location
        self.location_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EstimatedElapsedTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EstimatedElapsedTimeType.subclass:
            return EstimatedElapsedTimeType.subclass(*args_, **kwargs_)
        else:
            return EstimatedElapsedTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_elapsedTime(self):
        return self.elapsedTime
    def set_elapsedTime(self, elapsedTime):
        self.elapsedTime = elapsedTime
    def validate_DurationType(self, value):
        # Validate type ff:DurationType, a restriction on xs:duration.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.location is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='EstimatedElapsedTimeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EstimatedElapsedTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EstimatedElapsedTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EstimatedElapsedTimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='EstimatedElapsedTimeType'):
        if self.elapsedTime is not None and 'elapsedTime' not in already_processed:
            already_processed.add('elapsedTime')
            outfile.write(' elapsedTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elapsedTime), input_name='elapsedTime')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='EstimatedElapsedTimeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.location is not None:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            self.location.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('elapsedTime', node)
        if value is not None and 'elapsedTime' not in already_processed:
            already_processed.add('elapsedTime')
            self.elapsedTime = value
            self.validate_DurationType(self.elapsedTime)    # validate type DurationType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'location':
            obj_ = ElapsedTimeLocationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
# end class EstimatedElapsedTimeType


class ExpandedRouteType(GeneratedsSuper):
    """.Expanded Route: The expansion of the route into a set of points which
    describe the
    aircraft's expected 2D path from the departure aerodrome to the destination
    aerodrome."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, routePoint=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if routePoint is None:
            self.routePoint = []
        else:
            self.routePoint = routePoint
        self.routePoint_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExpandedRouteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExpandedRouteType.subclass:
            return ExpandedRouteType.subclass(*args_, **kwargs_)
        else:
            return ExpandedRouteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_routePoint(self):
        return self.routePoint
    def set_routePoint(self, routePoint):
        self.routePoint = routePoint
    def add_routePoint(self, value):
        self.routePoint.append(value)
    def insert_routePoint_at(self, index, value):
        self.routePoint.insert(index, value)
    def replace_routePoint_at(self, index, value):
        self.routePoint[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.routePoint
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='ExpandedRouteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExpandedRouteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExpandedRouteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExpandedRouteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='ExpandedRouteType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='ExpandedRouteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for routePoint_ in self.routePoint:
            namespaceprefix_ = self.routePoint_nsprefix_ + ':' if (UseCapturedNS_ and self.routePoint_nsprefix_) else ''
            routePoint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='routePoint', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'routePoint':
            obj_ = ExpandedRoutePointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.routePoint.append(obj_)
            obj_.original_tagname_ = 'routePoint'
# end class ExpandedRouteType


class ExpandedRoutePointType(AbstractRoutePointType):
    """.Expanded Route Point: A point that is part of the aircraft's expanded
    route of flight.
    .Expanded Route Point Time: The estimated time over the expanded route
    point."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AbstractRoutePointType
    def __init__(self, airTrafficType=None, clearanceLimit=None, delayAtPoint=None, flightRules=None, point=None, estimatedTime=None, constraint=None, estimatedLevel=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ExpandedRoutePointType, self).__init__(airTrafficType, clearanceLimit, delayAtPoint, flightRules, point,  **kwargs_)
        self.estimatedTime = _cast(None, estimatedTime)
        self.estimatedTime_nsprefix_ = None
        if constraint is None:
            self.constraint = []
        else:
            self.constraint = constraint
        self.constraint_nsprefix_ = None
        self.estimatedLevel = estimatedLevel
        self.estimatedLevel_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExpandedRoutePointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExpandedRoutePointType.subclass:
            return ExpandedRoutePointType.subclass(*args_, **kwargs_)
        else:
            return ExpandedRoutePointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_constraint(self):
        return self.constraint
    def set_constraint(self, constraint):
        self.constraint = constraint
    def set_constraint_with_type(self, value):
        self.constraint = value
        value.original_tagname_ = 'constraint'
        value.extensiontype_ = value.__class__.__name__
    def add_constraint(self, value):
        self.constraint.append(value)
    def add_constraint_with_type(self, value):
        self.constraint.append(value)
        value.original_tagname_ = 'constraint'
        value.extensiontype_ = value.__class__.__name__
    def insert_constraint_at(self, index, value):
        self.constraint.insert(index, value)
    def replace_constraint_at(self, index, value):
        self.constraint[index] = value
    def get_estimatedLevel(self):
        return self.estimatedLevel
    def set_estimatedLevel(self, estimatedLevel):
        self.estimatedLevel = estimatedLevel
    def get_estimatedTime(self):
        return self.estimatedTime
    def set_estimatedTime(self, estimatedTime):
        self.estimatedTime = estimatedTime
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.constraint or
            self.estimatedLevel is not None or
            super(ExpandedRoutePointType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='ExpandedRoutePointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExpandedRoutePointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExpandedRoutePointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExpandedRoutePointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='ExpandedRoutePointType'):
        super(ExpandedRoutePointType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExpandedRoutePointType')
        if self.estimatedTime is not None and 'estimatedTime' not in already_processed:
            already_processed.add('estimatedTime')
            outfile.write(' estimatedTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.estimatedTime), input_name='estimatedTime')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='ExpandedRoutePointType', fromsubclass_=False, pretty_print=True):
        super(ExpandedRoutePointType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for constraint_ in self.constraint:
            constraint_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.estimatedLevel is not None:
            namespaceprefix_ = self.estimatedLevel_nsprefix_ + ':' if (UseCapturedNS_ and self.estimatedLevel_nsprefix_) else ''
            self.estimatedLevel.export(outfile, level, namespaceprefix_, namespacedef_='', name_='estimatedLevel', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('estimatedTime', node)
        if value is not None and 'estimatedTime' not in already_processed:
            already_processed.add('estimatedTime')
            try:
                self.estimatedTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (estimatedTime): %s' % exp)
            self.validate_TimeType(self.estimatedTime)    # validate type TimeType
        super(ExpandedRoutePointType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'constraint':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <constraint> element')
            self.constraint.append(obj_)
            obj_.original_tagname_ = 'constraint'
        elif nodeName_ == 'estimatedLevel':
            class_obj_ = self.get_class_obj_(child_, AltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.estimatedLevel = obj_
            obj_.original_tagname_ = 'estimatedLevel'
        super(ExpandedRoutePointType, self).buildChildren(child_, node, nodeName_, True)
# end class ExpandedRoutePointType


class RouteType(FeatureType):
    """Contains information about the Flight Route. The route is comprised of
    Route Segments,
    which are comprised of Route Point/Airway pairs. Route also contains an
    expanded
    route.
    .Route: The ICAO route string as depicted from the flight plan.
    .Airfile Route Start Time: The actual or estimated time of departure from
    the first
    point on the route for a flight filed in the air.
    .Time En Route - Estimated: The total estimated time en route, from the
    departure
    time (runway) to the arrival at the destination (runway). For an airfile
    flight,
    this is the total estimated time en route, from the route start point to
    the arrival
    at the destination (runway).
    .Flight Rules: The regulation, or combination of regulations, that governs
    all aspects
    of operations under which the pilot plans to fly.
    .Route String: The ICAO route string as depicted from the flight plan."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FeatureType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, airfileRouteStartTime=None, flightDuration=None, initialFlightRules=None, routeText=None, climbSchedule=None, descentSchedule=None, estimatedElapsedTime=None, expandedRoute=None, initialCruisingSpeed=None, requestedAltitude=None, segment=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RouteType, self).__init__(centre, source, system, timestamp, extensiontype_,  **kwargs_)
        self.airfileRouteStartTime = _cast(None, airfileRouteStartTime)
        self.airfileRouteStartTime_nsprefix_ = None
        self.flightDuration = _cast(None, flightDuration)
        self.flightDuration_nsprefix_ = None
        self.initialFlightRules = _cast(None, initialFlightRules)
        self.initialFlightRules_nsprefix_ = None
        self.routeText = _cast(None, routeText)
        self.routeText_nsprefix_ = None
        self.climbSchedule = climbSchedule
        self.climbSchedule_nsprefix_ = None
        self.descentSchedule = descentSchedule
        self.descentSchedule_nsprefix_ = None
        if estimatedElapsedTime is None:
            self.estimatedElapsedTime = []
        else:
            self.estimatedElapsedTime = estimatedElapsedTime
        self.estimatedElapsedTime_nsprefix_ = None
        self.expandedRoute = expandedRoute
        self.expandedRoute_nsprefix_ = None
        self.initialCruisingSpeed = initialCruisingSpeed
        self.initialCruisingSpeed_nsprefix_ = None
        self.requestedAltitude = requestedAltitude
        self.requestedAltitude_nsprefix_ = None
        if segment is None:
            self.segment = []
        else:
            self.segment = segment
        self.segment_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RouteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RouteType.subclass:
            return RouteType.subclass(*args_, **kwargs_)
        else:
            return RouteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_climbSchedule(self):
        return self.climbSchedule
    def set_climbSchedule(self, climbSchedule):
        self.climbSchedule = climbSchedule
    def get_descentSchedule(self):
        return self.descentSchedule
    def set_descentSchedule(self, descentSchedule):
        self.descentSchedule = descentSchedule
    def get_estimatedElapsedTime(self):
        return self.estimatedElapsedTime
    def set_estimatedElapsedTime(self, estimatedElapsedTime):
        self.estimatedElapsedTime = estimatedElapsedTime
    def add_estimatedElapsedTime(self, value):
        self.estimatedElapsedTime.append(value)
    def insert_estimatedElapsedTime_at(self, index, value):
        self.estimatedElapsedTime.insert(index, value)
    def replace_estimatedElapsedTime_at(self, index, value):
        self.estimatedElapsedTime[index] = value
    def get_expandedRoute(self):
        return self.expandedRoute
    def set_expandedRoute(self, expandedRoute):
        self.expandedRoute = expandedRoute
    def get_initialCruisingSpeed(self):
        return self.initialCruisingSpeed
    def set_initialCruisingSpeed(self, initialCruisingSpeed):
        self.initialCruisingSpeed = initialCruisingSpeed
    def get_requestedAltitude(self):
        return self.requestedAltitude
    def set_requestedAltitude(self, requestedAltitude):
        self.requestedAltitude = requestedAltitude
    def get_segment(self):
        return self.segment
    def set_segment(self, segment):
        self.segment = segment
    def add_segment(self, value):
        self.segment.append(value)
    def insert_segment_at(self, index, value):
        self.segment.insert(index, value)
    def replace_segment_at(self, index, value):
        self.segment[index] = value
    def get_airfileRouteStartTime(self):
        return self.airfileRouteStartTime
    def set_airfileRouteStartTime(self, airfileRouteStartTime):
        self.airfileRouteStartTime = airfileRouteStartTime
    def get_flightDuration(self):
        return self.flightDuration
    def set_flightDuration(self, flightDuration):
        self.flightDuration = flightDuration
    def get_initialFlightRules(self):
        return self.initialFlightRules
    def set_initialFlightRules(self, initialFlightRules):
        self.initialFlightRules = initialFlightRules
    def get_routeText(self):
        return self.routeText
    def set_routeText(self, routeText):
        self.routeText = routeText
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_DurationType(self, value):
        # Validate type ff:DurationType, a restriction on xs:duration.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_FlightRulesType(self, value):
        # Validate type fb:FlightRulesType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['IFR', 'VFR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FlightRulesType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.climbSchedule is not None or
            self.descentSchedule is not None or
            self.estimatedElapsedTime or
            self.expandedRoute is not None or
            self.initialCruisingSpeed is not None or
            self.requestedAltitude is not None or
            self.segment or
            super(RouteType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='RouteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RouteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RouteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RouteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='RouteType'):
        super(RouteType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RouteType')
        if self.airfileRouteStartTime is not None and 'airfileRouteStartTime' not in already_processed:
            already_processed.add('airfileRouteStartTime')
            outfile.write(' airfileRouteStartTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.airfileRouteStartTime), input_name='airfileRouteStartTime')), ))
        if self.flightDuration is not None and 'flightDuration' not in already_processed:
            already_processed.add('flightDuration')
            outfile.write(' flightDuration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.flightDuration), input_name='flightDuration')), ))
        if self.initialFlightRules is not None and 'initialFlightRules' not in already_processed:
            already_processed.add('initialFlightRules')
            outfile.write(' initialFlightRules=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.initialFlightRules), input_name='initialFlightRules')), ))
        if self.routeText is not None and 'routeText' not in already_processed:
            already_processed.add('routeText')
            outfile.write(' routeText=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.routeText), input_name='routeText')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='RouteType', fromsubclass_=False, pretty_print=True):
        super(RouteType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.climbSchedule is not None:
            namespaceprefix_ = self.climbSchedule_nsprefix_ + ':' if (UseCapturedNS_ and self.climbSchedule_nsprefix_) else ''
            self.climbSchedule.export(outfile, level, namespaceprefix_, namespacedef_='', name_='climbSchedule', pretty_print=pretty_print)
        if self.descentSchedule is not None:
            namespaceprefix_ = self.descentSchedule_nsprefix_ + ':' if (UseCapturedNS_ and self.descentSchedule_nsprefix_) else ''
            self.descentSchedule.export(outfile, level, namespaceprefix_, namespacedef_='', name_='descentSchedule', pretty_print=pretty_print)
        for estimatedElapsedTime_ in self.estimatedElapsedTime:
            namespaceprefix_ = self.estimatedElapsedTime_nsprefix_ + ':' if (UseCapturedNS_ and self.estimatedElapsedTime_nsprefix_) else ''
            estimatedElapsedTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='estimatedElapsedTime', pretty_print=pretty_print)
        if self.expandedRoute is not None:
            namespaceprefix_ = self.expandedRoute_nsprefix_ + ':' if (UseCapturedNS_ and self.expandedRoute_nsprefix_) else ''
            self.expandedRoute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='expandedRoute', pretty_print=pretty_print)
        if self.initialCruisingSpeed is not None:
            namespaceprefix_ = self.initialCruisingSpeed_nsprefix_ + ':' if (UseCapturedNS_ and self.initialCruisingSpeed_nsprefix_) else ''
            self.initialCruisingSpeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='initialCruisingSpeed', pretty_print=pretty_print)
        if self.requestedAltitude is not None:
            namespaceprefix_ = self.requestedAltitude_nsprefix_ + ':' if (UseCapturedNS_ and self.requestedAltitude_nsprefix_) else ''
            self.requestedAltitude.export(outfile, level, namespaceprefix_, namespacedef_='', name_='requestedAltitude', pretty_print=pretty_print)
        for segment_ in self.segment:
            namespaceprefix_ = self.segment_nsprefix_ + ':' if (UseCapturedNS_ and self.segment_nsprefix_) else ''
            segment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='segment', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('airfileRouteStartTime', node)
        if value is not None and 'airfileRouteStartTime' not in already_processed:
            already_processed.add('airfileRouteStartTime')
            try:
                self.airfileRouteStartTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (airfileRouteStartTime): %s' % exp)
            self.validate_TimeType(self.airfileRouteStartTime)    # validate type TimeType
        value = find_attr_value_('flightDuration', node)
        if value is not None and 'flightDuration' not in already_processed:
            already_processed.add('flightDuration')
            self.flightDuration = value
            self.validate_DurationType(self.flightDuration)    # validate type DurationType
        value = find_attr_value_('initialFlightRules', node)
        if value is not None and 'initialFlightRules' not in already_processed:
            already_processed.add('initialFlightRules')
            self.initialFlightRules = value
            self.validate_FlightRulesType(self.initialFlightRules)    # validate type FlightRulesType
        value = find_attr_value_('routeText', node)
        if value is not None and 'routeText' not in already_processed:
            already_processed.add('routeText')
            self.routeText = value
            self.validate_FreeTextType(self.routeText)    # validate type FreeTextType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(RouteType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'climbSchedule':
            obj_ = SpeedScheduleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.climbSchedule = obj_
            obj_.original_tagname_ = 'climbSchedule'
        elif nodeName_ == 'descentSchedule':
            obj_ = SpeedScheduleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.descentSchedule = obj_
            obj_.original_tagname_ = 'descentSchedule'
        elif nodeName_ == 'estimatedElapsedTime':
            obj_ = EstimatedElapsedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.estimatedElapsedTime.append(obj_)
            obj_.original_tagname_ = 'estimatedElapsedTime'
        elif nodeName_ == 'expandedRoute':
            class_obj_ = self.get_class_obj_(child_, ExpandedRouteType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expandedRoute = obj_
            obj_.original_tagname_ = 'expandedRoute'
        elif nodeName_ == 'initialCruisingSpeed':
            obj_ = TrueAirspeedOrMachType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.initialCruisingSpeed = obj_
            obj_.original_tagname_ = 'initialCruisingSpeed'
        elif nodeName_ == 'requestedAltitude':
            class_obj_ = self.get_class_obj_(child_, AltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.requestedAltitude = obj_
            obj_.original_tagname_ = 'requestedAltitude'
        elif nodeName_ == 'segment':
            class_obj_ = self.get_class_obj_(child_, RouteSegmentType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.segment.append(obj_)
            obj_.original_tagname_ = 'segment'
        super(RouteType, self).buildChildren(child_, node, nodeName_, True)
# end class RouteType


class RoutePointType(AbstractRoutePointType):
    """Route point along a route of the flight."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AbstractRoutePointType
    def __init__(self, airTrafficType=None, clearanceLimit=None, delayAtPoint=None, flightRules=None, point=None, constraint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RoutePointType, self).__init__(airTrafficType, clearanceLimit, delayAtPoint, flightRules, point,  **kwargs_)
        if constraint is None:
            self.constraint = []
        else:
            self.constraint = constraint
        self.constraint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoutePointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoutePointType.subclass:
            return RoutePointType.subclass(*args_, **kwargs_)
        else:
            return RoutePointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_constraint(self):
        return self.constraint
    def set_constraint(self, constraint):
        self.constraint = constraint
    def set_constraint_with_type(self, value):
        self.constraint = value
        value.original_tagname_ = 'constraint'
        value.extensiontype_ = value.__class__.__name__
    def add_constraint(self, value):
        self.constraint.append(value)
    def add_constraint_with_type(self, value):
        self.constraint.append(value)
        value.original_tagname_ = 'constraint'
        value.extensiontype_ = value.__class__.__name__
    def insert_constraint_at(self, index, value):
        self.constraint.insert(index, value)
    def replace_constraint_at(self, index, value):
        self.constraint[index] = value
    def hasContent_(self):
        if (
            self.constraint or
            super(RoutePointType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='RoutePointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RoutePointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RoutePointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RoutePointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='RoutePointType'):
        super(RoutePointType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RoutePointType')
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='RoutePointType', fromsubclass_=False, pretty_print=True):
        super(RoutePointType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for constraint_ in self.constraint:
            constraint_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RoutePointType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'constraint':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <constraint> element')
            self.constraint.append(obj_)
            obj_.original_tagname_ = 'constraint'
        super(RoutePointType, self).buildChildren(child_, node, nodeName_, True)
# end class RoutePointType


class RouteSegmentType(GeneratedsSuper):
    """Route Segment contained within the route. Each segment may contain a
    route point
    and an airway.
    .Airway: The coded designator for a published ATS route or route
    segment."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, airway=None, routePoint=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.airway = _cast(None, airway)
        self.airway_nsprefix_ = None
        self.routePoint = routePoint
        self.routePoint_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RouteSegmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RouteSegmentType.subclass:
            return RouteSegmentType.subclass(*args_, **kwargs_)
        else:
            return RouteSegmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_routePoint(self):
        return self.routePoint
    def set_routePoint(self, routePoint):
        self.routePoint = routePoint
    def get_airway(self):
        return self.airway
    def set_airway(self, airway):
        self.airway = airway
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_AtsRouteType(self, value):
        # Validate type ff:AtsRouteType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_AtsRouteType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AtsRouteType_patterns_, ))
    validate_AtsRouteType_patterns_ = [['^([A-Z][A-Z0-9]{1,7})$']]
    def hasContent_(self):
        if (
            self.routePoint is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='RouteSegmentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RouteSegmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RouteSegmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RouteSegmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='RouteSegmentType'):
        if self.airway is not None and 'airway' not in already_processed:
            already_processed.add('airway')
            outfile.write(' airway=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.airway), input_name='airway')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='RouteSegmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routePoint is not None:
            namespaceprefix_ = self.routePoint_nsprefix_ + ':' if (UseCapturedNS_ and self.routePoint_nsprefix_) else ''
            self.routePoint.export(outfile, level, namespaceprefix_, namespacedef_='', name_='routePoint', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('airway', node)
        if value is not None and 'airway' not in already_processed:
            already_processed.add('airway')
            self.airway = value
            self.validate_AtsRouteType(self.airway)    # validate type AtsRouteType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'routePoint':
            obj_ = RoutePointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.routePoint = obj_
            obj_.original_tagname_ = 'routePoint'
# end class RouteSegmentType


class SpeedScheduleType(GeneratedsSuper):
    """Defines the speed schedule for climb and descent of the aircraft through
    the crossover
    altitude.
    .Speed Schedule - Climb: Initially submitted by the airspace user, this
    defines the
    target speed in both Initial Airspeed (IAS) and MACH so the aircraft can
    climb through
    the crossover altitude and target the MACH speed when needed.
    .Speed Schedule - Descent: Initially submitted by the airspace user, this
    defines
    the target speed in both IAS and MACH so the aircraft can descend through
    the crossover
    altitude and target the Initial Airspeed (IAS) speed when needed."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, initialSpeed=None, subsequentSpeed=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.initialSpeed = initialSpeed
        self.initialSpeed_nsprefix_ = None
        self.subsequentSpeed = subsequentSpeed
        self.subsequentSpeed_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpeedScheduleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpeedScheduleType.subclass:
            return SpeedScheduleType.subclass(*args_, **kwargs_)
        else:
            return SpeedScheduleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_initialSpeed(self):
        return self.initialSpeed
    def set_initialSpeed(self, initialSpeed):
        self.initialSpeed = initialSpeed
    def get_subsequentSpeed(self):
        return self.subsequentSpeed
    def set_subsequentSpeed(self, subsequentSpeed):
        self.subsequentSpeed = subsequentSpeed
    def hasContent_(self):
        if (
            self.initialSpeed is not None or
            self.subsequentSpeed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='SpeedScheduleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpeedScheduleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpeedScheduleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpeedScheduleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='SpeedScheduleType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0"', name_='SpeedScheduleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initialSpeed is not None:
            namespaceprefix_ = self.initialSpeed_nsprefix_ + ':' if (UseCapturedNS_ and self.initialSpeed_nsprefix_) else ''
            self.initialSpeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='initialSpeed', pretty_print=pretty_print)
        if self.subsequentSpeed is not None:
            namespaceprefix_ = self.subsequentSpeed_nsprefix_ + ':' if (UseCapturedNS_ and self.subsequentSpeed_nsprefix_) else ''
            self.subsequentSpeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subsequentSpeed', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'initialSpeed':
            class_obj_ = self.get_class_obj_(child_, AirspeedInIasOrMachType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.initialSpeed = obj_
            obj_.original_tagname_ = 'initialSpeed'
        elif nodeName_ == 'subsequentSpeed':
            class_obj_ = self.get_class_obj_(child_, AirspeedInIasOrMachType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subsequentSpeed = obj_
            obj_.original_tagname_ = 'subsequentSpeed'
# end class SpeedScheduleType


class RouteConstraintOrPreferenceType(GeneratedsSuper):
    """A constraint that is applicable to a route. Can be any of the several
    defined constraints.
    .Constraint Category: Specifies the category (implying a relative
    importance) of
    the constraint associated with a point in the route or expanded route."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, constraintType=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.constraintType = _cast(None, constraintType)
        self.constraintType_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RouteConstraintOrPreferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RouteConstraintOrPreferenceType.subclass:
            return RouteConstraintOrPreferenceType.subclass(*args_, **kwargs_)
        else:
            return RouteConstraintOrPreferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_constraintType(self):
        return self.constraintType
    def set_constraintType(self, constraintType):
        self.constraintType = constraintType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ConstraintOrPreferenceCategoryType(self, value):
        # Validate type fx:ConstraintOrPreferenceCategoryType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['EXECUTIVE_CONTROL', 'CONTROLLER_TACTICAL_PLANNING', 'NETWORK_STRATEGIC', 'OPERATOR_CONSTRAINT', 'FLIGHT_PLAN_EXPECTATION']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ConstraintOrPreferenceCategoryType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='RouteConstraintOrPreferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RouteConstraintOrPreferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RouteConstraintOrPreferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RouteConstraintOrPreferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='RouteConstraintOrPreferenceType'):
        if self.constraintType is not None and 'constraintType' not in already_processed:
            already_processed.add('constraintType')
            outfile.write(' constraintType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.constraintType), input_name='constraintType')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='RouteConstraintOrPreferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('constraintType', node)
        if value is not None and 'constraintType' not in already_processed:
            already_processed.add('constraintType')
            self.constraintType = value
            self.validate_ConstraintOrPreferenceCategoryType(self.constraintType)    # validate type ConstraintOrPreferenceCategoryType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RouteConstraintOrPreferenceType


class SpeedConstraintType(RouteConstraintOrPreferenceType):
    """.Route-Change Speed and Altitude: The planned speed and altitude the
    aircraft will
    change to either prior to, or after reaching, the associated Significant
    Point along
    its Route.
    .Change Speed and Altitude: The planned speed and altitude that the
    aircraft will
    change to upon reaching the associated Significant Point along its Route.
    Qualifies the position associated with the speed constraint."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RouteConstraintOrPreferenceType
    def __init__(self, constraintType=None, positionQualification=None, speed=None, timeConstraint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SpeedConstraintType, self).__init__(constraintType,  **kwargs_)
        self.positionQualification = _cast(None, positionQualification)
        self.positionQualification_nsprefix_ = None
        self.speed = speed
        self.speed_nsprefix_ = None
        self.timeConstraint = timeConstraint
        self.timeConstraint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpeedConstraintType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpeedConstraintType.subclass:
            return SpeedConstraintType.subclass(*args_, **kwargs_)
        else:
            return SpeedConstraintType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_speed(self):
        return self.speed
    def set_speed(self, speed):
        self.speed = speed
    def get_timeConstraint(self):
        return self.timeConstraint
    def set_timeConstraint(self, timeConstraint):
        self.timeConstraint = timeConstraint
    def get_positionQualification(self):
        return self.positionQualification
    def set_positionQualification(self, positionQualification):
        self.positionQualification = positionQualification
    def validate_PositionQualifierType(self, value):
        # Validate type fx:PositionQualifierType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AT_OR_BEFORE_POINT', 'AT_POINT', 'AT_OR_AFTER_POINT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PositionQualifierType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.speed is not None or
            self.timeConstraint is not None or
            super(SpeedConstraintType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='SpeedConstraintType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpeedConstraintType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpeedConstraintType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpeedConstraintType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='SpeedConstraintType'):
        super(SpeedConstraintType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpeedConstraintType')
        if self.positionQualification is not None and 'positionQualification' not in already_processed:
            already_processed.add('positionQualification')
            outfile.write(' positionQualification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.positionQualification), input_name='positionQualification')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:fx="http://www.fixm.aero/flight/3.0" ', name_='SpeedConstraintType', fromsubclass_=False, pretty_print=True):
        super(SpeedConstraintType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.speed is not None:
            namespaceprefix_ = self.speed_nsprefix_ + ':' if (UseCapturedNS_ and self.speed_nsprefix_) else ''
            self.speed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='speed', pretty_print=pretty_print)
        if self.timeConstraint is not None:
            namespaceprefix_ = self.timeConstraint_nsprefix_ + ':' if (UseCapturedNS_ and self.timeConstraint_nsprefix_) else ''
            self.timeConstraint.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timeConstraint', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('positionQualification', node)
        if value is not None and 'positionQualification' not in already_processed:
            already_processed.add('positionQualification')
            self.positionQualification = value
            self.validate_PositionQualifierType(self.positionQualification)    # validate type PositionQualifierType
        super(SpeedConstraintType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'speed':
            obj_ = TrueAirspeedOrMachType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.speed = obj_
            obj_.original_tagname_ = 'speed'
        elif nodeName_ == 'timeConstraint':
            obj_ = TimeConstraintType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeConstraint = obj_
            obj_.original_tagname_ = 'timeConstraint'
        super(SpeedConstraintType, self).buildChildren(child_, node, nodeName_, True)
# end class SpeedConstraintType


class TimeConstraintType(RouteConstraintOrPreferenceType):
    """Time Constraint associated with a route point or with other constraint.
    .Route-Change Speed and Altitude at Time: The planned speed and altitude
    the aircraft
    will change to relative to the associated time.
    .Route-Fix Time - Required: Contains the time at fix and the time at fix
    constraint
    condition, which together describe when the aircraft should arrive at a
    particular
    fix.
    Time associated with the time constraint.
    Qualifies the time associated with the constraint."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RouteConstraintOrPreferenceType
    def __init__(self, constraintType=None, requiredTime=None, timeQualification=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TimeConstraintType, self).__init__(constraintType,  **kwargs_)
        self.requiredTime = _cast(None, requiredTime)
        self.requiredTime_nsprefix_ = None
        self.timeQualification = _cast(None, timeQualification)
        self.timeQualification_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeConstraintType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeConstraintType.subclass:
            return TimeConstraintType.subclass(*args_, **kwargs_)
        else:
            return TimeConstraintType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_requiredTime(self):
        return self.requiredTime
    def set_requiredTime(self, requiredTime):
        self.requiredTime = requiredTime
    def get_timeQualification(self):
        return self.timeQualification
    def set_timeQualification(self, timeQualification):
        self.timeQualification = timeQualification
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_TimeQualifierType(self, value):
        # Validate type fx:TimeQualifierType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AT_OR_BEFORE_TIME', 'AT_TIME', 'AT_OR_AFTER_TIME', 'UNTIL_TIME']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TimeQualifierType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(TimeConstraintType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='TimeConstraintType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeConstraintType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeConstraintType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeConstraintType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='TimeConstraintType'):
        super(TimeConstraintType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeConstraintType')
        if self.requiredTime is not None and 'requiredTime' not in already_processed:
            already_processed.add('requiredTime')
            outfile.write(' requiredTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.requiredTime), input_name='requiredTime')), ))
        if self.timeQualification is not None and 'timeQualification' not in already_processed:
            already_processed.add('timeQualification')
            outfile.write(' timeQualification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.timeQualification), input_name='timeQualification')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='TimeConstraintType', fromsubclass_=False, pretty_print=True):
        super(TimeConstraintType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('requiredTime', node)
        if value is not None and 'requiredTime' not in already_processed:
            already_processed.add('requiredTime')
            try:
                self.requiredTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (requiredTime): %s' % exp)
            self.validate_TimeType(self.requiredTime)    # validate type TimeType
        value = find_attr_value_('timeQualification', node)
        if value is not None and 'timeQualification' not in already_processed:
            already_processed.add('timeQualification')
            self.timeQualification = value
            self.validate_TimeQualifierType(self.timeQualification)    # validate type TimeQualifierType
        super(TimeConstraintType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TimeConstraintType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TimeConstraintType


class FlightStatusType(FeatureType):
    """.Flight Status: Identification of the aspect of the flight life cycle.
    .Flight Plan Accepted Indicator: An indicator of acceptance of the flight
    plan by
    the appropriate ATS authority.
    .Hold State - Airborne Indicator: Specifies whether or not the aircraft is
    in an
    airborne hold.
    .Airfile Indicator: An indication the information about this flight was
    filed from
    the air.
    Flight Cycle is contains a mutually exclusive set of values representing
    stages of
    flight.
    .Flight Completed Indicator: An indicator that the flight was airborne and
    is now
    completed.
    .Flight Cancelled Indicator: Indication the flight has been cancelled after
    Flight
    Object creation.
    .Flight Filed Indicator: An indicator that flight information was filed to
    the appropriate
    Air Traffic Services authority.
    .Airborne Indicator: An indication of whether the flight is airborne or
    not.
    .Flight Scheduled Indicator: An indicator a flight has been created in the
    Air Traffic
    Services system and is expected to operate.
    .Missed Approach Indicator: An indicator that a flight executed a missed
    approach.
    .Flight Suspended Indicator: An indicator a flight has been suspended in
    the Air
    Traffic Services system."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FeatureType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, accepted=None, airborneHold=None, airfile=None, flightCycle=None, missedApproach=None, suspended=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FlightStatusType, self).__init__(centre, source, system, timestamp, extensiontype_,  **kwargs_)
        self.accepted = _cast(None, accepted)
        self.accepted_nsprefix_ = None
        self.airborneHold = _cast(None, airborneHold)
        self.airborneHold_nsprefix_ = None
        self.airfile = _cast(None, airfile)
        self.airfile_nsprefix_ = None
        self.flightCycle = _cast(None, flightCycle)
        self.flightCycle_nsprefix_ = None
        self.missedApproach = _cast(None, missedApproach)
        self.missedApproach_nsprefix_ = None
        self.suspended = _cast(None, suspended)
        self.suspended_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlightStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlightStatusType.subclass:
            return FlightStatusType.subclass(*args_, **kwargs_)
        else:
            return FlightStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accepted(self):
        return self.accepted
    def set_accepted(self, accepted):
        self.accepted = accepted
    def get_airborneHold(self):
        return self.airborneHold
    def set_airborneHold(self, airborneHold):
        self.airborneHold = airborneHold
    def get_airfile(self):
        return self.airfile
    def set_airfile(self, airfile):
        self.airfile = airfile
    def get_flightCycle(self):
        return self.flightCycle
    def set_flightCycle(self, flightCycle):
        self.flightCycle = flightCycle
    def get_missedApproach(self):
        return self.missedApproach
    def set_missedApproach(self, missedApproach):
        self.missedApproach = missedApproach
    def get_suspended(self):
        return self.suspended
    def set_suspended(self, suspended):
        self.suspended = suspended
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_FlightAcceptedIndicatorType(self, value):
        # Validate type fx:FlightAcceptedIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACCEPTED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FlightAcceptedIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_AirborneHoldIndicatorType(self, value):
        # Validate type fx:AirborneHoldIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AIRBORNE_HOLD', 'NOT_AIRBORNE_HOLD']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AirborneHoldIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_AirfileIndicatorType(self, value):
        # Validate type fx:AirfileIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AIRFILE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AirfileIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_FlightCycleType(self, value):
        # Validate type fx:FlightCycleType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['FILED', 'SCHEDULED', 'AIRBORNE', 'COMPLETED', 'CANCELLED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FlightCycleType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_MissedApproachIndicatorType(self, value):
        # Validate type fx:MissedApproachIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MISSED_APPROACH']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MissedApproachIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_FlightSuspendedIndicatorType(self, value):
        # Validate type fx:FlightSuspendedIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SUSPENDED', 'NOT_SUSPENDED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FlightSuspendedIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(FlightStatusType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='FlightStatusType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlightStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlightStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlightStatusType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='FlightStatusType'):
        super(FlightStatusType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlightStatusType')
        if self.accepted is not None and 'accepted' not in already_processed:
            already_processed.add('accepted')
            outfile.write(' accepted=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accepted), input_name='accepted')), ))
        if self.airborneHold is not None and 'airborneHold' not in already_processed:
            already_processed.add('airborneHold')
            outfile.write(' airborneHold=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.airborneHold), input_name='airborneHold')), ))
        if self.airfile is not None and 'airfile' not in already_processed:
            already_processed.add('airfile')
            outfile.write(' airfile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.airfile), input_name='airfile')), ))
        if self.flightCycle is not None and 'flightCycle' not in already_processed:
            already_processed.add('flightCycle')
            outfile.write(' flightCycle=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.flightCycle), input_name='flightCycle')), ))
        if self.missedApproach is not None and 'missedApproach' not in already_processed:
            already_processed.add('missedApproach')
            outfile.write(' missedApproach=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.missedApproach), input_name='missedApproach')), ))
        if self.suspended is not None and 'suspended' not in already_processed:
            already_processed.add('suspended')
            outfile.write(' suspended=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.suspended), input_name='suspended')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='FlightStatusType', fromsubclass_=False, pretty_print=True):
        super(FlightStatusType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accepted', node)
        if value is not None and 'accepted' not in already_processed:
            already_processed.add('accepted')
            self.accepted = value
            self.validate_FlightAcceptedIndicatorType(self.accepted)    # validate type FlightAcceptedIndicatorType
        value = find_attr_value_('airborneHold', node)
        if value is not None and 'airborneHold' not in already_processed:
            already_processed.add('airborneHold')
            self.airborneHold = value
            self.validate_AirborneHoldIndicatorType(self.airborneHold)    # validate type AirborneHoldIndicatorType
        value = find_attr_value_('airfile', node)
        if value is not None and 'airfile' not in already_processed:
            already_processed.add('airfile')
            self.airfile = value
            self.validate_AirfileIndicatorType(self.airfile)    # validate type AirfileIndicatorType
        value = find_attr_value_('flightCycle', node)
        if value is not None and 'flightCycle' not in already_processed:
            already_processed.add('flightCycle')
            self.flightCycle = value
            self.validate_FlightCycleType(self.flightCycle)    # validate type FlightCycleType
        value = find_attr_value_('missedApproach', node)
        if value is not None and 'missedApproach' not in already_processed:
            already_processed.add('missedApproach')
            self.missedApproach = value
            self.validate_MissedApproachIndicatorType(self.missedApproach)    # validate type MissedApproachIndicatorType
        value = find_attr_value_('suspended', node)
        if value is not None and 'suspended' not in already_processed:
            already_processed.add('suspended')
            self.suspended = value
            self.validate_FlightSuspendedIndicatorType(self.suspended)    # validate type FlightSuspendedIndicatorType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(FlightStatusType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(FlightStatusType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FlightStatusType


class CmsAccuracyType(DistanceType):
    """.Performance-Based Navigation Accuracy: This is the flight's navigation
    accuracy
    value for the phase of flight, specified in the Performance-Based
    Navigation Phase.
    .Performance-Based Navigation Phase: The phase of flight for which
    navigation performance
    is being recorded.
    .Performance-Based Navigation Category: This is an enumeration indicating
    whether
    the accuracy measure in Performance-Based Navigation Accuracy is measuring
    Area Navigation
    (RNAV) or Required Navigation Performance (RNP)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DistanceType
    def __init__(self, uom=None, phase=None, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CmsAccuracyType, self).__init__(uom, valueOf_,  **kwargs_)
        self.phase = _cast(None, phase)
        self.phase_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CmsAccuracyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CmsAccuracyType.subclass:
            return CmsAccuracyType.subclass(*args_, **kwargs_)
        else:
            return CmsAccuracyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_phase(self):
        return self.phase
    def set_phase(self, phase):
        self.phase = phase
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_NasPerformanceBasedNavigationPhaseType(self, value):
        # Validate type nas:NasPerformanceBasedNavigationPhaseType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEPARTURE', 'ARRIVAL', 'ENROUTE', 'OCEANIC', 'SPARE_1', 'SPARE_2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NasPerformanceBasedNavigationPhaseType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_CmsAccuracyTypeType(self, value):
        # Validate type nas:CmsAccuracyTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['RNV', 'RNP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CmsAccuracyTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(CmsAccuracyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='CmsAccuracyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CmsAccuracyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CmsAccuracyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CmsAccuracyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='CmsAccuracyType'):
        super(CmsAccuracyType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CmsAccuracyType')
        if self.phase is not None and 'phase' not in already_processed:
            already_processed.add('phase')
            outfile.write(' phase=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.phase), input_name='phase')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='CmsAccuracyType', fromsubclass_=False, pretty_print=True):
        super(CmsAccuracyType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('phase', node)
        if value is not None and 'phase' not in already_processed:
            already_processed.add('phase')
            self.phase = value
            self.validate_NasPerformanceBasedNavigationPhaseType(self.phase)    # validate type NasPerformanceBasedNavigationPhaseType
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_CmsAccuracyTypeType(self.type_)    # validate type CmsAccuracyTypeType
        super(CmsAccuracyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CmsAccuracyType


class NasAircraftType(AircraftType):
    """NAS specific extensions to aircraft information
    .Airborne Equipment Qualifier: A value assigned to the aircraft, based on
    its navigational
    equipment, whether or not it has a transponder, and if it has a
    transponder, whether
    the transponder supports Mode C.
    .Wake Turbulence Category - NAS: NAS classification of the aircraft wake
    turbulence,
    based on wingspan and Maximum Takeoff Weight (MTOW).
    .Special Aircraft Qualifier: Indicates the flight is a heavy jet, B757 or,
    if not
    present, a large jet and if the flight is either equipped or not with TCAS.
    This
    indicator is used for output purposes such as strip printing and message
    transfers
    to other facilities such as Automated Radar Terminal System (ARTS)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AircraftType
    def __init__(self, equipmentQualifier=None, nasWakeTurbulence=None, tfmsSpecialAircraftQualifier=None, accuracy=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasAircraftType, self).__init__( **kwargs_)
        self.equipmentQualifier = _cast(None, equipmentQualifier)
        self.equipmentQualifier_nsprefix_ = None
        self.nasWakeTurbulence = _cast(None, nasWakeTurbulence)
        self.nasWakeTurbulence_nsprefix_ = None
        self.tfmsSpecialAircraftQualifier = _cast(None, tfmsSpecialAircraftQualifier)
        self.tfmsSpecialAircraftQualifier_nsprefix_ = None
        self.accuracy = accuracy
        self.accuracy_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasAircraftType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasAircraftType.subclass:
            return NasAircraftType.subclass(*args_, **kwargs_)
        else:
            return NasAircraftType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accuracy(self):
        return self.accuracy
    def set_accuracy(self, accuracy):
        self.accuracy = accuracy
    def get_equipmentQualifier(self):
        return self.equipmentQualifier
    def set_equipmentQualifier(self, equipmentQualifier):
        self.equipmentQualifier = equipmentQualifier
    def get_nasWakeTurbulence(self):
        return self.nasWakeTurbulence
    def set_nasWakeTurbulence(self, nasWakeTurbulence):
        self.nasWakeTurbulence = nasWakeTurbulence
    def get_tfmsSpecialAircraftQualifier(self):
        return self.tfmsSpecialAircraftQualifier
    def set_tfmsSpecialAircraftQualifier(self, tfmsSpecialAircraftQualifier):
        self.tfmsSpecialAircraftQualifier = tfmsSpecialAircraftQualifier
    def validate_NasAirborneEquipmentQualifierType(self, value):
        # Validate type nas:NasAirborneEquipmentQualifierType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['X', 'T', 'U', 'D', 'B', 'A', 'M', 'N', 'P', 'Y', 'C', 'I', 'H', 'S', 'G', 'V', 'Z', 'L', 'W']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NasAirborneEquipmentQualifierType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_WakeTurbulenceCategoryExtendedType(self, value):
        # Validate type nas:WakeTurbulenceCategoryExtendedType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'B', 'C', 'D', 'E', 'F']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on WakeTurbulenceCategoryExtendedType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_NasSpecialAircraftQualifierType(self, value):
        # Validate type nas:NasSpecialAircraftQualifierType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['HEAVY_JET', 'TCAS', 'B757', 'B757_TCAS', 'HEAVY_JET_AND_TCAS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NasSpecialAircraftQualifierType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.accuracy is not None or
            super(NasAircraftType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasAircraftType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasAircraftType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasAircraftType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasAircraftType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasAircraftType'):
        super(NasAircraftType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasAircraftType')
        if self.equipmentQualifier is not None and 'equipmentQualifier' not in already_processed:
            already_processed.add('equipmentQualifier')
            outfile.write(' equipmentQualifier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.equipmentQualifier), input_name='equipmentQualifier')), ))
        if self.nasWakeTurbulence is not None and 'nasWakeTurbulence' not in already_processed:
            already_processed.add('nasWakeTurbulence')
            outfile.write(' nasWakeTurbulence=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nasWakeTurbulence), input_name='nasWakeTurbulence')), ))
        if self.tfmsSpecialAircraftQualifier is not None and 'tfmsSpecialAircraftQualifier' not in already_processed:
            already_processed.add('tfmsSpecialAircraftQualifier')
            outfile.write(' tfmsSpecialAircraftQualifier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tfmsSpecialAircraftQualifier), input_name='tfmsSpecialAircraftQualifier')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasAircraftType', fromsubclass_=False, pretty_print=True):
        super(NasAircraftType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.accuracy is not None:
            namespaceprefix_ = self.accuracy_nsprefix_ + ':' if (UseCapturedNS_ and self.accuracy_nsprefix_) else ''
            self.accuracy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accuracy', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('equipmentQualifier', node)
        if value is not None and 'equipmentQualifier' not in already_processed:
            already_processed.add('equipmentQualifier')
            self.equipmentQualifier = value
            self.validate_NasAirborneEquipmentQualifierType(self.equipmentQualifier)    # validate type NasAirborneEquipmentQualifierType
        value = find_attr_value_('nasWakeTurbulence', node)
        if value is not None and 'nasWakeTurbulence' not in already_processed:
            already_processed.add('nasWakeTurbulence')
            self.nasWakeTurbulence = value
            self.validate_WakeTurbulenceCategoryExtendedType(self.nasWakeTurbulence)    # validate type WakeTurbulenceCategoryExtendedType
        value = find_attr_value_('tfmsSpecialAircraftQualifier', node)
        if value is not None and 'tfmsSpecialAircraftQualifier' not in already_processed:
            already_processed.add('tfmsSpecialAircraftQualifier')
            self.tfmsSpecialAircraftQualifier = value
            self.validate_NasSpecialAircraftQualifierType(self.tfmsSpecialAircraftQualifier)    # validate type NasSpecialAircraftQualifierType
        super(NasAircraftType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accuracy':
            obj_ = NasPerformanceBasedAccuracyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accuracy = obj_
            obj_.original_tagname_ = 'accuracy'
        super(NasAircraftType, self).buildChildren(child_, node, nodeName_, True)
# end class NasAircraftType


class NasPerformanceBasedAccuracyType(GeneratedsSuper):
    """NAS extension for Performance-Based Navigation Accuracy.
    .Performance-Based Navigation Accuracy: This is the flight's navigation
    accuracy
    value for the phase of flight, specified in the Performance-Based
    Navigation Phase.
    .Performance-Based Navigation Category: This is an enumeration indicating
    whether
    the accuracy measure in Performance-Based Navigation Accuracy is measuring
    Area Navigation
    (RNAV) or Required Navigation Performance (RNP)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, cmsFieldType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if cmsFieldType is None:
            self.cmsFieldType = []
        else:
            self.cmsFieldType = cmsFieldType
        self.cmsFieldType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasPerformanceBasedAccuracyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasPerformanceBasedAccuracyType.subclass:
            return NasPerformanceBasedAccuracyType.subclass(*args_, **kwargs_)
        else:
            return NasPerformanceBasedAccuracyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cmsFieldType(self):
        return self.cmsFieldType
    def set_cmsFieldType(self, cmsFieldType):
        self.cmsFieldType = cmsFieldType
    def add_cmsFieldType(self, value):
        self.cmsFieldType.append(value)
    def insert_cmsFieldType_at(self, index, value):
        self.cmsFieldType.insert(index, value)
    def replace_cmsFieldType_at(self, index, value):
        self.cmsFieldType[index] = value
    def hasContent_(self):
        if (
            self.cmsFieldType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasPerformanceBasedAccuracyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasPerformanceBasedAccuracyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasPerformanceBasedAccuracyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasPerformanceBasedAccuracyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasPerformanceBasedAccuracyType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasPerformanceBasedAccuracyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cmsFieldType_ in self.cmsFieldType:
            namespaceprefix_ = self.cmsFieldType_nsprefix_ + ':' if (UseCapturedNS_ and self.cmsFieldType_nsprefix_) else ''
            cmsFieldType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cmsFieldType', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cmsFieldType':
            obj_ = CmsAccuracyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cmsFieldType.append(obj_)
            obj_.original_tagname_ = 'cmsFieldType'
# end class NasPerformanceBasedAccuracyType


class AboveAltitudeType(AltitudeType):
    """aircraft operating above a specified altitude"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AltitudeType
    def __init__(self, ref=None, uom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AboveAltitudeType, self).__init__(ref, uom, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AboveAltitudeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AboveAltitudeType.subclass:
            return AboveAltitudeType.subclass(*args_, **kwargs_)
        else:
            return AboveAltitudeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AboveAltitudeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='AboveAltitudeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AboveAltitudeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AboveAltitudeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AboveAltitudeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='AboveAltitudeType'):
        super(AboveAltitudeType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AboveAltitudeType')
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='AboveAltitudeType', fromsubclass_=False, pretty_print=True):
        super(AboveAltitudeType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AboveAltitudeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AboveAltitudeType


class AltFixAltAltitudeType(GeneratedsSuper):
    """Alt-fix-alt altitude is defined as an altitude prior to a specified fix,
    the specified
    fix itself, and altitude post specified fix."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, point=None, post=None, pre=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.point = point
        self.point_nsprefix_ = None
        self.post = post
        self.post_nsprefix_ = None
        self.pre = pre
        self.pre_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AltFixAltAltitudeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AltFixAltAltitudeType.subclass:
            return AltFixAltAltitudeType.subclass(*args_, **kwargs_)
        else:
            return AltFixAltAltitudeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_point(self):
        return self.point
    def set_point(self, point):
        self.point = point
    def set_point_with_type(self, value):
        self.point = value
        value.original_tagname_ = 'point'
        value.extensiontype_ = value.__class__.__name__
    def get_post(self):
        return self.post
    def set_post(self, post):
        self.post = post
    def get_pre(self):
        return self.pre
    def set_pre(self, pre):
        self.pre = pre
    def hasContent_(self):
        if (
            self.point is not None or
            self.post is not None or
            self.pre is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='AltFixAltAltitudeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AltFixAltAltitudeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AltFixAltAltitudeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AltFixAltAltitudeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='AltFixAltAltitudeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='AltFixAltAltitudeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.point is not None:
            self.point.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.post is not None:
            namespaceprefix_ = self.post_nsprefix_ + ':' if (UseCapturedNS_ and self.post_nsprefix_) else ''
            self.post.export(outfile, level, namespaceprefix_, namespacedef_='', name_='post', pretty_print=pretty_print)
        if self.pre is not None:
            namespaceprefix_ = self.pre_nsprefix_ + ':' if (UseCapturedNS_ and self.pre_nsprefix_) else ''
            self.pre.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pre', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'point':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <point> element')
            self.point = obj_
            obj_.original_tagname_ = 'point'
        elif nodeName_ == 'post':
            class_obj_ = self.get_class_obj_(child_, AltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.post = obj_
            obj_.original_tagname_ = 'post'
        elif nodeName_ == 'pre':
            class_obj_ = self.get_class_obj_(child_, AltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pre = obj_
            obj_.original_tagname_ = 'pre'
# end class AltFixAltAltitudeType


class BlockAltitudeType(GeneratedsSuper):
    """Altitude indicates that aircraft is operating above and below the
    specified altitudes."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, above=None, below=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.above = above
        self.above_nsprefix_ = None
        self.below = below
        self.below_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BlockAltitudeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BlockAltitudeType.subclass:
            return BlockAltitudeType.subclass(*args_, **kwargs_)
        else:
            return BlockAltitudeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_above(self):
        return self.above
    def set_above(self, above):
        self.above = above
    def get_below(self):
        return self.below
    def set_below(self, below):
        self.below = below
    def hasContent_(self):
        if (
            self.above is not None or
            self.below is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='BlockAltitudeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BlockAltitudeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BlockAltitudeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BlockAltitudeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='BlockAltitudeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='BlockAltitudeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.above is not None:
            namespaceprefix_ = self.above_nsprefix_ + ':' if (UseCapturedNS_ and self.above_nsprefix_) else ''
            self.above.export(outfile, level, namespaceprefix_, namespacedef_='', name_='above', pretty_print=pretty_print)
        if self.below is not None:
            namespaceprefix_ = self.below_nsprefix_ + ':' if (UseCapturedNS_ and self.below_nsprefix_) else ''
            self.below.export(outfile, level, namespaceprefix_, namespacedef_='', name_='below', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'above':
            class_obj_ = self.get_class_obj_(child_, AltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.above = obj_
            obj_.original_tagname_ = 'above'
        elif nodeName_ == 'below':
            class_obj_ = self.get_class_obj_(child_, AltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.below = obj_
            obj_.original_tagname_ = 'below'
# end class BlockAltitudeType


class NasAltitudeType(GeneratedsSuper):
    """A single NAS altitude, which can take on any of the several forms listed
    in the
    "choice" below."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, above=None, altFixAlt=None, block=None, simple=None, vfr=None, vfrOnTop=None, vfrOnTopPlus=None, vfrPlus=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.above = above
        self.above_nsprefix_ = None
        self.altFixAlt = altFixAlt
        self.altFixAlt_nsprefix_ = None
        self.block = block
        self.block_nsprefix_ = None
        self.simple = simple
        self.simple_nsprefix_ = None
        self.vfr = vfr
        self.vfr_nsprefix_ = None
        self.vfrOnTop = vfrOnTop
        self.vfrOnTop_nsprefix_ = None
        self.vfrOnTopPlus = vfrOnTopPlus
        self.vfrOnTopPlus_nsprefix_ = None
        self.vfrPlus = vfrPlus
        self.vfrPlus_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasAltitudeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasAltitudeType.subclass:
            return NasAltitudeType.subclass(*args_, **kwargs_)
        else:
            return NasAltitudeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_above(self):
        return self.above
    def set_above(self, above):
        self.above = above
    def get_altFixAlt(self):
        return self.altFixAlt
    def set_altFixAlt(self, altFixAlt):
        self.altFixAlt = altFixAlt
    def get_block(self):
        return self.block
    def set_block(self, block):
        self.block = block
    def get_simple(self):
        return self.simple
    def set_simple(self, simple):
        self.simple = simple
    def get_vfr(self):
        return self.vfr
    def set_vfr(self, vfr):
        self.vfr = vfr
    def get_vfrOnTop(self):
        return self.vfrOnTop
    def set_vfrOnTop(self, vfrOnTop):
        self.vfrOnTop = vfrOnTop
    def get_vfrOnTopPlus(self):
        return self.vfrOnTopPlus
    def set_vfrOnTopPlus(self, vfrOnTopPlus):
        self.vfrOnTopPlus = vfrOnTopPlus
    def get_vfrPlus(self):
        return self.vfrPlus
    def set_vfrPlus(self, vfrPlus):
        self.vfrPlus = vfrPlus
    def hasContent_(self):
        if (
            self.above is not None or
            self.altFixAlt is not None or
            self.block is not None or
            self.simple is not None or
            self.vfr is not None or
            self.vfrOnTop is not None or
            self.vfrOnTopPlus is not None or
            self.vfrPlus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasAltitudeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasAltitudeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasAltitudeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasAltitudeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasAltitudeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasAltitudeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.above is not None:
            namespaceprefix_ = self.above_nsprefix_ + ':' if (UseCapturedNS_ and self.above_nsprefix_) else ''
            self.above.export(outfile, level, namespaceprefix_, namespacedef_='', name_='above', pretty_print=pretty_print)
        if self.altFixAlt is not None:
            namespaceprefix_ = self.altFixAlt_nsprefix_ + ':' if (UseCapturedNS_ and self.altFixAlt_nsprefix_) else ''
            self.altFixAlt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='altFixAlt', pretty_print=pretty_print)
        if self.block is not None:
            namespaceprefix_ = self.block_nsprefix_ + ':' if (UseCapturedNS_ and self.block_nsprefix_) else ''
            self.block.export(outfile, level, namespaceprefix_, namespacedef_='', name_='block', pretty_print=pretty_print)
        if self.simple is not None:
            namespaceprefix_ = self.simple_nsprefix_ + ':' if (UseCapturedNS_ and self.simple_nsprefix_) else ''
            self.simple.export(outfile, level, namespaceprefix_, namespacedef_='', name_='simple', pretty_print=pretty_print)
        if self.vfr is not None:
            namespaceprefix_ = self.vfr_nsprefix_ + ':' if (UseCapturedNS_ and self.vfr_nsprefix_) else ''
            self.vfr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vfr', pretty_print=pretty_print)
        if self.vfrOnTop is not None:
            namespaceprefix_ = self.vfrOnTop_nsprefix_ + ':' if (UseCapturedNS_ and self.vfrOnTop_nsprefix_) else ''
            self.vfrOnTop.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vfrOnTop', pretty_print=pretty_print)
        if self.vfrOnTopPlus is not None:
            namespaceprefix_ = self.vfrOnTopPlus_nsprefix_ + ':' if (UseCapturedNS_ and self.vfrOnTopPlus_nsprefix_) else ''
            self.vfrOnTopPlus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vfrOnTopPlus', pretty_print=pretty_print)
        if self.vfrPlus is not None:
            namespaceprefix_ = self.vfrPlus_nsprefix_ + ':' if (UseCapturedNS_ and self.vfrPlus_nsprefix_) else ''
            self.vfrPlus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vfrPlus', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'above':
            obj_ = AboveAltitudeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.above = obj_
            obj_.original_tagname_ = 'above'
        elif nodeName_ == 'altFixAlt':
            obj_ = AltFixAltAltitudeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.altFixAlt = obj_
            obj_.original_tagname_ = 'altFixAlt'
        elif nodeName_ == 'block':
            obj_ = BlockAltitudeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.block = obj_
            obj_.original_tagname_ = 'block'
        elif nodeName_ == 'simple':
            class_obj_ = self.get_class_obj_(child_, SimpleAltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.simple = obj_
            obj_.original_tagname_ = 'simple'
        elif nodeName_ == 'vfr':
            obj_ = VfrAltitudeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vfr = obj_
            obj_.original_tagname_ = 'vfr'
        elif nodeName_ == 'vfrOnTop':
            obj_ = VfrOnTopAltitudeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vfrOnTop = obj_
            obj_.original_tagname_ = 'vfrOnTop'
        elif nodeName_ == 'vfrOnTopPlus':
            obj_ = VfrOnTopPlusAltitudeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vfrOnTopPlus = obj_
            obj_.original_tagname_ = 'vfrOnTopPlus'
        elif nodeName_ == 'vfrPlus':
            obj_ = VfrPlusAltitudeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vfrPlus = obj_
            obj_.original_tagname_ = 'vfrPlus'
# end class NasAltitudeType


class SimpleAltitudeType(AltitudeType):
    """The only NAS altitude that maps directly to the core ICAO altitude
    types."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AltitudeType
    def __init__(self, ref=None, uom=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SimpleAltitudeType, self).__init__(ref, uom, valueOf_, extensiontype_,  **kwargs_)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleAltitudeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleAltitudeType.subclass:
            return SimpleAltitudeType.subclass(*args_, **kwargs_)
        else:
            return SimpleAltitudeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(SimpleAltitudeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='SimpleAltitudeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SimpleAltitudeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SimpleAltitudeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SimpleAltitudeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='SimpleAltitudeType'):
        super(SimpleAltitudeType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SimpleAltitudeType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='SimpleAltitudeType', fromsubclass_=False, pretty_print=True):
        super(SimpleAltitudeType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SimpleAltitudeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SimpleAltitudeType


class VfrAltitudeType(GeneratedsSuper):
    """vfr altitude"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VfrAltitudeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VfrAltitudeType.subclass:
            return VfrAltitudeType.subclass(*args_, **kwargs_)
        else:
            return VfrAltitudeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='VfrAltitudeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VfrAltitudeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VfrAltitudeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VfrAltitudeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='VfrAltitudeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='VfrAltitudeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class VfrAltitudeType


class VfrOnTopAltitudeType(GeneratedsSuper):
    """vfr-on-top altitude"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VfrOnTopAltitudeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VfrOnTopAltitudeType.subclass:
            return VfrOnTopAltitudeType.subclass(*args_, **kwargs_)
        else:
            return VfrOnTopAltitudeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='VfrOnTopAltitudeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VfrOnTopAltitudeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VfrOnTopAltitudeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VfrOnTopAltitudeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='VfrOnTopAltitudeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='VfrOnTopAltitudeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class VfrOnTopAltitudeType


class VfrOnTopPlusAltitudeType(AltitudeType):
    """vfr-on-top with altitude"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AltitudeType
    def __init__(self, ref=None, uom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(VfrOnTopPlusAltitudeType, self).__init__(ref, uom, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VfrOnTopPlusAltitudeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VfrOnTopPlusAltitudeType.subclass:
            return VfrOnTopPlusAltitudeType.subclass(*args_, **kwargs_)
        else:
            return VfrOnTopPlusAltitudeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(VfrOnTopPlusAltitudeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='VfrOnTopPlusAltitudeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VfrOnTopPlusAltitudeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VfrOnTopPlusAltitudeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VfrOnTopPlusAltitudeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='VfrOnTopPlusAltitudeType'):
        super(VfrOnTopPlusAltitudeType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VfrOnTopPlusAltitudeType')
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='VfrOnTopPlusAltitudeType', fromsubclass_=False, pretty_print=True):
        super(VfrOnTopPlusAltitudeType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VfrOnTopPlusAltitudeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class VfrOnTopPlusAltitudeType


class VfrPlusAltitudeType(AltitudeType):
    """vfr plus altitude"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AltitudeType
    def __init__(self, ref=None, uom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(VfrPlusAltitudeType, self).__init__(ref, uom, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VfrPlusAltitudeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VfrPlusAltitudeType.subclass:
            return VfrPlusAltitudeType.subclass(*args_, **kwargs_)
        else:
            return VfrPlusAltitudeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(VfrPlusAltitudeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='VfrPlusAltitudeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VfrPlusAltitudeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VfrPlusAltitudeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VfrPlusAltitudeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='VfrPlusAltitudeType'):
        super(VfrPlusAltitudeType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VfrPlusAltitudeType')
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='VfrPlusAltitudeType', fromsubclass_=False, pretty_print=True):
        super(VfrPlusAltitudeType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VfrPlusAltitudeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class VfrPlusAltitudeType


class NasArrivalType(FlightArrivalType):
    """Extends core Flight Arrival with NAS specific Extensions.
    .Arrival Center: Indicates the Air Route Traffic Control Center (ARTCC) for
    the arrival
    point for a flight.
    .Arrival Point: The final point or other final entity where the air traffic
    control/management
    system route terminates.
    .Arrival Slot - NAS: A time slot at an airport or airspace entry point that
    identifies
    a point in time when an aircraft is constrained to arrive at the airport or
    airspace
    entry point.
    .Slot Hold Status: If a flight is controlled and cancelled [e.g., has a
    Controlled
    Time of Departure (CTD), Controlled Time of Arrival (CTA), and Arrival Slot
    (ASLOT)],
    the slot hold status indicates whether the slot associated with this flight
    is being
    held, or would be held, by the Airspace User for the next full compression.
    .In-Block Time - Scheduled: Scheduled gate time of arrival for a flight, as
    provided
    by the OAG (Official Airline Guide).
    .Yielded Slot Indicator: Indicates the slot currently specified in Runway
    Arrival
    Time - Controlled is to be given up by the Airspace User in return for a
    later
    slot."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FlightArrivalType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, arrivalFleetPrioritization=None, arrivalSequenceNumber=None, earliestInBlockTime=None, filedRevisedDestinationStar=None, landingLimits=None, standardInstrumentArrival=None, approachFix=None, approachTime=None, arrivalAerodrome=None, arrivalAerodromeAlternate=None, arrivalAerodromeOriginal=None, arrivalFix=None, arrivalFixTime=None, filedRevisedDestinationAerodrome=None, runwayPositionAndTime=None, standPositionAndTime=None, arrivalCenter=None, arrivalPoint=None, arrivalSlot=None, holdStatus=None, scheduledInBlockTime=None, slotYielded=None, runwayArrivalTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasArrivalType, self).__init__(centre, source, system, timestamp, arrivalFleetPrioritization, arrivalSequenceNumber, earliestInBlockTime, filedRevisedDestinationStar, landingLimits, standardInstrumentArrival, approachFix, approachTime, arrivalAerodrome, arrivalAerodromeAlternate, arrivalAerodromeOriginal, arrivalFix, arrivalFixTime, filedRevisedDestinationAerodrome, runwayPositionAndTime, standPositionAndTime,  **kwargs_)
        self.arrivalCenter = _cast(None, arrivalCenter)
        self.arrivalCenter_nsprefix_ = None
        self.arrivalPoint = _cast(None, arrivalPoint)
        self.arrivalPoint_nsprefix_ = None
        self.arrivalSlot = _cast(None, arrivalSlot)
        self.arrivalSlot_nsprefix_ = None
        self.holdStatus = _cast(None, holdStatus)
        self.holdStatus_nsprefix_ = None
        self.scheduledInBlockTime = _cast(None, scheduledInBlockTime)
        self.scheduledInBlockTime_nsprefix_ = None
        self.slotYielded = _cast(None, slotYielded)
        self.slotYielded_nsprefix_ = None
        self.runwayArrivalTime = runwayArrivalTime
        self.runwayArrivalTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasArrivalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasArrivalType.subclass:
            return NasArrivalType.subclass(*args_, **kwargs_)
        else:
            return NasArrivalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_runwayArrivalTime(self):
        return self.runwayArrivalTime
    def set_runwayArrivalTime(self, runwayArrivalTime):
        self.runwayArrivalTime = runwayArrivalTime
    def get_arrivalCenter(self):
        return self.arrivalCenter
    def set_arrivalCenter(self, arrivalCenter):
        self.arrivalCenter = arrivalCenter
    def get_arrivalPoint(self):
        return self.arrivalPoint
    def set_arrivalPoint(self, arrivalPoint):
        self.arrivalPoint = arrivalPoint
    def get_arrivalSlot(self):
        return self.arrivalSlot
    def set_arrivalSlot(self, arrivalSlot):
        self.arrivalSlot = arrivalSlot
    def get_holdStatus(self):
        return self.holdStatus
    def set_holdStatus(self, holdStatus):
        self.holdStatus = holdStatus
    def get_scheduledInBlockTime(self):
        return self.scheduledInBlockTime
    def set_scheduledInBlockTime(self, scheduledInBlockTime):
        self.scheduledInBlockTime = scheduledInBlockTime
    def get_slotYielded(self):
        return self.slotYielded
    def set_slotYielded(self, slotYielded):
        self.slotYielded = slotYielded
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_SlotHoldStatusType(self, value):
        # Validate type nas:SlotHoldStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['HOLD', 'RELEASE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SlotHoldStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_SlotYieldedIndicatorType(self, value):
        # Validate type nas:SlotYieldedIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SLOT_YIELDED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SlotYieldedIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.runwayArrivalTime is not None or
            super(NasArrivalType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasArrivalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasArrivalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasArrivalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasArrivalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasArrivalType'):
        super(NasArrivalType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasArrivalType')
        if self.arrivalCenter is not None and 'arrivalCenter' not in already_processed:
            already_processed.add('arrivalCenter')
            outfile.write(' arrivalCenter=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.arrivalCenter), input_name='arrivalCenter')), ))
        if self.arrivalPoint is not None and 'arrivalPoint' not in already_processed:
            already_processed.add('arrivalPoint')
            outfile.write(' arrivalPoint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.arrivalPoint), input_name='arrivalPoint')), ))
        if self.arrivalSlot is not None and 'arrivalSlot' not in already_processed:
            already_processed.add('arrivalSlot')
            outfile.write(' arrivalSlot=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.arrivalSlot), input_name='arrivalSlot')), ))
        if self.holdStatus is not None and 'holdStatus' not in already_processed:
            already_processed.add('holdStatus')
            outfile.write(' holdStatus=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.holdStatus), input_name='holdStatus')), ))
        if self.scheduledInBlockTime is not None and 'scheduledInBlockTime' not in already_processed:
            already_processed.add('scheduledInBlockTime')
            outfile.write(' scheduledInBlockTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scheduledInBlockTime), input_name='scheduledInBlockTime')), ))
        if self.slotYielded is not None and 'slotYielded' not in already_processed:
            already_processed.add('slotYielded')
            outfile.write(' slotYielded=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.slotYielded), input_name='slotYielded')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasArrivalType', fromsubclass_=False, pretty_print=True):
        super(NasArrivalType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.runwayArrivalTime is not None:
            namespaceprefix_ = self.runwayArrivalTime_nsprefix_ + ':' if (UseCapturedNS_ and self.runwayArrivalTime_nsprefix_) else ''
            self.runwayArrivalTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='runwayArrivalTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('arrivalCenter', node)
        if value is not None and 'arrivalCenter' not in already_processed:
            already_processed.add('arrivalCenter')
            self.arrivalCenter = value
            self.validate_FreeTextType(self.arrivalCenter)    # validate type FreeTextType
        value = find_attr_value_('arrivalPoint', node)
        if value is not None and 'arrivalPoint' not in already_processed:
            already_processed.add('arrivalPoint')
            self.arrivalPoint = value
            self.validate_FreeTextType(self.arrivalPoint)    # validate type FreeTextType
        value = find_attr_value_('arrivalSlot', node)
        if value is not None and 'arrivalSlot' not in already_processed:
            already_processed.add('arrivalSlot')
            self.arrivalSlot = value
            self.validate_FreeTextType(self.arrivalSlot)    # validate type FreeTextType
        value = find_attr_value_('holdStatus', node)
        if value is not None and 'holdStatus' not in already_processed:
            already_processed.add('holdStatus')
            self.holdStatus = value
            self.validate_SlotHoldStatusType(self.holdStatus)    # validate type SlotHoldStatusType
        value = find_attr_value_('scheduledInBlockTime', node)
        if value is not None and 'scheduledInBlockTime' not in already_processed:
            already_processed.add('scheduledInBlockTime')
            try:
                self.scheduledInBlockTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (scheduledInBlockTime): %s' % exp)
            self.validate_TimeType(self.scheduledInBlockTime)    # validate type TimeType
        value = find_attr_value_('slotYielded', node)
        if value is not None and 'slotYielded' not in already_processed:
            already_processed.add('slotYielded')
            self.slotYielded = value
            self.validate_SlotYieldedIndicatorType(self.slotYielded)    # validate type SlotYieldedIndicatorType
        super(NasArrivalType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'runwayArrivalTime':
            obj_ = RunwayArrivalTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.runwayArrivalTime = obj_
            obj_.original_tagname_ = 'runwayArrivalTime'
        super(NasArrivalType, self).buildChildren(child_, node, nodeName_, True)
# end class NasArrivalType


class RunwayAcceptableSlotSubstitutionType(GeneratedsSuper):
    """.Runway Arrival Time - Slot Credit Substitution Earliest Acceptable: The
    earliest
    time at which the Airspace user will accept a slot in a Traffic Management
    Initiative
    (TMI) Ground Delay Program (GDP) in return for a yielded slot.
    .Runway Arrival Time - Slot Credit Substitution Latest Acceptable: The
    latest time
    at which the Airspace user will accept a slot in a Traffic Management
    Initiative
    (TMI) Ground Delay Program (GDP), in return for a yielded slot."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, earliest=None, latest=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.earliest = earliest
        self.earliest_nsprefix_ = None
        self.latest = latest
        self.latest_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RunwayAcceptableSlotSubstitutionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RunwayAcceptableSlotSubstitutionType.subclass:
            return RunwayAcceptableSlotSubstitutionType.subclass(*args_, **kwargs_)
        else:
            return RunwayAcceptableSlotSubstitutionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_earliest(self):
        return self.earliest
    def set_earliest(self, earliest):
        self.earliest = earliest
    def get_latest(self):
        return self.latest
    def set_latest(self, latest):
        self.latest = latest
    def hasContent_(self):
        if (
            self.earliest is not None or
            self.latest is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='RunwayAcceptableSlotSubstitutionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RunwayAcceptableSlotSubstitutionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RunwayAcceptableSlotSubstitutionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RunwayAcceptableSlotSubstitutionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='RunwayAcceptableSlotSubstitutionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='RunwayAcceptableSlotSubstitutionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.earliest is not None:
            namespaceprefix_ = self.earliest_nsprefix_ + ':' if (UseCapturedNS_ and self.earliest_nsprefix_) else ''
            self.earliest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='earliest', pretty_print=pretty_print)
        if self.latest is not None:
            namespaceprefix_ = self.latest_nsprefix_ + ':' if (UseCapturedNS_ and self.latest_nsprefix_) else ''
            self.latest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='latest', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'earliest':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.earliest = obj_
            obj_.original_tagname_ = 'earliest'
        elif nodeName_ == 'latest':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.latest = obj_
            obj_.original_tagname_ = 'latest'
# end class RunwayAcceptableSlotSubstitutionType


class RunwayArrivalTimeType(GeneratedsSuper):
    """Container for NAS Specific Runway Arrival Times."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, airlineEstimated=None, earliest=None, original=None, preferred=None, slotSubstitution=None, tfmsEstimated=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.airlineEstimated = airlineEstimated
        self.airlineEstimated_nsprefix_ = None
        self.earliest = earliest
        self.earliest_nsprefix_ = None
        self.original = original
        self.original_nsprefix_ = None
        self.preferred = preferred
        self.preferred_nsprefix_ = None
        self.slotSubstitution = slotSubstitution
        self.slotSubstitution_nsprefix_ = None
        self.tfmsEstimated = tfmsEstimated
        self.tfmsEstimated_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RunwayArrivalTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RunwayArrivalTimeType.subclass:
            return RunwayArrivalTimeType.subclass(*args_, **kwargs_)
        else:
            return RunwayArrivalTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_airlineEstimated(self):
        return self.airlineEstimated
    def set_airlineEstimated(self, airlineEstimated):
        self.airlineEstimated = airlineEstimated
    def get_earliest(self):
        return self.earliest
    def set_earliest(self, earliest):
        self.earliest = earliest
    def get_original(self):
        return self.original
    def set_original(self, original):
        self.original = original
    def get_preferred(self):
        return self.preferred
    def set_preferred(self, preferred):
        self.preferred = preferred
    def get_slotSubstitution(self):
        return self.slotSubstitution
    def set_slotSubstitution(self, slotSubstitution):
        self.slotSubstitution = slotSubstitution
    def get_tfmsEstimated(self):
        return self.tfmsEstimated
    def set_tfmsEstimated(self, tfmsEstimated):
        self.tfmsEstimated = tfmsEstimated
    def hasContent_(self):
        if (
            self.airlineEstimated is not None or
            self.earliest is not None or
            self.original is not None or
            self.preferred is not None or
            self.slotSubstitution is not None or
            self.tfmsEstimated is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='RunwayArrivalTimeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RunwayArrivalTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RunwayArrivalTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RunwayArrivalTimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='RunwayArrivalTimeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='RunwayArrivalTimeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.airlineEstimated is not None:
            namespaceprefix_ = self.airlineEstimated_nsprefix_ + ':' if (UseCapturedNS_ and self.airlineEstimated_nsprefix_) else ''
            self.airlineEstimated.export(outfile, level, namespaceprefix_, namespacedef_='', name_='airlineEstimated', pretty_print=pretty_print)
        if self.earliest is not None:
            namespaceprefix_ = self.earliest_nsprefix_ + ':' if (UseCapturedNS_ and self.earliest_nsprefix_) else ''
            self.earliest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='earliest', pretty_print=pretty_print)
        if self.original is not None:
            namespaceprefix_ = self.original_nsprefix_ + ':' if (UseCapturedNS_ and self.original_nsprefix_) else ''
            self.original.export(outfile, level, namespaceprefix_, namespacedef_='', name_='original', pretty_print=pretty_print)
        if self.preferred is not None:
            namespaceprefix_ = self.preferred_nsprefix_ + ':' if (UseCapturedNS_ and self.preferred_nsprefix_) else ''
            self.preferred.export(outfile, level, namespaceprefix_, namespacedef_='', name_='preferred', pretty_print=pretty_print)
        if self.slotSubstitution is not None:
            namespaceprefix_ = self.slotSubstitution_nsprefix_ + ':' if (UseCapturedNS_ and self.slotSubstitution_nsprefix_) else ''
            self.slotSubstitution.export(outfile, level, namespaceprefix_, namespacedef_='', name_='slotSubstitution', pretty_print=pretty_print)
        if self.tfmsEstimated is not None:
            namespaceprefix_ = self.tfmsEstimated_nsprefix_ + ':' if (UseCapturedNS_ and self.tfmsEstimated_nsprefix_) else ''
            self.tfmsEstimated.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tfmsEstimated', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'airlineEstimated':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.airlineEstimated = obj_
            obj_.original_tagname_ = 'airlineEstimated'
        elif nodeName_ == 'earliest':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.earliest = obj_
            obj_.original_tagname_ = 'earliest'
        elif nodeName_ == 'original':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.original = obj_
            obj_.original_tagname_ = 'original'
        elif nodeName_ == 'preferred':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.preferred = obj_
            obj_.original_tagname_ = 'preferred'
        elif nodeName_ == 'slotSubstitution':
            obj_ = RunwayAcceptableSlotSubstitutionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.slotSubstitution = obj_
            obj_.original_tagname_ = 'slotSubstitution'
        elif nodeName_ == 'tfmsEstimated':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tfmsEstimated = obj_
            obj_.original_tagname_ = 'tfmsEstimated'
# end class RunwayArrivalTimeType


class NasAdvisoryType(GeneratedsSuper):
    """.NAS Advisory Information: A container for Traffic Flow Management
    advisories pertinent
    to a single flight.
    .Traffic Flow Management Advisory Number: Advisory number issued by traffic
    flow
    management.
    .Traffic Flow Management Advisory Type: The type for the advisory issued by
    traffic
    flow management.
    .Traffic Flow Management Advisory Number: Advisory number issued by traffic
    flow
    management.
    .Traffic Flow Management Advisory Type: The type for the advisory issued by
    traffic
    flow management.
    .Traffic Flow Management Advisory Update Time: The date and time when the
    advisory
    was last updated."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, advisoryNumber=None, advisoryType=None, advisoryUpdateTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.advisoryNumber = _cast(None, advisoryNumber)
        self.advisoryNumber_nsprefix_ = None
        self.advisoryType = _cast(None, advisoryType)
        self.advisoryType_nsprefix_ = None
        self.advisoryUpdateTime = _cast(None, advisoryUpdateTime)
        self.advisoryUpdateTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasAdvisoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasAdvisoryType.subclass:
            return NasAdvisoryType.subclass(*args_, **kwargs_)
        else:
            return NasAdvisoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_advisoryNumber(self):
        return self.advisoryNumber
    def set_advisoryNumber(self, advisoryNumber):
        self.advisoryNumber = advisoryNumber
    def get_advisoryType(self):
        return self.advisoryType
    def set_advisoryType(self, advisoryType):
        self.advisoryType = advisoryType
    def get_advisoryUpdateTime(self):
        return self.advisoryUpdateTime
    def set_advisoryUpdateTime(self, advisoryUpdateTime):
        self.advisoryUpdateTime = advisoryUpdateTime
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_AdvisoryTypeType(self, value):
        # Validate type nas:AdvisoryTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['GDP', 'AFP', 'GDP_CANCEL', 'AFP_CANCEL', 'GS', 'GS_CANCEL', 'REROUTE', 'CTOP', 'CTOP_CANCEL']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AdvisoryTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasAdvisoryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasAdvisoryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasAdvisoryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasAdvisoryType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasAdvisoryType'):
        if self.advisoryNumber is not None and 'advisoryNumber' not in already_processed:
            already_processed.add('advisoryNumber')
            outfile.write(' advisoryNumber=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.advisoryNumber), input_name='advisoryNumber')), ))
        if self.advisoryType is not None and 'advisoryType' not in already_processed:
            already_processed.add('advisoryType')
            outfile.write(' advisoryType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.advisoryType), input_name='advisoryType')), ))
        if self.advisoryUpdateTime is not None and 'advisoryUpdateTime' not in already_processed:
            already_processed.add('advisoryUpdateTime')
            outfile.write(' advisoryUpdateTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.advisoryUpdateTime), input_name='advisoryUpdateTime')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasAdvisoryType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('advisoryNumber', node)
        if value is not None and 'advisoryNumber' not in already_processed:
            already_processed.add('advisoryNumber')
            self.advisoryNumber = value
            self.validate_FreeTextType(self.advisoryNumber)    # validate type FreeTextType
        value = find_attr_value_('advisoryType', node)
        if value is not None and 'advisoryType' not in already_processed:
            already_processed.add('advisoryType')
            self.advisoryType = value
            self.validate_AdvisoryTypeType(self.advisoryType)    # validate type AdvisoryTypeType
        value = find_attr_value_('advisoryUpdateTime', node)
        if value is not None and 'advisoryUpdateTime' not in already_processed:
            already_processed.add('advisoryUpdateTime')
            try:
                self.advisoryUpdateTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (advisoryUpdateTime): %s' % exp)
            self.validate_TimeType(self.advisoryUpdateTime)    # validate type TimeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NasAdvisoryType


class NasRerouteType(GeneratedsSuper):
    """.Traffic Flow Management Reroute Information: A container for
    information pertinent
    to a single NAS reroute issued for a flight by traffic flow management.
    .Traffic Flow Management System Reroute Identifier: Traffic Flow Management
    System
    generated unique identifier for the reroute.
    .Traffic Flow Management System Reroute Name: Traffic Flow Management
    System assigned
    name for the reroute.
    .Traffic Flow Management System Reroute Type: Route type of the assigned
    reroute.
    .Traffic Flow Management System Reroute Inclusion Indicator: Indicates
    whether the
    flight is included or proposed to be included in the traffic management
    reroute initiative.
    .Traffic Flow Management System Reroute Identifier: Traffic Flow Management
    System
    generated unique identifier for the reroute.
    .Traffic Flow Management System Reroute Name: Traffic Flow Management
    System assigned
    name for the reroute.
    .Traffic Flow Management System Reroute Type: Route type of the assigned
    reroute.
    .Traffic Flow Management System Reroute Protected Segment: All or a portion
    of the
    route string that is designated as the protected portion.
    .Traffic Flow Management System Reroute Identifier: Traffic Flow Management
    System
    generated unique identifier for the reroute.
    .Traffic Flow Management System Reroute Name: Traffic Flow Management
    System assigned
    name for the reroute.
    .Traffic Flow Management System Reroute Type: Route type of the assigned
    reroute."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, rerouteIdentifier=None, rerouteInclusionIndicator=None, rerouteName=None, rerouteProtectedSegment=None, rerouteType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.rerouteIdentifier = _cast(None, rerouteIdentifier)
        self.rerouteIdentifier_nsprefix_ = None
        self.rerouteInclusionIndicator = _cast(None, rerouteInclusionIndicator)
        self.rerouteInclusionIndicator_nsprefix_ = None
        self.rerouteName = _cast(None, rerouteName)
        self.rerouteName_nsprefix_ = None
        self.rerouteProtectedSegment = _cast(None, rerouteProtectedSegment)
        self.rerouteProtectedSegment_nsprefix_ = None
        self.rerouteType = _cast(None, rerouteType)
        self.rerouteType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasRerouteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasRerouteType.subclass:
            return NasRerouteType.subclass(*args_, **kwargs_)
        else:
            return NasRerouteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rerouteIdentifier(self):
        return self.rerouteIdentifier
    def set_rerouteIdentifier(self, rerouteIdentifier):
        self.rerouteIdentifier = rerouteIdentifier
    def get_rerouteInclusionIndicator(self):
        return self.rerouteInclusionIndicator
    def set_rerouteInclusionIndicator(self, rerouteInclusionIndicator):
        self.rerouteInclusionIndicator = rerouteInclusionIndicator
    def get_rerouteName(self):
        return self.rerouteName
    def set_rerouteName(self, rerouteName):
        self.rerouteName = rerouteName
    def get_rerouteProtectedSegment(self):
        return self.rerouteProtectedSegment
    def set_rerouteProtectedSegment(self, rerouteProtectedSegment):
        self.rerouteProtectedSegment = rerouteProtectedSegment
    def get_rerouteType(self):
        return self.rerouteType
    def set_rerouteType(self, rerouteType):
        self.rerouteType = rerouteType
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_RerouteInclusionIndicatorType(self, value):
        # Validate type nas:RerouteInclusionIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INCLUDED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RerouteInclusionIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_RerouteTypeType(self, value):
        # Validate type nas:RerouteTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['BLANK', 'CDR_RTE', 'REROUTE', 'UPT_RTE', 'UNKNOWN']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RerouteTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasRerouteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasRerouteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasRerouteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasRerouteType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasRerouteType'):
        if self.rerouteIdentifier is not None and 'rerouteIdentifier' not in already_processed:
            already_processed.add('rerouteIdentifier')
            outfile.write(' rerouteIdentifier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rerouteIdentifier), input_name='rerouteIdentifier')), ))
        if self.rerouteInclusionIndicator is not None and 'rerouteInclusionIndicator' not in already_processed:
            already_processed.add('rerouteInclusionIndicator')
            outfile.write(' rerouteInclusionIndicator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rerouteInclusionIndicator), input_name='rerouteInclusionIndicator')), ))
        if self.rerouteName is not None and 'rerouteName' not in already_processed:
            already_processed.add('rerouteName')
            outfile.write(' rerouteName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rerouteName), input_name='rerouteName')), ))
        if self.rerouteProtectedSegment is not None and 'rerouteProtectedSegment' not in already_processed:
            already_processed.add('rerouteProtectedSegment')
            outfile.write(' rerouteProtectedSegment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rerouteProtectedSegment), input_name='rerouteProtectedSegment')), ))
        if self.rerouteType is not None and 'rerouteType' not in already_processed:
            already_processed.add('rerouteType')
            outfile.write(' rerouteType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rerouteType), input_name='rerouteType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasRerouteType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rerouteIdentifier', node)
        if value is not None and 'rerouteIdentifier' not in already_processed:
            already_processed.add('rerouteIdentifier')
            self.rerouteIdentifier = value
            self.validate_FreeTextType(self.rerouteIdentifier)    # validate type FreeTextType
        value = find_attr_value_('rerouteInclusionIndicator', node)
        if value is not None and 'rerouteInclusionIndicator' not in already_processed:
            already_processed.add('rerouteInclusionIndicator')
            self.rerouteInclusionIndicator = value
            self.validate_RerouteInclusionIndicatorType(self.rerouteInclusionIndicator)    # validate type RerouteInclusionIndicatorType
        value = find_attr_value_('rerouteName', node)
        if value is not None and 'rerouteName' not in already_processed:
            already_processed.add('rerouteName')
            self.rerouteName = value
            self.validate_FreeTextType(self.rerouteName)    # validate type FreeTextType
        value = find_attr_value_('rerouteProtectedSegment', node)
        if value is not None and 'rerouteProtectedSegment' not in already_processed:
            already_processed.add('rerouteProtectedSegment')
            self.rerouteProtectedSegment = value
            self.validate_FreeTextType(self.rerouteProtectedSegment)    # validate type FreeTextType
        value = find_attr_value_('rerouteType', node)
        if value is not None and 'rerouteType' not in already_processed:
            already_processed.add('rerouteType')
            self.rerouteType = value
            self.validate_RerouteTypeType(self.rerouteType)    # validate type RerouteTypeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NasRerouteType


class NasTmiType(GeneratedsSuper):
    """Container for NAS Traffic Management Initiatives. CTOP Information is
    not included
    in this container but instead collected in the NasTmiTrajectoryOption
    Container and
    connected to the Flight Object."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, advisories=None, reroute=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if advisories is None:
            self.advisories = []
        else:
            self.advisories = advisories
        self.advisories_nsprefix_ = None
        if reroute is None:
            self.reroute = []
        else:
            self.reroute = reroute
        self.reroute_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasTmiType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasTmiType.subclass:
            return NasTmiType.subclass(*args_, **kwargs_)
        else:
            return NasTmiType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_advisories(self):
        return self.advisories
    def set_advisories(self, advisories):
        self.advisories = advisories
    def add_advisories(self, value):
        self.advisories.append(value)
    def insert_advisories_at(self, index, value):
        self.advisories.insert(index, value)
    def replace_advisories_at(self, index, value):
        self.advisories[index] = value
    def get_reroute(self):
        return self.reroute
    def set_reroute(self, reroute):
        self.reroute = reroute
    def add_reroute(self, value):
        self.reroute.append(value)
    def insert_reroute_at(self, index, value):
        self.reroute.insert(index, value)
    def replace_reroute_at(self, index, value):
        self.reroute[index] = value
    def hasContent_(self):
        if (
            self.advisories or
            self.reroute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasTmiType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasTmiType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasTmiType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasTmiType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasTmiType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasTmiType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for advisories_ in self.advisories:
            namespaceprefix_ = self.advisories_nsprefix_ + ':' if (UseCapturedNS_ and self.advisories_nsprefix_) else ''
            advisories_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='advisories', pretty_print=pretty_print)
        for reroute_ in self.reroute:
            namespaceprefix_ = self.reroute_nsprefix_ + ':' if (UseCapturedNS_ and self.reroute_nsprefix_) else ''
            reroute_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reroute', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'advisories':
            obj_ = NasAdvisoryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.advisories.append(obj_)
            obj_.original_tagname_ = 'advisories'
        elif nodeName_ == 'reroute':
            obj_ = NasRerouteType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reroute.append(obj_)
            obj_.original_tagname_ = 'reroute'
# end class NasTmiType


class NasHandoffType(HandoffType):
    """Contains information about flight handoff between sectors.
    .Handoff Event Category: Characterizes a handoff in terms of its status."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = HandoffType
    def __init__(self, coordinationStatus=None, receivingUnit=None, transferringUnit=None, event=None, acceptingUnit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasHandoffType, self).__init__(coordinationStatus, receivingUnit, transferringUnit,  **kwargs_)
        self.event = _cast(None, event)
        self.event_nsprefix_ = None
        self.acceptingUnit = acceptingUnit
        self.acceptingUnit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasHandoffType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasHandoffType.subclass:
            return NasHandoffType.subclass(*args_, **kwargs_)
        else:
            return NasHandoffType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_acceptingUnit(self):
        return self.acceptingUnit
    def set_acceptingUnit(self, acceptingUnit):
        self.acceptingUnit = acceptingUnit
    def set_acceptingUnit_with_type(self, value):
        self.acceptingUnit = value
        value.original_tagname_ = 'acceptingUnit'
        value.extensiontype_ = value.__class__.__name__
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def validate_NasHandoffEventType(self, value):
        # Validate type nas:NasHandoffEventType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INITIATION', 'ACCEPTANCE', 'RETRACTION', 'TAKE_CONTROL', 'UPDATE', 'FAILURE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NasHandoffEventType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.acceptingUnit is not None or
            super(NasHandoffType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='NasHandoffType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasHandoffType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasHandoffType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasHandoffType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasHandoffType'):
        super(NasHandoffType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasHandoffType')
        if self.event is not None and 'event' not in already_processed:
            already_processed.add('event')
            outfile.write(' event=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.event), input_name='event')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='NasHandoffType', fromsubclass_=False, pretty_print=True):
        super(NasHandoffType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.acceptingUnit is not None:
            self.acceptingUnit.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('event', node)
        if value is not None and 'event' not in already_processed:
            already_processed.add('event')
            self.event = value
            self.validate_NasHandoffEventType(self.event)    # validate type NasHandoffEventType
        super(NasHandoffType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'acceptingUnit':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <acceptingUnit> element')
            self.acceptingUnit = obj_
            obj_.original_tagname_ = 'acceptingUnit'
        super(NasHandoffType, self).buildChildren(child_, node, nodeName_, True)
# end class NasHandoffType


class NasUnitBoundaryType(UnitBoundaryType):
    """NAS Specific extension of BoundaryCrossing to include "actual"
    BoundaryCrossing attributes."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = UnitBoundaryType
    def __init__(self, delegated=None, sectorIdentifier=None, unitBoundaryIndicator=None, boundaryCrossingCoordinated=None, boundaryCrossingProposed=None, downstreamUnit=None, handoff=None, upstreamUnit=None, boundaryCrossingActual=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasUnitBoundaryType, self).__init__(delegated, sectorIdentifier, unitBoundaryIndicator, boundaryCrossingCoordinated, boundaryCrossingProposed, downstreamUnit, handoff, upstreamUnit,  **kwargs_)
        self.boundaryCrossingActual = boundaryCrossingActual
        self.boundaryCrossingActual_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasUnitBoundaryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasUnitBoundaryType.subclass:
            return NasUnitBoundaryType.subclass(*args_, **kwargs_)
        else:
            return NasUnitBoundaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_boundaryCrossingActual(self):
        return self.boundaryCrossingActual
    def set_boundaryCrossingActual(self, boundaryCrossingActual):
        self.boundaryCrossingActual = boundaryCrossingActual
    def hasContent_(self):
        if (
            self.boundaryCrossingActual is not None or
            super(NasUnitBoundaryType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='NasUnitBoundaryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasUnitBoundaryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasUnitBoundaryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasUnitBoundaryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasUnitBoundaryType'):
        super(NasUnitBoundaryType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasUnitBoundaryType')
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='NasUnitBoundaryType', fromsubclass_=False, pretty_print=True):
        super(NasUnitBoundaryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.boundaryCrossingActual is not None:
            namespaceprefix_ = self.boundaryCrossingActual_nsprefix_ + ':' if (UseCapturedNS_ and self.boundaryCrossingActual_nsprefix_) else ''
            self.boundaryCrossingActual.export(outfile, level, namespaceprefix_, namespacedef_='', name_='boundaryCrossingActual', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NasUnitBoundaryType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'boundaryCrossingActual':
            obj_ = BoundaryCrossingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.boundaryCrossingActual = obj_
            obj_.original_tagname_ = 'boundaryCrossingActual'
        super(NasUnitBoundaryType, self).buildChildren(child_, node, nodeName_, True)
# end class NasUnitBoundaryType


class NasDepartureType(FlightDepartureType):
    """Extends core Flight Departue with NAS specific Extensions.
    .Departure Center: Indicates the Air Route Traffic Control Center (ARTCC)
    for the
    departure point for a flight.
    .Departure Point: The first point or other initial entity where the air
    traffic control/management
    system route starts.
    .Off-Block Time - Scheduled: Scheduled gate time of departure for a flight,
    as provided
    by the OAG (Official Airline Guide).
    .Movement Area Entry Time - Target: The time at which a flight is assigned
    to enter
    the Airport Movement Area (AMA) when airport surface departure metering
    procedures
    are in effect."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FlightDepartureType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, departureFleetPrioritization=None, departureSlot=None, earliestOffBlockTime=None, standardInstrumentDeparture=None, departureAerodrome=None, departureFix=None, departureFixTime=None, departureTimes=None, offBlockReadyTime=None, runwayPositionAndTime=None, standPositionAndTime=None, takeoffAlternateAerodrome=None, takeoffWeight=None, departureCenter=None, departurePoint=None, scheduledOffBlockTime=None, targetMAEntryTime=None, runwayDepartureTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasDepartureType, self).__init__(centre, source, system, timestamp, departureFleetPrioritization, departureSlot, earliestOffBlockTime, standardInstrumentDeparture, departureAerodrome, departureFix, departureFixTime, departureTimes, offBlockReadyTime, runwayPositionAndTime, standPositionAndTime, takeoffAlternateAerodrome, takeoffWeight,  **kwargs_)
        self.departureCenter = _cast(None, departureCenter)
        self.departureCenter_nsprefix_ = None
        self.departurePoint = _cast(None, departurePoint)
        self.departurePoint_nsprefix_ = None
        self.scheduledOffBlockTime = _cast(None, scheduledOffBlockTime)
        self.scheduledOffBlockTime_nsprefix_ = None
        self.targetMAEntryTime = _cast(None, targetMAEntryTime)
        self.targetMAEntryTime_nsprefix_ = None
        self.runwayDepartureTime = runwayDepartureTime
        self.runwayDepartureTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasDepartureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasDepartureType.subclass:
            return NasDepartureType.subclass(*args_, **kwargs_)
        else:
            return NasDepartureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_runwayDepartureTime(self):
        return self.runwayDepartureTime
    def set_runwayDepartureTime(self, runwayDepartureTime):
        self.runwayDepartureTime = runwayDepartureTime
    def get_departureCenter(self):
        return self.departureCenter
    def set_departureCenter(self, departureCenter):
        self.departureCenter = departureCenter
    def get_departurePoint(self):
        return self.departurePoint
    def set_departurePoint(self, departurePoint):
        self.departurePoint = departurePoint
    def get_scheduledOffBlockTime(self):
        return self.scheduledOffBlockTime
    def set_scheduledOffBlockTime(self, scheduledOffBlockTime):
        self.scheduledOffBlockTime = scheduledOffBlockTime
    def get_targetMAEntryTime(self):
        return self.targetMAEntryTime
    def set_targetMAEntryTime(self, targetMAEntryTime):
        self.targetMAEntryTime = targetMAEntryTime
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.runwayDepartureTime is not None or
            super(NasDepartureType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasDepartureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasDepartureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasDepartureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasDepartureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasDepartureType'):
        super(NasDepartureType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasDepartureType')
        if self.departureCenter is not None and 'departureCenter' not in already_processed:
            already_processed.add('departureCenter')
            outfile.write(' departureCenter=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.departureCenter), input_name='departureCenter')), ))
        if self.departurePoint is not None and 'departurePoint' not in already_processed:
            already_processed.add('departurePoint')
            outfile.write(' departurePoint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.departurePoint), input_name='departurePoint')), ))
        if self.scheduledOffBlockTime is not None and 'scheduledOffBlockTime' not in already_processed:
            already_processed.add('scheduledOffBlockTime')
            outfile.write(' scheduledOffBlockTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scheduledOffBlockTime), input_name='scheduledOffBlockTime')), ))
        if self.targetMAEntryTime is not None and 'targetMAEntryTime' not in already_processed:
            already_processed.add('targetMAEntryTime')
            outfile.write(' targetMAEntryTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetMAEntryTime), input_name='targetMAEntryTime')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasDepartureType', fromsubclass_=False, pretty_print=True):
        super(NasDepartureType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.runwayDepartureTime is not None:
            namespaceprefix_ = self.runwayDepartureTime_nsprefix_ + ':' if (UseCapturedNS_ and self.runwayDepartureTime_nsprefix_) else ''
            self.runwayDepartureTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='runwayDepartureTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('departureCenter', node)
        if value is not None and 'departureCenter' not in already_processed:
            already_processed.add('departureCenter')
            self.departureCenter = value
            self.validate_FreeTextType(self.departureCenter)    # validate type FreeTextType
        value = find_attr_value_('departurePoint', node)
        if value is not None and 'departurePoint' not in already_processed:
            already_processed.add('departurePoint')
            self.departurePoint = value
            self.validate_FreeTextType(self.departurePoint)    # validate type FreeTextType
        value = find_attr_value_('scheduledOffBlockTime', node)
        if value is not None and 'scheduledOffBlockTime' not in already_processed:
            already_processed.add('scheduledOffBlockTime')
            try:
                self.scheduledOffBlockTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (scheduledOffBlockTime): %s' % exp)
            self.validate_TimeType(self.scheduledOffBlockTime)    # validate type TimeType
        value = find_attr_value_('targetMAEntryTime', node)
        if value is not None and 'targetMAEntryTime' not in already_processed:
            already_processed.add('targetMAEntryTime')
            try:
                self.targetMAEntryTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (targetMAEntryTime): %s' % exp)
            self.validate_TimeType(self.targetMAEntryTime)    # validate type TimeType
        super(NasDepartureType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'runwayDepartureTime':
            obj_ = RunwayDepartureTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.runwayDepartureTime = obj_
            obj_.original_tagname_ = 'runwayDepartureTime'
        super(NasDepartureType, self).buildChildren(child_, node, nodeName_, True)
# end class NasDepartureType


class RunwayDepartureTimeType(GeneratedsSuper):
    """Container for NAS Specific Runway Departure Times."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, airlineEstimated=None, earliest=None, original=None, preferred=None, tfmEstimated=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.airlineEstimated = airlineEstimated
        self.airlineEstimated_nsprefix_ = None
        self.earliest = earliest
        self.earliest_nsprefix_ = None
        self.original = original
        self.original_nsprefix_ = None
        self.preferred = preferred
        self.preferred_nsprefix_ = None
        self.tfmEstimated = tfmEstimated
        self.tfmEstimated_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RunwayDepartureTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RunwayDepartureTimeType.subclass:
            return RunwayDepartureTimeType.subclass(*args_, **kwargs_)
        else:
            return RunwayDepartureTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_airlineEstimated(self):
        return self.airlineEstimated
    def set_airlineEstimated(self, airlineEstimated):
        self.airlineEstimated = airlineEstimated
    def get_earliest(self):
        return self.earliest
    def set_earliest(self, earliest):
        self.earliest = earliest
    def get_original(self):
        return self.original
    def set_original(self, original):
        self.original = original
    def get_preferred(self):
        return self.preferred
    def set_preferred(self, preferred):
        self.preferred = preferred
    def get_tfmEstimated(self):
        return self.tfmEstimated
    def set_tfmEstimated(self, tfmEstimated):
        self.tfmEstimated = tfmEstimated
    def hasContent_(self):
        if (
            self.airlineEstimated is not None or
            self.earliest is not None or
            self.original is not None or
            self.preferred is not None or
            self.tfmEstimated is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='RunwayDepartureTimeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RunwayDepartureTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RunwayDepartureTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RunwayDepartureTimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='RunwayDepartureTimeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='RunwayDepartureTimeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.airlineEstimated is not None:
            namespaceprefix_ = self.airlineEstimated_nsprefix_ + ':' if (UseCapturedNS_ and self.airlineEstimated_nsprefix_) else ''
            self.airlineEstimated.export(outfile, level, namespaceprefix_, namespacedef_='', name_='airlineEstimated', pretty_print=pretty_print)
        if self.earliest is not None:
            namespaceprefix_ = self.earliest_nsprefix_ + ':' if (UseCapturedNS_ and self.earliest_nsprefix_) else ''
            self.earliest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='earliest', pretty_print=pretty_print)
        if self.original is not None:
            namespaceprefix_ = self.original_nsprefix_ + ':' if (UseCapturedNS_ and self.original_nsprefix_) else ''
            self.original.export(outfile, level, namespaceprefix_, namespacedef_='', name_='original', pretty_print=pretty_print)
        if self.preferred is not None:
            namespaceprefix_ = self.preferred_nsprefix_ + ':' if (UseCapturedNS_ and self.preferred_nsprefix_) else ''
            self.preferred.export(outfile, level, namespaceprefix_, namespacedef_='', name_='preferred', pretty_print=pretty_print)
        if self.tfmEstimated is not None:
            namespaceprefix_ = self.tfmEstimated_nsprefix_ + ':' if (UseCapturedNS_ and self.tfmEstimated_nsprefix_) else ''
            self.tfmEstimated.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tfmEstimated', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'airlineEstimated':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.airlineEstimated = obj_
            obj_.original_tagname_ = 'airlineEstimated'
        elif nodeName_ == 'earliest':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.earliest = obj_
            obj_.original_tagname_ = 'earliest'
        elif nodeName_ == 'original':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.original = obj_
            obj_.original_tagname_ = 'original'
        elif nodeName_ == 'preferred':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.preferred = obj_
            obj_.original_tagname_ = 'preferred'
        elif nodeName_ == 'tfmEstimated':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tfmEstimated = obj_
            obj_.original_tagname_ = 'tfmEstimated'
# end class RunwayDepartureTimeType


class AirspaceAcceptableSlotSubstitutionType(GeneratedsSuper):
    """.Runway Arrival Time - Slot Credit Substitution Earliest Acceptable: The
    earliest
    time at which the Airspace user will accept a slot in a Traffic Management
    Initiative
    (TMI) Ground Delay Program (GDP) in return for a yielded slot.
    .Runway Arrival Time - Slot Credit Substitution Latest Acceptable: The
    latest time
    at which the Airspace user will accept a slot in a Traffic Management
    Initiative
    (TMI) Ground Delay Program (GDP), in return for a yielded slot."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, earliest=None, latest=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.earliest = earliest
        self.earliest_nsprefix_ = None
        self.latest = latest
        self.latest_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AirspaceAcceptableSlotSubstitutionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AirspaceAcceptableSlotSubstitutionType.subclass:
            return AirspaceAcceptableSlotSubstitutionType.subclass(*args_, **kwargs_)
        else:
            return AirspaceAcceptableSlotSubstitutionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_earliest(self):
        return self.earliest
    def set_earliest(self, earliest):
        self.earliest = earliest
    def get_latest(self):
        return self.latest
    def set_latest(self, latest):
        self.latest = latest
    def hasContent_(self):
        if (
            self.earliest is not None or
            self.latest is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='AirspaceAcceptableSlotSubstitutionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AirspaceAcceptableSlotSubstitutionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AirspaceAcceptableSlotSubstitutionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AirspaceAcceptableSlotSubstitutionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='AirspaceAcceptableSlotSubstitutionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='AirspaceAcceptableSlotSubstitutionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.earliest is not None:
            namespaceprefix_ = self.earliest_nsprefix_ + ':' if (UseCapturedNS_ and self.earliest_nsprefix_) else ''
            self.earliest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='earliest', pretty_print=pretty_print)
        if self.latest is not None:
            namespaceprefix_ = self.latest_nsprefix_ + ':' if (UseCapturedNS_ and self.latest_nsprefix_) else ''
            self.latest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='latest', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'earliest':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.earliest = obj_
            obj_.original_tagname_ = 'earliest'
        elif nodeName_ == 'latest':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.latest = obj_
            obj_.original_tagname_ = 'latest'
# end class AirspaceAcceptableSlotSubstitutionType


class AirspaceEntryTimeType(GeneratedsSuper):
    """Container for :
    Airspace Entry Time - Earliest
    Airspace Entry Time - Initial
    Airspace Entry Time - Original
    Airspace Entry Time - Traffic Flow Management System Estimated"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, earliest=None, initial=None, original=None, slotSubstitution=None, tfmsEstimated=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.earliest = earliest
        self.earliest_nsprefix_ = None
        self.initial = initial
        self.initial_nsprefix_ = None
        self.original = original
        self.original_nsprefix_ = None
        self.slotSubstitution = slotSubstitution
        self.slotSubstitution_nsprefix_ = None
        self.tfmsEstimated = tfmsEstimated
        self.tfmsEstimated_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AirspaceEntryTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AirspaceEntryTimeType.subclass:
            return AirspaceEntryTimeType.subclass(*args_, **kwargs_)
        else:
            return AirspaceEntryTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_earliest(self):
        return self.earliest
    def set_earliest(self, earliest):
        self.earliest = earliest
    def get_initial(self):
        return self.initial
    def set_initial(self, initial):
        self.initial = initial
    def get_original(self):
        return self.original
    def set_original(self, original):
        self.original = original
    def get_slotSubstitution(self):
        return self.slotSubstitution
    def set_slotSubstitution(self, slotSubstitution):
        self.slotSubstitution = slotSubstitution
    def get_tfmsEstimated(self):
        return self.tfmsEstimated
    def set_tfmsEstimated(self, tfmsEstimated):
        self.tfmsEstimated = tfmsEstimated
    def hasContent_(self):
        if (
            self.earliest is not None or
            self.initial is not None or
            self.original is not None or
            self.slotSubstitution is not None or
            self.tfmsEstimated is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='AirspaceEntryTimeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AirspaceEntryTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AirspaceEntryTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AirspaceEntryTimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='AirspaceEntryTimeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='AirspaceEntryTimeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.earliest is not None:
            namespaceprefix_ = self.earliest_nsprefix_ + ':' if (UseCapturedNS_ and self.earliest_nsprefix_) else ''
            self.earliest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='earliest', pretty_print=pretty_print)
        if self.initial is not None:
            namespaceprefix_ = self.initial_nsprefix_ + ':' if (UseCapturedNS_ and self.initial_nsprefix_) else ''
            self.initial.export(outfile, level, namespaceprefix_, namespacedef_='', name_='initial', pretty_print=pretty_print)
        if self.original is not None:
            namespaceprefix_ = self.original_nsprefix_ + ':' if (UseCapturedNS_ and self.original_nsprefix_) else ''
            self.original.export(outfile, level, namespaceprefix_, namespacedef_='', name_='original', pretty_print=pretty_print)
        if self.slotSubstitution is not None:
            namespaceprefix_ = self.slotSubstitution_nsprefix_ + ':' if (UseCapturedNS_ and self.slotSubstitution_nsprefix_) else ''
            self.slotSubstitution.export(outfile, level, namespaceprefix_, namespacedef_='', name_='slotSubstitution', pretty_print=pretty_print)
        if self.tfmsEstimated is not None:
            namespaceprefix_ = self.tfmsEstimated_nsprefix_ + ':' if (UseCapturedNS_ and self.tfmsEstimated_nsprefix_) else ''
            self.tfmsEstimated.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tfmsEstimated', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'earliest':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.earliest = obj_
            obj_.original_tagname_ = 'earliest'
        elif nodeName_ == 'initial':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.initial = obj_
            obj_.original_tagname_ = 'initial'
        elif nodeName_ == 'original':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.original = obj_
            obj_.original_tagname_ = 'original'
        elif nodeName_ == 'slotSubstitution':
            obj_ = AirspaceAcceptableSlotSubstitutionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.slotSubstitution = obj_
            obj_.original_tagname_ = 'slotSubstitution'
        elif nodeName_ == 'tfmsEstimated':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tfmsEstimated = obj_
            obj_.original_tagname_ = 'tfmsEstimated'
# end class AirspaceEntryTimeType


class AirspaceExitTimeType(GeneratedsSuper):
    """Container for
    Airspace Exit Time - Traffic Flow Management System Estimated"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tfmsEstimated=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tfmsEstimated = tfmsEstimated
        self.tfmsEstimated_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AirspaceExitTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AirspaceExitTimeType.subclass:
            return AirspaceExitTimeType.subclass(*args_, **kwargs_)
        else:
            return AirspaceExitTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tfmsEstimated(self):
        return self.tfmsEstimated
    def set_tfmsEstimated(self, tfmsEstimated):
        self.tfmsEstimated = tfmsEstimated
    def hasContent_(self):
        if (
            self.tfmsEstimated is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='AirspaceExitTimeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AirspaceExitTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AirspaceExitTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AirspaceExitTimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='AirspaceExitTimeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='AirspaceExitTimeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tfmsEstimated is not None:
            namespaceprefix_ = self.tfmsEstimated_nsprefix_ + ':' if (UseCapturedNS_ and self.tfmsEstimated_nsprefix_) else ''
            self.tfmsEstimated.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tfmsEstimated', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tfmsEstimated':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tfmsEstimated = obj_
            obj_.original_tagname_ = 'tfmsEstimated'
# end class AirspaceExitTimeType


class NasAirspaceConstraintType(AirspaceConstraintType):
    """Container for Airspace Slot Handling.
    .Arrival Slot - NAS: A time slot at an airport or airspace entry point that
    identifies
    a point in time when an aircraft is constrained to arrive at the airport or
    airspace
    entry point.
    .Slot Hold Status: If a flight is controlled and cancelled [e.g., has a
    Controlled
    Time of Departure (CTD), Controlled Time of Arrival (CTA), and Arrival Slot
    (ASLOT)],
    the slot hold status indicates whether the slot associated with this flight
    is being
    held, or would be held, by the Airspace User for the next full compression.
    .Yielded Slot Indicator: Indicates the slot currently specified in Runway
    Arrival
    Time - Controlled is to be given up by the Airspace User in return for a
    later
    slot."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AirspaceConstraintType
    def __init__(self, constrainedAirspace=None, airspaceControlledEntryTime=None, arrivalSlot=None, holdStatus=None, yieldedSlot=None, entryTime=None, exitTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasAirspaceConstraintType, self).__init__(constrainedAirspace, airspaceControlledEntryTime,  **kwargs_)
        self.arrivalSlot = _cast(None, arrivalSlot)
        self.arrivalSlot_nsprefix_ = None
        self.holdStatus = _cast(None, holdStatus)
        self.holdStatus_nsprefix_ = None
        self.yieldedSlot = _cast(None, yieldedSlot)
        self.yieldedSlot_nsprefix_ = None
        self.entryTime = entryTime
        self.entryTime_nsprefix_ = None
        self.exitTime = exitTime
        self.exitTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasAirspaceConstraintType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasAirspaceConstraintType.subclass:
            return NasAirspaceConstraintType.subclass(*args_, **kwargs_)
        else:
            return NasAirspaceConstraintType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_entryTime(self):
        return self.entryTime
    def set_entryTime(self, entryTime):
        self.entryTime = entryTime
    def get_exitTime(self):
        return self.exitTime
    def set_exitTime(self, exitTime):
        self.exitTime = exitTime
    def get_arrivalSlot(self):
        return self.arrivalSlot
    def set_arrivalSlot(self, arrivalSlot):
        self.arrivalSlot = arrivalSlot
    def get_holdStatus(self):
        return self.holdStatus
    def set_holdStatus(self, holdStatus):
        self.holdStatus = holdStatus
    def get_yieldedSlot(self):
        return self.yieldedSlot
    def set_yieldedSlot(self, yieldedSlot):
        self.yieldedSlot = yieldedSlot
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_SlotHoldStatusType(self, value):
        # Validate type nas:SlotHoldStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['HOLD', 'RELEASE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SlotHoldStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_SlotYieldedIndicatorType(self, value):
        # Validate type nas:SlotYieldedIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SLOT_YIELDED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SlotYieldedIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.entryTime is not None or
            self.exitTime is not None or
            super(NasAirspaceConstraintType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasAirspaceConstraintType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasAirspaceConstraintType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasAirspaceConstraintType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasAirspaceConstraintType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasAirspaceConstraintType'):
        super(NasAirspaceConstraintType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasAirspaceConstraintType')
        if self.arrivalSlot is not None and 'arrivalSlot' not in already_processed:
            already_processed.add('arrivalSlot')
            outfile.write(' arrivalSlot=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.arrivalSlot), input_name='arrivalSlot')), ))
        if self.holdStatus is not None and 'holdStatus' not in already_processed:
            already_processed.add('holdStatus')
            outfile.write(' holdStatus=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.holdStatus), input_name='holdStatus')), ))
        if self.yieldedSlot is not None and 'yieldedSlot' not in already_processed:
            already_processed.add('yieldedSlot')
            outfile.write(' yieldedSlot=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.yieldedSlot), input_name='yieldedSlot')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasAirspaceConstraintType', fromsubclass_=False, pretty_print=True):
        super(NasAirspaceConstraintType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.entryTime is not None:
            namespaceprefix_ = self.entryTime_nsprefix_ + ':' if (UseCapturedNS_ and self.entryTime_nsprefix_) else ''
            self.entryTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryTime', pretty_print=pretty_print)
        if self.exitTime is not None:
            namespaceprefix_ = self.exitTime_nsprefix_ + ':' if (UseCapturedNS_ and self.exitTime_nsprefix_) else ''
            self.exitTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='exitTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('arrivalSlot', node)
        if value is not None and 'arrivalSlot' not in already_processed:
            already_processed.add('arrivalSlot')
            self.arrivalSlot = value
            self.validate_FreeTextType(self.arrivalSlot)    # validate type FreeTextType
        value = find_attr_value_('holdStatus', node)
        if value is not None and 'holdStatus' not in already_processed:
            already_processed.add('holdStatus')
            self.holdStatus = value
            self.validate_SlotHoldStatusType(self.holdStatus)    # validate type SlotHoldStatusType
        value = find_attr_value_('yieldedSlot', node)
        if value is not None and 'yieldedSlot' not in already_processed:
            already_processed.add('yieldedSlot')
            self.yieldedSlot = value
            self.validate_SlotYieldedIndicatorType(self.yieldedSlot)    # validate type SlotYieldedIndicatorType
        super(NasAirspaceConstraintType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'entryTime':
            obj_ = AirspaceEntryTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryTime = obj_
            obj_.original_tagname_ = 'entryTime'
        elif nodeName_ == 'exitTime':
            obj_ = AirspaceExitTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.exitTime = obj_
            obj_.original_tagname_ = 'exitTime'
        super(NasAirspaceConstraintType, self).buildChildren(child_, node, nodeName_, True)
# end class NasAirspaceConstraintType


class NasClearedFlightInformationType(ClearedFlightInformationType):
    """Extends the core ClearedFlightInformation to hold additional clearance
    information.
    .En Route Clearance Heading: Contains the En Route Controller Clearance
    heading,
    as entered by the controller in the fourth line of the Full Data Block.
    .En Route Clearance Speed: This data element contains the En Route
    Controller Clearance
    speed, as entered by the controller in the fourth line of the Full Data
    Block.
    .En Route Clearance Text: This data element contains free-form text entered
    by the
    En Route Controller, to be associated with the Clearance in the fourth line
    of the
    Full Data Block."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ClearedFlightInformationType
    def __init__(self, clearedFlightLevel=None, clearedSpeed=None, directRouting=None, heading=None, offtrackClearance=None, rateOfClimbDescend=None, clearanceHeading=None, clearanceSpeed=None, clearanceText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasClearedFlightInformationType, self).__init__(clearedFlightLevel, clearedSpeed, directRouting, heading, offtrackClearance, rateOfClimbDescend,  **kwargs_)
        self.clearanceHeading = _cast(None, clearanceHeading)
        self.clearanceHeading_nsprefix_ = None
        self.clearanceSpeed = _cast(None, clearanceSpeed)
        self.clearanceSpeed_nsprefix_ = None
        self.clearanceText = _cast(None, clearanceText)
        self.clearanceText_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasClearedFlightInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasClearedFlightInformationType.subclass:
            return NasClearedFlightInformationType.subclass(*args_, **kwargs_)
        else:
            return NasClearedFlightInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_clearanceHeading(self):
        return self.clearanceHeading
    def set_clearanceHeading(self, clearanceHeading):
        self.clearanceHeading = clearanceHeading
    def get_clearanceSpeed(self):
        return self.clearanceSpeed
    def set_clearanceSpeed(self, clearanceSpeed):
        self.clearanceSpeed = clearanceSpeed
    def get_clearanceText(self):
        return self.clearanceText
    def set_clearanceText(self, clearanceText):
        self.clearanceText = clearanceText
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(NasClearedFlightInformationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasClearedFlightInformationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasClearedFlightInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasClearedFlightInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasClearedFlightInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasClearedFlightInformationType'):
        super(NasClearedFlightInformationType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasClearedFlightInformationType')
        if self.clearanceHeading is not None and 'clearanceHeading' not in already_processed:
            already_processed.add('clearanceHeading')
            outfile.write(' clearanceHeading=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clearanceHeading), input_name='clearanceHeading')), ))
        if self.clearanceSpeed is not None and 'clearanceSpeed' not in already_processed:
            already_processed.add('clearanceSpeed')
            outfile.write(' clearanceSpeed=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clearanceSpeed), input_name='clearanceSpeed')), ))
        if self.clearanceText is not None and 'clearanceText' not in already_processed:
            already_processed.add('clearanceText')
            outfile.write(' clearanceText=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clearanceText), input_name='clearanceText')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasClearedFlightInformationType', fromsubclass_=False, pretty_print=True):
        super(NasClearedFlightInformationType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clearanceHeading', node)
        if value is not None and 'clearanceHeading' not in already_processed:
            already_processed.add('clearanceHeading')
            self.clearanceHeading = value
            self.validate_FreeTextType(self.clearanceHeading)    # validate type FreeTextType
        value = find_attr_value_('clearanceSpeed', node)
        if value is not None and 'clearanceSpeed' not in already_processed:
            already_processed.add('clearanceSpeed')
            self.clearanceSpeed = value
            self.validate_FreeTextType(self.clearanceSpeed)    # validate type FreeTextType
        value = find_attr_value_('clearanceText', node)
        if value is not None and 'clearanceText' not in already_processed:
            already_processed.add('clearanceText')
            self.clearanceText = value
            self.validate_FreeTextType(self.clearanceText)    # validate type FreeTextType
        super(NasClearedFlightInformationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(NasClearedFlightInformationType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NasClearedFlightInformationType


class NasEnRouteType(EnRouteType):
    """Extension of core EnRoute to include additional NAS hold information."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EnRouteType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, fleetPrioritization=None, alternateAerodrome=None, beaconCodeAssignment=None, boundaryCrossings=None, cleared=None, controlElement=None, cpdlcConnection=None, pointout=None, position=None, expectedFurtherClearanceTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasEnRouteType, self).__init__(centre, source, system, timestamp, fleetPrioritization, alternateAerodrome, beaconCodeAssignment, boundaryCrossings, cleared, controlElement, cpdlcConnection, pointout, position,  **kwargs_)
        self.expectedFurtherClearanceTime = expectedFurtherClearanceTime
        self.expectedFurtherClearanceTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasEnRouteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasEnRouteType.subclass:
            return NasEnRouteType.subclass(*args_, **kwargs_)
        else:
            return NasEnRouteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_expectedFurtherClearanceTime(self):
        return self.expectedFurtherClearanceTime
    def set_expectedFurtherClearanceTime(self, expectedFurtherClearanceTime):
        self.expectedFurtherClearanceTime = expectedFurtherClearanceTime
    def hasContent_(self):
        if (
            self.expectedFurtherClearanceTime is not None or
            super(NasEnRouteType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='NasEnRouteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasEnRouteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasEnRouteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasEnRouteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasEnRouteType'):
        super(NasEnRouteType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasEnRouteType')
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='NasEnRouteType', fromsubclass_=False, pretty_print=True):
        super(NasEnRouteType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.expectedFurtherClearanceTime is not None:
            namespaceprefix_ = self.expectedFurtherClearanceTime_nsprefix_ + ':' if (UseCapturedNS_ and self.expectedFurtherClearanceTime_nsprefix_) else ''
            self.expectedFurtherClearanceTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='expectedFurtherClearanceTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NasEnRouteType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'expectedFurtherClearanceTime':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expectedFurtherClearanceTime = obj_
            obj_.original_tagname_ = 'expectedFurtherClearanceTime'
        super(NasEnRouteType, self).buildChildren(child_, node, nodeName_, True)
# end class NasEnRouteType


class NasAirspeedChoiceType(GeneratedsSuper):
    """A NAS extension to add an additional optional value to element Airspeed,
    In the NAS this element is: Aircraft Speed/Speed Classified.
    The value is "SC". Used when the speed is a classifed value."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, classified=None, nasAirspeed=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.classified = classified
        self.validate_ClassifiedSpeedIndicatorType(self.classified)
        self.classified_nsprefix_ = None
        self.nasAirspeed = nasAirspeed
        self.nasAirspeed_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasAirspeedChoiceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasAirspeedChoiceType.subclass:
            return NasAirspeedChoiceType.subclass(*args_, **kwargs_)
        else:
            return NasAirspeedChoiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_classified(self):
        return self.classified
    def set_classified(self, classified):
        self.classified = classified
    def get_nasAirspeed(self):
        return self.nasAirspeed
    def set_nasAirspeed(self, nasAirspeed):
        self.nasAirspeed = nasAirspeed
    def validate_ClassifiedSpeedIndicatorType(self, value):
        result = True
        # Validate type ClassifiedSpeedIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CLASSIFIED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ClassifiedSpeedIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.classified is not None or
            self.nasAirspeed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='NasAirspeedChoiceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasAirspeedChoiceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasAirspeedChoiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasAirspeedChoiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasAirspeedChoiceType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='NasAirspeedChoiceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.classified is not None:
            namespaceprefix_ = self.classified_nsprefix_ + ':' if (UseCapturedNS_ and self.classified_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclassified>%s</%sclassified>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.classified), input_name='classified')), namespaceprefix_ , eol_))
        if self.nasAirspeed is not None:
            namespaceprefix_ = self.nasAirspeed_nsprefix_ + ':' if (UseCapturedNS_ and self.nasAirspeed_nsprefix_) else ''
            self.nasAirspeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nasAirspeed', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'classified':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'classified')
            value_ = self.gds_validate_string(value_, node, 'classified')
            self.classified = value_
            self.classified_nsprefix_ = child_.prefix
            # validate type ClassifiedSpeedIndicatorType
            self.validate_ClassifiedSpeedIndicatorType(self.classified)
        elif nodeName_ == 'nasAirspeed':
            obj_ = TrueAirspeedOrMachType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nasAirspeed = obj_
            obj_.original_tagname_ = 'nasAirspeed'
# end class NasAirspeedChoiceType


class NasCoordinationType(GeneratedsSuper):
    """NAS extension to boundary crossing information: includes special
    handling for ccoordination
    time type.
    Coordination Time and Coordination Fix are handled by crossingPoint and
    crossingTime.
    .Coordination Time: The time to be used in conjunction with the
    Coordination Fix
    so processing for this flight (and its trajectory) can be synchronized for
    the next
    sector/facility. It coordinates the flight plan with the aircraft position.
    Container for Coordination Time Type.
    .Coordination Time Type: The indicator for the type of Coordination Time .
    .Delay Time to Absorb: Indicates the amount of time that needs to be
    absorbed during
    the flight. It is corrective action for meeting the goal of Estimated
    Departure Clearance
    Time (EDCT), when flight is already active and needs to arrive at the
    destination
    later than originally planned."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, coordinationTime=None, coordinationTimeHandling=None, delayTimeToAbsorb=None, coordinationFix=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.coordinationTime = _cast(None, coordinationTime)
        self.coordinationTime_nsprefix_ = None
        self.coordinationTimeHandling = _cast(None, coordinationTimeHandling)
        self.coordinationTimeHandling_nsprefix_ = None
        self.delayTimeToAbsorb = _cast(None, delayTimeToAbsorb)
        self.delayTimeToAbsorb_nsprefix_ = None
        self.coordinationFix = coordinationFix
        self.coordinationFix_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasCoordinationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasCoordinationType.subclass:
            return NasCoordinationType.subclass(*args_, **kwargs_)
        else:
            return NasCoordinationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_coordinationFix(self):
        return self.coordinationFix
    def set_coordinationFix(self, coordinationFix):
        self.coordinationFix = coordinationFix
    def set_coordinationFix_with_type(self, value):
        self.coordinationFix = value
        value.original_tagname_ = 'coordinationFix'
        value.extensiontype_ = value.__class__.__name__
    def get_coordinationTime(self):
        return self.coordinationTime
    def set_coordinationTime(self, coordinationTime):
        self.coordinationTime = coordinationTime
    def get_coordinationTimeHandling(self):
        return self.coordinationTimeHandling
    def set_coordinationTimeHandling(self, coordinationTimeHandling):
        self.coordinationTimeHandling = coordinationTimeHandling
    def get_delayTimeToAbsorb(self):
        return self.delayTimeToAbsorb
    def set_delayTimeToAbsorb(self, delayTimeToAbsorb):
        self.delayTimeToAbsorb = delayTimeToAbsorb
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_CoordinationTimeTypeType(self, value):
        # Validate type nas:CoordinationTimeTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['P', 'D', 'E']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CoordinationTimeTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DurationType(self, value):
        # Validate type ff:DurationType, a restriction on xs:duration.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.coordinationFix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='NasCoordinationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasCoordinationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasCoordinationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasCoordinationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasCoordinationType'):
        if self.coordinationTime is not None and 'coordinationTime' not in already_processed:
            already_processed.add('coordinationTime')
            outfile.write(' coordinationTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.coordinationTime), input_name='coordinationTime')), ))
        if self.coordinationTimeHandling is not None and 'coordinationTimeHandling' not in already_processed:
            already_processed.add('coordinationTimeHandling')
            outfile.write(' coordinationTimeHandling=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.coordinationTimeHandling), input_name='coordinationTimeHandling')), ))
        if self.delayTimeToAbsorb is not None and 'delayTimeToAbsorb' not in already_processed:
            already_processed.add('delayTimeToAbsorb')
            outfile.write(' delayTimeToAbsorb=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delayTimeToAbsorb), input_name='delayTimeToAbsorb')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='NasCoordinationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.coordinationFix is not None:
            self.coordinationFix.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coordinationTime', node)
        if value is not None and 'coordinationTime' not in already_processed:
            already_processed.add('coordinationTime')
            try:
                self.coordinationTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (coordinationTime): %s' % exp)
            self.validate_TimeType(self.coordinationTime)    # validate type TimeType
        value = find_attr_value_('coordinationTimeHandling', node)
        if value is not None and 'coordinationTimeHandling' not in already_processed:
            already_processed.add('coordinationTimeHandling')
            self.coordinationTimeHandling = value
            self.validate_CoordinationTimeTypeType(self.coordinationTimeHandling)    # validate type CoordinationTimeTypeType
        value = find_attr_value_('delayTimeToAbsorb', node)
        if value is not None and 'delayTimeToAbsorb' not in already_processed:
            already_processed.add('delayTimeToAbsorb')
            self.delayTimeToAbsorb = value
            self.validate_DurationType(self.delayTimeToAbsorb)    # validate type DurationType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'coordinationFix':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <coordinationFix> element')
            self.coordinationFix = obj_
            obj_.original_tagname_ = 'coordinationFix'
# end class NasCoordinationType


class NasFlightType(FlightType):
    """Extends core Flight object with NAS extra data
    .Current RVSM Flight Compliance: Indicates if the flight is currently
    Reduced Vertical
    Separation Minimum (RVSM) compliant in RVSM airspace, as determined by the
    Traffic
    Flow Management System.
    .Future RVSM Flight Compliance: Indicates if the flight will beReduced
    Vertical Separation
    Minimum (RVSM) compliant when it reaches the RVSM airspace as determined by
    the Traffic
    Flow Management System (TFMS).
    .Flight Class: Denotes the flight class of the aircraft which is determined
    by the
    aircraft call sign that is in the Aircraft Situation Display to Industry
    (ASDI) feed."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FlightType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, flightFiler=None, flightType=None, remarks=None, agreed=None, aircraftDescription=None, arrival=None, controllingUnit=None, dangerousGoods=None, departure=None, emergency=None, enRoute=None, enRouteDiversion=None, extensions=None, flightIdentification=None, flightStatus=None, gufi=None, negotiating=None, operator=None, originator=None, radioCommunicationFailure=None, rankedTrajectories=None, routeToRevisedDestination=None, specialHandling=None, supplementalData=None, currentRVSMCompliance=None, futureRVSMCompliance=None, tfmsFlightClass=None, assignedAltitude=None, coordination=None, flightIdentificationPrevious=None, flightIntent=None, flightPlan=None, interimAltitude=None, nasTmi=None, requestedAirspeed=None, requestedAltitude=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasFlightType, self).__init__(centre, source, system, timestamp, flightFiler, flightType, remarks, agreed, aircraftDescription, arrival, controllingUnit, dangerousGoods, departure, emergency, enRoute, enRouteDiversion, extensions, flightIdentification, flightStatus, gufi, negotiating, operator, originator, radioCommunicationFailure, rankedTrajectories, routeToRevisedDestination, specialHandling, supplementalData,  **kwargs_)
        self.currentRVSMCompliance = _cast(None, currentRVSMCompliance)
        self.currentRVSMCompliance_nsprefix_ = None
        self.futureRVSMCompliance = _cast(None, futureRVSMCompliance)
        self.futureRVSMCompliance_nsprefix_ = None
        self.tfmsFlightClass = _cast(None, tfmsFlightClass)
        self.tfmsFlightClass_nsprefix_ = None
        self.assignedAltitude = assignedAltitude
        self.assignedAltitude_nsprefix_ = None
        self.coordination = coordination
        self.coordination_nsprefix_ = None
        self.flightIdentificationPrevious = flightIdentificationPrevious
        self.flightIdentificationPrevious_nsprefix_ = None
        self.flightIntent = flightIntent
        self.flightIntent_nsprefix_ = None
        self.flightPlan = flightPlan
        self.flightPlan_nsprefix_ = None
        self.interimAltitude = interimAltitude
        self.interimAltitude_nsprefix_ = None
        self.nasTmi = nasTmi
        self.nasTmi_nsprefix_ = None
        self.requestedAirspeed = requestedAirspeed
        self.requestedAirspeed_nsprefix_ = None
        self.requestedAltitude = requestedAltitude
        self.requestedAltitude_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasFlightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasFlightType.subclass:
            return NasFlightType.subclass(*args_, **kwargs_)
        else:
            return NasFlightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_assignedAltitude(self):
        return self.assignedAltitude
    def set_assignedAltitude(self, assignedAltitude):
        self.assignedAltitude = assignedAltitude
    def get_coordination(self):
        return self.coordination
    def set_coordination(self, coordination):
        self.coordination = coordination
    def get_flightIdentificationPrevious(self):
        return self.flightIdentificationPrevious
    def set_flightIdentificationPrevious(self, flightIdentificationPrevious):
        self.flightIdentificationPrevious = flightIdentificationPrevious
    def get_flightIntent(self):
        return self.flightIntent
    def set_flightIntent(self, flightIntent):
        self.flightIntent = flightIntent
    def get_flightPlan(self):
        return self.flightPlan
    def set_flightPlan(self, flightPlan):
        self.flightPlan = flightPlan
    def get_interimAltitude(self):
        return self.interimAltitude
    def set_interimAltitude(self, interimAltitude):
        self.interimAltitude = interimAltitude
    def get_nasTmi(self):
        return self.nasTmi
    def set_nasTmi(self, nasTmi):
        self.nasTmi = nasTmi
    def get_requestedAirspeed(self):
        return self.requestedAirspeed
    def set_requestedAirspeed(self, requestedAirspeed):
        self.requestedAirspeed = requestedAirspeed
    def get_requestedAltitude(self):
        return self.requestedAltitude
    def set_requestedAltitude(self, requestedAltitude):
        self.requestedAltitude = requestedAltitude
    def get_currentRVSMCompliance(self):
        return self.currentRVSMCompliance
    def set_currentRVSMCompliance(self, currentRVSMCompliance):
        self.currentRVSMCompliance = currentRVSMCompliance
    def get_futureRVSMCompliance(self):
        return self.futureRVSMCompliance
    def set_futureRVSMCompliance(self, futureRVSMCompliance):
        self.futureRVSMCompliance = futureRVSMCompliance
    def get_tfmsFlightClass(self):
        return self.tfmsFlightClass
    def set_tfmsFlightClass(self, tfmsFlightClass):
        self.tfmsFlightClass = tfmsFlightClass
    def validate_RVSMFlightIndicatorType(self, value):
        # Validate type nas:RVSMFlightIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMPLIANT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RVSMFlightIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_NasFlightClassType(self, value):
        # Validate type nas:NasFlightClassType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['GA', 'LIFEGUARD', 'TAXI', 'CANADIAN_GA', 'MILITARY']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NasFlightClassType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.assignedAltitude is not None or
            self.coordination is not None or
            self.flightIdentificationPrevious is not None or
            self.flightIntent is not None or
            self.flightPlan is not None or
            self.interimAltitude is not None or
            self.nasTmi is not None or
            self.requestedAirspeed is not None or
            self.requestedAltitude is not None or
            super(NasFlightType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasFlightType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasFlightType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasFlightType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasFlightType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasFlightType'):
        super(NasFlightType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasFlightType')
        if self.currentRVSMCompliance is not None and 'currentRVSMCompliance' not in already_processed:
            already_processed.add('currentRVSMCompliance')
            outfile.write(' currentRVSMCompliance=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.currentRVSMCompliance), input_name='currentRVSMCompliance')), ))
        if self.futureRVSMCompliance is not None and 'futureRVSMCompliance' not in already_processed:
            already_processed.add('futureRVSMCompliance')
            outfile.write(' futureRVSMCompliance=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.futureRVSMCompliance), input_name='futureRVSMCompliance')), ))
        if self.tfmsFlightClass is not None and 'tfmsFlightClass' not in already_processed:
            already_processed.add('tfmsFlightClass')
            outfile.write(' tfmsFlightClass=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tfmsFlightClass), input_name='tfmsFlightClass')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasFlightType', fromsubclass_=False, pretty_print=True):
        super(NasFlightType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.assignedAltitude is not None:
            namespaceprefix_ = self.assignedAltitude_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedAltitude_nsprefix_) else ''
            self.assignedAltitude.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedAltitude', pretty_print=pretty_print)
        if self.coordination is not None:
            namespaceprefix_ = self.coordination_nsprefix_ + ':' if (UseCapturedNS_ and self.coordination_nsprefix_) else ''
            self.coordination.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coordination', pretty_print=pretty_print)
        if self.flightIdentificationPrevious is not None:
            namespaceprefix_ = self.flightIdentificationPrevious_nsprefix_ + ':' if (UseCapturedNS_ and self.flightIdentificationPrevious_nsprefix_) else ''
            self.flightIdentificationPrevious.export(outfile, level, namespaceprefix_, namespacedef_='', name_='flightIdentificationPrevious', pretty_print=pretty_print)
        if self.flightIntent is not None:
            namespaceprefix_ = self.flightIntent_nsprefix_ + ':' if (UseCapturedNS_ and self.flightIntent_nsprefix_) else ''
            self.flightIntent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='flightIntent', pretty_print=pretty_print)
        if self.flightPlan is not None:
            namespaceprefix_ = self.flightPlan_nsprefix_ + ':' if (UseCapturedNS_ and self.flightPlan_nsprefix_) else ''
            self.flightPlan.export(outfile, level, namespaceprefix_, namespacedef_='', name_='flightPlan', pretty_print=pretty_print)
        if self.interimAltitude is not None:
            namespaceprefix_ = self.interimAltitude_nsprefix_ + ':' if (UseCapturedNS_ and self.interimAltitude_nsprefix_) else ''
            self.interimAltitude.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interimAltitude', pretty_print=pretty_print)
        if self.nasTmi is not None:
            namespaceprefix_ = self.nasTmi_nsprefix_ + ':' if (UseCapturedNS_ and self.nasTmi_nsprefix_) else ''
            self.nasTmi.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nasTmi', pretty_print=pretty_print)
        if self.requestedAirspeed is not None:
            namespaceprefix_ = self.requestedAirspeed_nsprefix_ + ':' if (UseCapturedNS_ and self.requestedAirspeed_nsprefix_) else ''
            self.requestedAirspeed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='requestedAirspeed', pretty_print=pretty_print)
        if self.requestedAltitude is not None:
            namespaceprefix_ = self.requestedAltitude_nsprefix_ + ':' if (UseCapturedNS_ and self.requestedAltitude_nsprefix_) else ''
            self.requestedAltitude.export(outfile, level, namespaceprefix_, namespacedef_='', name_='requestedAltitude', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currentRVSMCompliance', node)
        if value is not None and 'currentRVSMCompliance' not in already_processed:
            already_processed.add('currentRVSMCompliance')
            self.currentRVSMCompliance = value
            self.validate_RVSMFlightIndicatorType(self.currentRVSMCompliance)    # validate type RVSMFlightIndicatorType
        value = find_attr_value_('futureRVSMCompliance', node)
        if value is not None and 'futureRVSMCompliance' not in already_processed:
            already_processed.add('futureRVSMCompliance')
            self.futureRVSMCompliance = value
            self.validate_RVSMFlightIndicatorType(self.futureRVSMCompliance)    # validate type RVSMFlightIndicatorType
        value = find_attr_value_('tfmsFlightClass', node)
        if value is not None and 'tfmsFlightClass' not in already_processed:
            already_processed.add('tfmsFlightClass')
            self.tfmsFlightClass = value
            self.validate_NasFlightClassType(self.tfmsFlightClass)    # validate type NasFlightClassType
        super(NasFlightType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'assignedAltitude':
            obj_ = NasAltitudeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedAltitude = obj_
            obj_.original_tagname_ = 'assignedAltitude'
        elif nodeName_ == 'coordination':
            obj_ = NasCoordinationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coordination = obj_
            obj_.original_tagname_ = 'coordination'
        elif nodeName_ == 'flightIdentificationPrevious':
            obj_ = NasFlightIdentificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.flightIdentificationPrevious = obj_
            obj_.original_tagname_ = 'flightIdentificationPrevious'
        elif nodeName_ == 'flightIntent':
            obj_ = FlightIntentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.flightIntent = obj_
            obj_.original_tagname_ = 'flightIntent'
        elif nodeName_ == 'flightPlan':
            obj_ = NasFlightPlanType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.flightPlan = obj_
            obj_.original_tagname_ = 'flightPlan'
        elif nodeName_ == 'interimAltitude':
            class_obj_ = self.get_class_obj_(child_, SimpleAltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interimAltitude = obj_
            obj_.original_tagname_ = 'interimAltitude'
        elif nodeName_ == 'nasTmi':
            obj_ = NasTmiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nasTmi = obj_
            obj_.original_tagname_ = 'nasTmi'
        elif nodeName_ == 'requestedAirspeed':
            obj_ = NasAirspeedChoiceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.requestedAirspeed = obj_
            obj_.original_tagname_ = 'requestedAirspeed'
        elif nodeName_ == 'requestedAltitude':
            obj_ = NasAltitudeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.requestedAltitude = obj_
            obj_.original_tagname_ = 'requestedAltitude'
        super(NasFlightType, self).buildChildren(child_, node, nodeName_, True)
# end class NasFlightType


class NasFlightIdentificationType(FlightIdentificationType):
    """Extends aircraft identity to include computer id and SSPID.
    .Site Specific Plan Identifier: Site Specific Plan Identifier is a unique
    ID for
    each system plan in each ERAM facility.
    .Computer ID: A unique identification assigned by ERAM to each flight plan.
    .Computer ID: A unique identification assigned by ERAM to each flight plan.
    .Site Specific Plan Identifier: Site Specific Plan Identifier is a unique
    ID for
    each system plan in each ERAM facility."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FlightIdentificationType
    def __init__(self, aircraftIdentification=None, majorCarrierIdentifier=None, marketingCarrierFlightIdentifier=None, computerId=None, siteSpecificPlanId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasFlightIdentificationType, self).__init__(aircraftIdentification, majorCarrierIdentifier, marketingCarrierFlightIdentifier,  **kwargs_)
        self.computerId = _cast(None, computerId)
        self.computerId_nsprefix_ = None
        self.siteSpecificPlanId = _cast(None, siteSpecificPlanId)
        self.siteSpecificPlanId_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasFlightIdentificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasFlightIdentificationType.subclass:
            return NasFlightIdentificationType.subclass(*args_, **kwargs_)
        else:
            return NasFlightIdentificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_computerId(self):
        return self.computerId
    def set_computerId(self, computerId):
        self.computerId = computerId
    def get_siteSpecificPlanId(self):
        return self.siteSpecificPlanId
    def set_siteSpecificPlanId(self, siteSpecificPlanId):
        self.siteSpecificPlanId = siteSpecificPlanId
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_CountType(self, value):
        # Validate type fb:CountType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on CountType' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(NasFlightIdentificationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasFlightIdentificationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasFlightIdentificationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasFlightIdentificationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasFlightIdentificationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasFlightIdentificationType'):
        super(NasFlightIdentificationType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasFlightIdentificationType')
        if self.computerId is not None and 'computerId' not in already_processed:
            already_processed.add('computerId')
            outfile.write(' computerId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.computerId), input_name='computerId')), ))
        if self.siteSpecificPlanId is not None and 'siteSpecificPlanId' not in already_processed:
            already_processed.add('siteSpecificPlanId')
            outfile.write(' siteSpecificPlanId="%s"' % self.gds_format_integer(self.siteSpecificPlanId, input_name='siteSpecificPlanId'))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasFlightIdentificationType', fromsubclass_=False, pretty_print=True):
        super(NasFlightIdentificationType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('computerId', node)
        if value is not None and 'computerId' not in already_processed:
            already_processed.add('computerId')
            self.computerId = value
            self.validate_FreeTextType(self.computerId)    # validate type FreeTextType
        value = find_attr_value_('siteSpecificPlanId', node)
        if value is not None and 'siteSpecificPlanId' not in already_processed:
            already_processed.add('siteSpecificPlanId')
            self.siteSpecificPlanId = self.gds_parse_integer(value, node, 'siteSpecificPlanId')
            self.validate_CountType(self.siteSpecificPlanId)    # validate type CountType
        super(NasFlightIdentificationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(NasFlightIdentificationType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NasFlightIdentificationType


class NasSupplementalDataType(SupplementalDataType):
    """Container for additional data specific to nas such as additional flight
    information."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SupplementalDataType
    def __init__(self, fuelEndurance=None, personsOnBoard=None, pilotInCommand=None, additionalFlightInformation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasSupplementalDataType, self).__init__(fuelEndurance, personsOnBoard, pilotInCommand,  **kwargs_)
        self.additionalFlightInformation = additionalFlightInformation
        self.additionalFlightInformation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasSupplementalDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasSupplementalDataType.subclass:
            return NasSupplementalDataType.subclass(*args_, **kwargs_)
        else:
            return NasSupplementalDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_additionalFlightInformation(self):
        return self.additionalFlightInformation
    def set_additionalFlightInformation(self, additionalFlightInformation):
        self.additionalFlightInformation = additionalFlightInformation
    def hasContent_(self):
        if (
            self.additionalFlightInformation is not None or
            super(NasSupplementalDataType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='NasSupplementalDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasSupplementalDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasSupplementalDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasSupplementalDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasSupplementalDataType'):
        super(NasSupplementalDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasSupplementalDataType')
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='NasSupplementalDataType', fromsubclass_=False, pretty_print=True):
        super(NasSupplementalDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.additionalFlightInformation is not None:
            namespaceprefix_ = self.additionalFlightInformation_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalFlightInformation_nsprefix_) else ''
            self.additionalFlightInformation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalFlightInformation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NasSupplementalDataType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'additionalFlightInformation':
            obj_ = NameValueListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalFlightInformation = obj_
            obj_.original_tagname_ = 'additionalFlightInformation'
        super(NasSupplementalDataType, self).buildChildren(child_, node, nodeName_, True)
# end class NasSupplementalDataType


class ArrivalMovementAreaHoldInformationType(GeneratedsSuper):
    """.Airport Movement Area Holding - Departure Information: Indicates the
    intent for
    a departing flight to hold in the airport movement area when surface
    departure metering
    or other Traffic Management Initiatives are in effect, and the time when
    the flight
    is estimated to request entry in the airport movement area.
    .Airport Movement Area Holding - Arrival Information: Indicates the intent
    for an
    arriving flight to hold in the airport movement area due to unavailability
    of a parking
    stand or ramp access, and the time when the flight is estimated to exit the
    airport
    movement area.
    .Movement Area Entry Time - Airspace User Requested: Indicates the time
    when the
    flight is estimated to request entry in the airport movement area.
    .Movement Area Exit Time - Airspace User Requested: Indicates the time when
    the flight
    is estimated to exit the airport movement area.
    .Airport Movement Area Holding Intent - Departure: Indicates the intent for
    a departing
    flight to hold in the airport movement area when surface departure metering
    or other
    Traffic Management Initiatives are in effect.
    .Airport Movement Area Holding Intent - Arrival: Indicates the intent for
    an arriving
    flight to hold in the airport movement area due to unavailability of a
    parking stand
    or ramp access."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, estimatedExitTime=None, holdIntent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.estimatedExitTime = _cast(None, estimatedExitTime)
        self.estimatedExitTime_nsprefix_ = None
        self.holdIntent = _cast(None, holdIntent)
        self.holdIntent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArrivalMovementAreaHoldInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArrivalMovementAreaHoldInformationType.subclass:
            return ArrivalMovementAreaHoldInformationType.subclass(*args_, **kwargs_)
        else:
            return ArrivalMovementAreaHoldInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_estimatedExitTime(self):
        return self.estimatedExitTime
    def set_estimatedExitTime(self, estimatedExitTime):
        self.estimatedExitTime = estimatedExitTime
    def get_holdIntent(self):
        return self.holdIntent
    def set_holdIntent(self, holdIntent):
        self.holdIntent = holdIntent
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_HoldIntentType(self, value):
        # Validate type nas:HoldIntentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['HOLD', 'NO_HOLD']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on HoldIntentType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='ArrivalMovementAreaHoldInformationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArrivalMovementAreaHoldInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArrivalMovementAreaHoldInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArrivalMovementAreaHoldInformationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='ArrivalMovementAreaHoldInformationType'):
        if self.estimatedExitTime is not None and 'estimatedExitTime' not in already_processed:
            already_processed.add('estimatedExitTime')
            outfile.write(' estimatedExitTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.estimatedExitTime), input_name='estimatedExitTime')), ))
        if self.holdIntent is not None and 'holdIntent' not in already_processed:
            already_processed.add('holdIntent')
            outfile.write(' holdIntent=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.holdIntent), input_name='holdIntent')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='ArrivalMovementAreaHoldInformationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('estimatedExitTime', node)
        if value is not None and 'estimatedExitTime' not in already_processed:
            already_processed.add('estimatedExitTime')
            try:
                self.estimatedExitTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (estimatedExitTime): %s' % exp)
            self.validate_TimeType(self.estimatedExitTime)    # validate type TimeType
        value = find_attr_value_('holdIntent', node)
        if value is not None and 'holdIntent' not in already_processed:
            already_processed.add('holdIntent')
            self.holdIntent = value
            self.validate_HoldIntentType(self.holdIntent)    # validate type HoldIntentType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ArrivalMovementAreaHoldInformationType


class DeicingInformationType(GeneratedsSuper):
    """.Deicing Information: Indicates the intent for the flight to be deiced
    and the intended
    deicing location.
    .Deicing Intent: Indicates the intent for the flight to be deiced.
    .Deicing Location: Indicates the location where the flight intends to be
    deiced."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, deicingIntent=None, deicingLocation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.deicingIntent = _cast(None, deicingIntent)
        self.deicingIntent_nsprefix_ = None
        self.deicingLocation = _cast(None, deicingLocation)
        self.deicingLocation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeicingInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeicingInformationType.subclass:
            return DeicingInformationType.subclass(*args_, **kwargs_)
        else:
            return DeicingInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_deicingIntent(self):
        return self.deicingIntent
    def set_deicingIntent(self, deicingIntent):
        self.deicingIntent = deicingIntent
    def get_deicingLocation(self):
        return self.deicingLocation
    def set_deicingLocation(self, deicingLocation):
        self.deicingLocation = deicingLocation
    def validate_DeicingIntentType(self, value):
        # Validate type nas:DeicingIntentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEICE', 'NO_DEICE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DeicingIntentType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='DeicingInformationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeicingInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeicingInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DeicingInformationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='DeicingInformationType'):
        if self.deicingIntent is not None and 'deicingIntent' not in already_processed:
            already_processed.add('deicingIntent')
            outfile.write(' deicingIntent=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.deicingIntent), input_name='deicingIntent')), ))
        if self.deicingLocation is not None and 'deicingLocation' not in already_processed:
            already_processed.add('deicingLocation')
            outfile.write(' deicingLocation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.deicingLocation), input_name='deicingLocation')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='DeicingInformationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deicingIntent', node)
        if value is not None and 'deicingIntent' not in already_processed:
            already_processed.add('deicingIntent')
            self.deicingIntent = value
            self.validate_DeicingIntentType(self.deicingIntent)    # validate type DeicingIntentType
        value = find_attr_value_('deicingLocation', node)
        if value is not None and 'deicingLocation' not in already_processed:
            already_processed.add('deicingLocation')
            self.deicingLocation = value
            self.validate_FreeTextType(self.deicingLocation)    # validate type FreeTextType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DeicingInformationType


class DepartureMovementAreaHoldInformationType(GeneratedsSuper):
    """.Airport Movement Area Holding - Departure Information: Indicates the
    intent for
    a departing flight to hold in the airport movement area when surface
    departure metering
    or other Traffic Management Initiatives are in effect, and the time when
    the flight
    is estimated to request entry in the airport movement area.
    .Airport Movement Area Holding - Arrival Information: Indicates the intent
    for an
    arriving flight to hold in the airport movement area due to unavailability
    of a parking
    stand or ramp access, and the time when the flight is estimated to exit the
    airport
    movement area.
    .Movement Area Entry Time - Airspace User Requested: Indicates the time
    when the
    flight is estimated to request entry in the airport movement area.
    .Movement Area Exit Time - Airspace User Requested: Indicates the time when
    the flight
    is estimated to exit the airport movement area.
    .Airport Movement Area Holding Intent - Departure: Indicates the intent for
    a departing
    flight to hold in the airport movement area when surface departure metering
    or other
    Traffic Management Initiatives are in effect.
    .Airport Movement Area Holding Intent - Arrival: Indicates the intent for
    an arriving
    flight to hold in the airport movement area due to unavailability of a
    parking stand
    or ramp access."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, estimatedEntryTime=None, holdIntent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.estimatedEntryTime = _cast(None, estimatedEntryTime)
        self.estimatedEntryTime_nsprefix_ = None
        self.holdIntent = _cast(None, holdIntent)
        self.holdIntent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DepartureMovementAreaHoldInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DepartureMovementAreaHoldInformationType.subclass:
            return DepartureMovementAreaHoldInformationType.subclass(*args_, **kwargs_)
        else:
            return DepartureMovementAreaHoldInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_estimatedEntryTime(self):
        return self.estimatedEntryTime
    def set_estimatedEntryTime(self, estimatedEntryTime):
        self.estimatedEntryTime = estimatedEntryTime
    def get_holdIntent(self):
        return self.holdIntent
    def set_holdIntent(self, holdIntent):
        self.holdIntent = holdIntent
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_HoldIntentType(self, value):
        # Validate type nas:HoldIntentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['HOLD', 'NO_HOLD']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on HoldIntentType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='DepartureMovementAreaHoldInformationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DepartureMovementAreaHoldInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DepartureMovementAreaHoldInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DepartureMovementAreaHoldInformationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='DepartureMovementAreaHoldInformationType'):
        if self.estimatedEntryTime is not None and 'estimatedEntryTime' not in already_processed:
            already_processed.add('estimatedEntryTime')
            outfile.write(' estimatedEntryTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.estimatedEntryTime), input_name='estimatedEntryTime')), ))
        if self.holdIntent is not None and 'holdIntent' not in already_processed:
            already_processed.add('holdIntent')
            outfile.write(' holdIntent=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.holdIntent), input_name='holdIntent')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='DepartureMovementAreaHoldInformationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('estimatedEntryTime', node)
        if value is not None and 'estimatedEntryTime' not in already_processed:
            already_processed.add('estimatedEntryTime')
            try:
                self.estimatedEntryTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (estimatedEntryTime): %s' % exp)
            self.validate_TimeType(self.estimatedEntryTime)    # validate type TimeType
        value = find_attr_value_('holdIntent', node)
        if value is not None and 'holdIntent' not in already_processed:
            already_processed.add('holdIntent')
            self.holdIntent = value
            self.validate_HoldIntentType(self.holdIntent)    # validate type HoldIntentType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DepartureMovementAreaHoldInformationType


class FlightIntentType(GeneratedsSuper):
    """.Flight Intent: A container for the list of intent values provided by
    the flight
    operator that designate the intentions of a flight prior to departure from
    an aerodrome
    or after arrival at an aerodrome.
    .Intended Arrival Spot: Indicates the location intended for the flight to
    enter the
    non-movement area from the airport movement area.
    .Intended Departure Spot: Indicates the location intended for the flight to
    enter
    the airport movement area from the non-movement area.
    .Stand Return Intent: Indicates the intent for the flight to return to the
    stand."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, intendedArrivalSpot=None, intendedDepartureSpot=None, standReturnIntent=None, arrival=None, deicing=None, departure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.intendedArrivalSpot = _cast(None, intendedArrivalSpot)
        self.intendedArrivalSpot_nsprefix_ = None
        self.intendedDepartureSpot = _cast(None, intendedDepartureSpot)
        self.intendedDepartureSpot_nsprefix_ = None
        self.standReturnIntent = _cast(None, standReturnIntent)
        self.standReturnIntent_nsprefix_ = None
        self.arrival = arrival
        self.arrival_nsprefix_ = None
        self.deicing = deicing
        self.deicing_nsprefix_ = None
        self.departure = departure
        self.departure_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlightIntentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlightIntentType.subclass:
            return FlightIntentType.subclass(*args_, **kwargs_)
        else:
            return FlightIntentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_arrival(self):
        return self.arrival
    def set_arrival(self, arrival):
        self.arrival = arrival
    def get_deicing(self):
        return self.deicing
    def set_deicing(self, deicing):
        self.deicing = deicing
    def get_departure(self):
        return self.departure
    def set_departure(self, departure):
        self.departure = departure
    def get_intendedArrivalSpot(self):
        return self.intendedArrivalSpot
    def set_intendedArrivalSpot(self, intendedArrivalSpot):
        self.intendedArrivalSpot = intendedArrivalSpot
    def get_intendedDepartureSpot(self):
        return self.intendedDepartureSpot
    def set_intendedDepartureSpot(self, intendedDepartureSpot):
        self.intendedDepartureSpot = intendedDepartureSpot
    def get_standReturnIntent(self):
        return self.standReturnIntent
    def set_standReturnIntent(self, standReturnIntent):
        self.standReturnIntent = standReturnIntent
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_StandReturnIntentType(self, value):
        # Validate type nas:StandReturnIntentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['RETURN', 'NO_RETURN']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StandReturnIntentType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.arrival is not None or
            self.deicing is not None or
            self.departure is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='FlightIntentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlightIntentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlightIntentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlightIntentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='FlightIntentType'):
        if self.intendedArrivalSpot is not None and 'intendedArrivalSpot' not in already_processed:
            already_processed.add('intendedArrivalSpot')
            outfile.write(' intendedArrivalSpot=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.intendedArrivalSpot), input_name='intendedArrivalSpot')), ))
        if self.intendedDepartureSpot is not None and 'intendedDepartureSpot' not in already_processed:
            already_processed.add('intendedDepartureSpot')
            outfile.write(' intendedDepartureSpot=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.intendedDepartureSpot), input_name='intendedDepartureSpot')), ))
        if self.standReturnIntent is not None and 'standReturnIntent' not in already_processed:
            already_processed.add('standReturnIntent')
            outfile.write(' standReturnIntent=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.standReturnIntent), input_name='standReturnIntent')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='FlightIntentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.arrival is not None:
            namespaceprefix_ = self.arrival_nsprefix_ + ':' if (UseCapturedNS_ and self.arrival_nsprefix_) else ''
            self.arrival.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arrival', pretty_print=pretty_print)
        if self.deicing is not None:
            namespaceprefix_ = self.deicing_nsprefix_ + ':' if (UseCapturedNS_ and self.deicing_nsprefix_) else ''
            self.deicing.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deicing', pretty_print=pretty_print)
        if self.departure is not None:
            namespaceprefix_ = self.departure_nsprefix_ + ':' if (UseCapturedNS_ and self.departure_nsprefix_) else ''
            self.departure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='departure', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('intendedArrivalSpot', node)
        if value is not None and 'intendedArrivalSpot' not in already_processed:
            already_processed.add('intendedArrivalSpot')
            self.intendedArrivalSpot = value
            self.validate_FreeTextType(self.intendedArrivalSpot)    # validate type FreeTextType
        value = find_attr_value_('intendedDepartureSpot', node)
        if value is not None and 'intendedDepartureSpot' not in already_processed:
            already_processed.add('intendedDepartureSpot')
            self.intendedDepartureSpot = value
            self.validate_FreeTextType(self.intendedDepartureSpot)    # validate type FreeTextType
        value = find_attr_value_('standReturnIntent', node)
        if value is not None and 'standReturnIntent' not in already_processed:
            already_processed.add('standReturnIntent')
            self.standReturnIntent = value
            self.validate_StandReturnIntentType(self.standReturnIntent)    # validate type StandReturnIntentType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'arrival':
            obj_ = ArrivalMovementAreaHoldInformationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arrival = obj_
            obj_.original_tagname_ = 'arrival'
        elif nodeName_ == 'deicing':
            obj_ = DeicingInformationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deicing = obj_
            obj_.original_tagname_ = 'deicing'
        elif nodeName_ == 'departure':
            obj_ = DepartureMovementAreaHoldInformationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.departure = obj_
            obj_.original_tagname_ = 'departure'
# end class FlightIntentType


class NasFlightPlanType(FeatureType):
    """Describes the flight plan structure used by NAS. Based on core ICAO
    flight plan.
    .Traffic Flow Management System Flight Plan Remarks: NAS Flight Plan Field
    11 remarks
    processed by the Traffic Flow Management System (TFMS) and used for TFM
    purposes.
    .Flight Plan Identifier: The flight plan identifier is used to uniquely
    name a flight
    plan within the scope of its flight."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FeatureType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, flightPlanRemarks=None, identifier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasFlightPlanType, self).__init__(centre, source, system, timestamp,  **kwargs_)
        self.flightPlanRemarks = _cast(None, flightPlanRemarks)
        self.flightPlanRemarks_nsprefix_ = None
        self.identifier = _cast(None, identifier)
        self.identifier_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasFlightPlanType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasFlightPlanType.subclass:
            return NasFlightPlanType.subclass(*args_, **kwargs_)
        else:
            return NasFlightPlanType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_flightPlanRemarks(self):
        return self.flightPlanRemarks
    def set_flightPlanRemarks(self, flightPlanRemarks):
        self.flightPlanRemarks = flightPlanRemarks
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(NasFlightPlanType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasFlightPlanType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasFlightPlanType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasFlightPlanType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasFlightPlanType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasFlightPlanType'):
        super(NasFlightPlanType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasFlightPlanType')
        if self.flightPlanRemarks is not None and 'flightPlanRemarks' not in already_processed:
            already_processed.add('flightPlanRemarks')
            outfile.write(' flightPlanRemarks=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.flightPlanRemarks), input_name='flightPlanRemarks')), ))
        if self.identifier is not None and 'identifier' not in already_processed:
            already_processed.add('identifier')
            outfile.write(' identifier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.identifier), input_name='identifier')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasFlightPlanType', fromsubclass_=False, pretty_print=True):
        super(NasFlightPlanType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('flightPlanRemarks', node)
        if value is not None and 'flightPlanRemarks' not in already_processed:
            already_processed.add('flightPlanRemarks')
            self.flightPlanRemarks = value
            self.validate_FreeTextType(self.flightPlanRemarks)    # validate type FreeTextType
        value = find_attr_value_('identifier', node)
        if value is not None and 'identifier' not in already_processed:
            already_processed.add('identifier')
            self.identifier = value
            self.validate_FreeTextType(self.identifier)    # validate type FreeTextType
        super(NasFlightPlanType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(NasFlightPlanType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NasFlightPlanType


class AbstractMessageType(GeneratedsSuper):
    """The Message type is the smallest unit of data transmission between
    components. It
    contains identifying metadata and a payload. It is expected that extensions
    will
    extend this to define their own message types, including their own
    payloads."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, metadata=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.metadata = metadata
        self.metadata_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractMessageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractMessageType.subclass:
            return AbstractMessageType.subclass(*args_, **kwargs_)
        else:
            return AbstractMessageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_metadata(self):
        return self.metadata
    def set_metadata(self, metadata):
        self.metadata = metadata
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.metadata is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='AbstractMessageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbstractMessageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractMessageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AbstractMessageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='AbstractMessageType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='AbstractMessageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.metadata is not None:
            namespaceprefix_ = self.metadata_nsprefix_ + ':' if (UseCapturedNS_ and self.metadata_nsprefix_) else ''
            self.metadata.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metadata', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'metadata':
            obj_ = MessageMetadataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metadata = obj_
            obj_.original_tagname_ = 'metadata'
# end class AbstractMessageType


class FeatureMessageType(AbstractMessageType):
    """It is expected that extensions will extend this to define their own
    message types,
    including their own payloads."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AbstractMessageType
    def __init__(self, metadata=None, feature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FeatureMessageType, self).__init__(metadata,  **kwargs_)
        self.feature = feature
        self.feature_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FeatureMessageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FeatureMessageType.subclass:
            return FeatureMessageType.subclass(*args_, **kwargs_)
        else:
            return FeatureMessageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_feature(self):
        return self.feature
    def set_feature(self, feature):
        self.feature = feature
    def set_feature_with_type(self, value):
        self.feature = value
        value.original_tagname_ = 'feature'
        value.extensiontype_ = value.__class__.__name__
    def hasContent_(self):
        if (
            self.feature is not None or
            super(FeatureMessageType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='FeatureMessageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FeatureMessageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FeatureMessageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FeatureMessageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='FeatureMessageType'):
        super(FeatureMessageType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FeatureMessageType')
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='FeatureMessageType', fromsubclass_=False, pretty_print=True):
        super(FeatureMessageType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.feature is not None:
            self.feature.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FeatureMessageType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'feature':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <feature> element')
            self.feature = obj_
            obj_.original_tagname_ = 'feature'
        super(FeatureMessageType, self).buildChildren(child_, node, nodeName_, True)
# end class FeatureMessageType


class FlightMessageType(AbstractMessageType):
    """FlightMessage is used to transmit FIXM flight objects."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AbstractMessageType
    def __init__(self, metadata=None, flight=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FlightMessageType, self).__init__(metadata,  **kwargs_)
        self.flight = flight
        self.flight_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlightMessageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlightMessageType.subclass:
            return FlightMessageType.subclass(*args_, **kwargs_)
        else:
            return FlightMessageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_flight(self):
        return self.flight
    def set_flight(self, flight):
        self.flight = flight
    def hasContent_(self):
        if (
            self.flight is not None or
            super(FlightMessageType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='FlightMessageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlightMessageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlightMessageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlightMessageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='FlightMessageType'):
        super(FlightMessageType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlightMessageType')
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:fx="http://www.fixm.aero/flight/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='FlightMessageType', fromsubclass_=False, pretty_print=True):
        super(FlightMessageType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.flight is not None:
            namespaceprefix_ = self.flight_nsprefix_ + ':' if (UseCapturedNS_ and self.flight_nsprefix_) else ''
            self.flight.export(outfile, level, namespaceprefix_, namespacedef_='', name_='flight', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FlightMessageType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'flight':
            class_obj_ = self.get_class_obj_(child_, FlightType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.flight = obj_
            obj_.original_tagname_ = 'flight'
        super(FlightMessageType, self).buildChildren(child_, node, nodeName_, True)
# end class FlightMessageType


class MessageCollectionType(GeneratedsSuper):
    """The MessageCollection type is a mechanism for aggregating messages to be
    transmitted
    as a group. This is useful
    both to aggregate messages about one flight, and to pack many messages
    together for transmission efficiency."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, message=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if message is None:
            self.message = []
        else:
            self.message = message
        self.message_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageCollectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageCollectionType.subclass:
            return MessageCollectionType.subclass(*args_, **kwargs_)
        else:
            return MessageCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_message(self):
        return self.message
    def set_message(self, message):
        self.message = message
    def set_message_with_type(self, value):
        self.message = value
        value.original_tagname_ = 'message'
        value.extensiontype_ = value.__class__.__name__
    def add_message(self, value):
        self.message.append(value)
    def add_message_with_type(self, value):
        self.message.append(value)
        value.original_tagname_ = 'message'
        value.extensiontype_ = value.__class__.__name__
    def insert_message_at(self, index, value):
        self.message.insert(index, value)
    def replace_message_at(self, index, value):
        self.message[index] = value
    def hasContent_(self):
        if (
            self.message
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='MessageCollectionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MessageCollectionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessageCollectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MessageCollectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='MessageCollectionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='MessageCollectionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for message_ in self.message:
            message_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'message':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <message> element')
            self.message.append(obj_)
            obj_.original_tagname_ = 'message'
# end class MessageCollectionType


class MessageMetadataType(GeneratedsSuper):
    """The MessageMetadata provides a unique message identifier, the origin of
    the message
    in time and location,
    the system
    that produced the message, and the time span over which the message data is
    valid.
    The GUMI is the Globally Unique Message Identifier. It has the following
    format:
    "urn":"fixm.aero":system:subsystem:timestamp:sequence
    where:system is the major system involved, eg "nas"
    subsystem is the minor system involved, eg "eram"
    timestamp is a time stamp to the second with all punctuation and time
    offset squeezed out
    sequence is an ascending integer to ensure uniqueness within the second
    example:
    urn:fixm.aero:nas:eram:20120606T142534:384"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gumi=None, generationLocation=None, validTimeSpan=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.gumi = _cast(None, gumi)
        self.gumi_nsprefix_ = None
        self.generationLocation = generationLocation
        self.generationLocation_nsprefix_ = None
        self.validTimeSpan = validTimeSpan
        self.validTimeSpan_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageMetadataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageMetadataType.subclass:
            return MessageMetadataType.subclass(*args_, **kwargs_)
        else:
            return MessageMetadataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_generationLocation(self):
        return self.generationLocation
    def set_generationLocation(self, generationLocation):
        self.generationLocation = generationLocation
    def get_validTimeSpan(self):
        return self.validTimeSpan
    def set_validTimeSpan(self, validTimeSpan):
        self.validTimeSpan = validTimeSpan
    def get_gumi(self):
        return self.gumi
    def set_gumi(self, gumi):
        self.gumi = gumi
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.generationLocation is not None or
            self.validTimeSpan is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='MessageMetadataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MessageMetadataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessageMetadataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MessageMetadataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='MessageMetadataType'):
        if self.gumi is not None and 'gumi' not in already_processed:
            already_processed.add('gumi')
            outfile.write(' gumi=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gumi), input_name='gumi')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='MessageMetadataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.generationLocation is not None:
            namespaceprefix_ = self.generationLocation_nsprefix_ + ':' if (UseCapturedNS_ and self.generationLocation_nsprefix_) else ''
            self.generationLocation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='generationLocation', pretty_print=pretty_print)
        if self.validTimeSpan is not None:
            namespaceprefix_ = self.validTimeSpan_nsprefix_ + ':' if (UseCapturedNS_ and self.validTimeSpan_nsprefix_) else ''
            self.validTimeSpan.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTimeSpan', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gumi', node)
        if value is not None and 'gumi' not in already_processed:
            already_processed.add('gumi')
            self.gumi = value
            self.validate_FreeTextType(self.gumi)    # validate type FreeTextType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'generationLocation':
            class_obj_ = self.get_class_obj_(child_, GeographicLocationType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.generationLocation = obj_
            obj_.original_tagname_ = 'generationLocation'
        elif nodeName_ == 'validTimeSpan':
            obj_ = TimeSpanType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validTimeSpan = obj_
            obj_.original_tagname_ = 'validTimeSpan'
# end class MessageMetadataType


class NasAircraftPositionType(AircraftPositionType):
    """Container for NAS target and track aircraft positions.
    .Coast Indicator: An indicator the aircraft was unexpectedly not detected
    by radar
    (after a period of tracking).
    .Target Position Time: The time associated with the raw radar return."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AircraftPositionType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, positionTime=None, reportSource=None, actualSpeed=None, altitude=None, followingPosition=None, nextPosition=None, position=None, track=None, coastIndicator=None, targetPositionTime=None, targetAltitude=None, targetPosition=None, trackVelocity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasAircraftPositionType, self).__init__(centre, source, system, timestamp, positionTime, reportSource, actualSpeed, altitude, followingPosition, nextPosition, position, track,  **kwargs_)
        self.coastIndicator = _cast(None, coastIndicator)
        self.coastIndicator_nsprefix_ = None
        self.targetPositionTime = _cast(None, targetPositionTime)
        self.targetPositionTime_nsprefix_ = None
        self.targetAltitude = targetAltitude
        self.targetAltitude_nsprefix_ = None
        self.targetPosition = targetPosition
        self.targetPosition_nsprefix_ = None
        self.trackVelocity = trackVelocity
        self.trackVelocity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasAircraftPositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasAircraftPositionType.subclass:
            return NasAircraftPositionType.subclass(*args_, **kwargs_)
        else:
            return NasAircraftPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_targetAltitude(self):
        return self.targetAltitude
    def set_targetAltitude(self, targetAltitude):
        self.targetAltitude = targetAltitude
    def get_targetPosition(self):
        return self.targetPosition
    def set_targetPosition(self, targetPosition):
        self.targetPosition = targetPosition
    def get_trackVelocity(self):
        return self.trackVelocity
    def set_trackVelocity(self, trackVelocity):
        self.trackVelocity = trackVelocity
    def get_coastIndicator(self):
        return self.coastIndicator
    def set_coastIndicator(self, coastIndicator):
        self.coastIndicator = coastIndicator
    def get_targetPositionTime(self):
        return self.targetPositionTime
    def set_targetPositionTime(self, targetPositionTime):
        self.targetPositionTime = targetPositionTime
    def validate_NasCoastIndicatorType(self, value):
        # Validate type nas:NasCoastIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COASTING']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NasCoastIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.targetAltitude is not None or
            self.targetPosition is not None or
            self.trackVelocity is not None or
            super(NasAircraftPositionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='NasAircraftPositionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasAircraftPositionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasAircraftPositionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasAircraftPositionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasAircraftPositionType'):
        super(NasAircraftPositionType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasAircraftPositionType')
        if self.coastIndicator is not None and 'coastIndicator' not in already_processed:
            already_processed.add('coastIndicator')
            outfile.write(' coastIndicator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.coastIndicator), input_name='coastIndicator')), ))
        if self.targetPositionTime is not None and 'targetPositionTime' not in already_processed:
            already_processed.add('targetPositionTime')
            outfile.write(' targetPositionTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetPositionTime), input_name='targetPositionTime')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0" ', name_='NasAircraftPositionType', fromsubclass_=False, pretty_print=True):
        super(NasAircraftPositionType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.targetAltitude is not None:
            namespaceprefix_ = self.targetAltitude_nsprefix_ + ':' if (UseCapturedNS_ and self.targetAltitude_nsprefix_) else ''
            self.targetAltitude.export(outfile, level, namespaceprefix_, namespacedef_='', name_='targetAltitude', pretty_print=pretty_print)
        if self.targetPosition is not None:
            namespaceprefix_ = self.targetPosition_nsprefix_ + ':' if (UseCapturedNS_ and self.targetPosition_nsprefix_) else ''
            self.targetPosition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='targetPosition', pretty_print=pretty_print)
        if self.trackVelocity is not None:
            namespaceprefix_ = self.trackVelocity_nsprefix_ + ':' if (UseCapturedNS_ and self.trackVelocity_nsprefix_) else ''
            self.trackVelocity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='trackVelocity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coastIndicator', node)
        if value is not None and 'coastIndicator' not in already_processed:
            already_processed.add('coastIndicator')
            self.coastIndicator = value
            self.validate_NasCoastIndicatorType(self.coastIndicator)    # validate type NasCoastIndicatorType
        value = find_attr_value_('targetPositionTime', node)
        if value is not None and 'targetPositionTime' not in already_processed:
            already_processed.add('targetPositionTime')
            try:
                self.targetPositionTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (targetPositionTime): %s' % exp)
            self.validate_TimeType(self.targetPositionTime)    # validate type TimeType
        super(NasAircraftPositionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'targetAltitude':
            obj_ = NasPositionAltitudeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.targetAltitude = obj_
            obj_.original_tagname_ = 'targetAltitude'
        elif nodeName_ == 'targetPosition':
            class_obj_ = self.get_class_obj_(child_, GeographicLocationType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.targetPosition = obj_
            obj_.original_tagname_ = 'targetPosition'
        elif nodeName_ == 'trackVelocity':
            obj_ = NasVelocityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.trackVelocity = obj_
            obj_.original_tagname_ = 'trackVelocity'
        super(NasAircraftPositionType, self).buildChildren(child_, node, nodeName_, True)
# end class NasAircraftPositionType


class NasPositionAltitudeType(SimpleAltitudeType):
    """The Mode C target altitude, corrected for barometric pressure.
    Suspected invalid altitudes marked with the 'invalid' attribute
    .Target Altitude: The Mode C target altitude, corrected for barometric
    pressure.
    Can be marked as invalid.
    Indicates whether target altitude is invalid."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SimpleAltitudeType
    def __init__(self, ref=None, uom=None, invalid=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasPositionAltitudeType, self).__init__(ref, uom, valueOf_,  **kwargs_)
        self.invalid = _cast(None, invalid)
        self.invalid_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasPositionAltitudeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasPositionAltitudeType.subclass:
            return NasPositionAltitudeType.subclass(*args_, **kwargs_)
        else:
            return NasPositionAltitudeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invalid(self):
        return self.invalid
    def set_invalid(self, invalid):
        self.invalid = invalid
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_InvalidIndicatorType(self, value):
        # Validate type nas:InvalidIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INVALID']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InvalidIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(NasPositionAltitudeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasPositionAltitudeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasPositionAltitudeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasPositionAltitudeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasPositionAltitudeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasPositionAltitudeType'):
        super(NasPositionAltitudeType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasPositionAltitudeType')
        if self.invalid is not None and 'invalid' not in already_processed:
            already_processed.add('invalid')
            outfile.write(' invalid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.invalid), input_name='invalid')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasPositionAltitudeType', fromsubclass_=False, pretty_print=True):
        super(NasPositionAltitudeType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('invalid', node)
        if value is not None and 'invalid' not in already_processed:
            already_processed.add('invalid')
            self.invalid = value
            self.validate_InvalidIndicatorType(self.invalid)    # validate type InvalidIndicatorType
        super(NasPositionAltitudeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NasPositionAltitudeType


class NasVelocityType(GeneratedsSuper):
    """Describes flight's velocity in X and Y axes
    .Track Speed Components: Speed of the radar surveillance track along the X
    and Y
    components."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, x=None, y=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.x = x
        self.x_nsprefix_ = None
        self.y = y
        self.y_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasVelocityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasVelocityType.subclass:
            return NasVelocityType.subclass(*args_, **kwargs_)
        else:
            return NasVelocityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def hasContent_(self):
        if (
            self.x is not None or
            self.y is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='NasVelocityType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasVelocityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasVelocityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasVelocityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasVelocityType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='NasVelocityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.x is not None:
            namespaceprefix_ = self.x_nsprefix_ + ':' if (UseCapturedNS_ and self.x_nsprefix_) else ''
            self.x.export(outfile, level, namespaceprefix_, namespacedef_='', name_='x', pretty_print=pretty_print)
        if self.y is not None:
            namespaceprefix_ = self.y_nsprefix_ + ':' if (UseCapturedNS_ and self.y_nsprefix_) else ''
            self.y.export(outfile, level, namespaceprefix_, namespacedef_='', name_='y', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'x':
            class_obj_ = self.get_class_obj_(child_, AirspeedInIasOrMachType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.x = obj_
            obj_.original_tagname_ = 'x'
        elif nodeName_ == 'y':
            class_obj_ = self.get_class_obj_(child_, AirspeedInIasOrMachType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.y = obj_
            obj_.original_tagname_ = 'y'
# end class NasVelocityType


class NasAdaptedRouteType(GeneratedsSuper):
    """Representation of converted route
    .Adapted Departure Route Identifier: The identifier used to internally
    identify the
    Adapted Departure Route (ADR).
    Route (AAR) to be provided to the controller at the time the auto-route is
    applied.
    .Adapted Departure Arrival Route Clearance Support Alphanumerics: This
    field contains
    the route string with an Adapted Departure Arrival Route (ADAR) to be
    provided to
    the controller at the time the auto-route is applied.
    .Adapted Arrival Route Clearance Support Alphanumerics: This field contains
    the route
    string with an Adapted Arrival Route (AAR) to be provided to the controller
    at the
    time the auto-route is applied.
    .Adapted Departure Route Clearance Support Alphanumerics: This field
    contains the
    route string with an Adapted Departure Route (ADR) to be provided to the
    controller
    at the time the auto-route is applied.
    .Adapted Departure Arrival Route Identifier: The five character identifier
    is used
    to internally identify an Adapted Departure Arrival Route (ADAR).
    .Adapted Departure Route Identifier: The identifier used to internally
    identify the
    Adapted Departure Route (ADR).
    .Adapted Arrival Route Identifier: The five character identifier used to
    internally
    identify an adapted arrival route."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nasRouteAlphanumeric=None, nasRouteIdentifier=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nasRouteAlphanumeric = _cast(None, nasRouteAlphanumeric)
        self.nasRouteAlphanumeric_nsprefix_ = None
        self.nasRouteIdentifier = _cast(None, nasRouteIdentifier)
        self.nasRouteIdentifier_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasAdaptedRouteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasAdaptedRouteType.subclass:
            return NasAdaptedRouteType.subclass(*args_, **kwargs_)
        else:
            return NasAdaptedRouteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nasRouteAlphanumeric(self):
        return self.nasRouteAlphanumeric
    def set_nasRouteAlphanumeric(self, nasRouteAlphanumeric):
        self.nasRouteAlphanumeric = nasRouteAlphanumeric
    def get_nasRouteIdentifier(self):
        return self.nasRouteIdentifier
    def set_nasRouteIdentifier(self, nasRouteIdentifier):
        self.nasRouteIdentifier = nasRouteIdentifier
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasAdaptedRouteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasAdaptedRouteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasAdaptedRouteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasAdaptedRouteType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasAdaptedRouteType'):
        if self.nasRouteAlphanumeric is not None and 'nasRouteAlphanumeric' not in already_processed:
            already_processed.add('nasRouteAlphanumeric')
            outfile.write(' nasRouteAlphanumeric=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nasRouteAlphanumeric), input_name='nasRouteAlphanumeric')), ))
        if self.nasRouteIdentifier is not None and 'nasRouteIdentifier' not in already_processed:
            already_processed.add('nasRouteIdentifier')
            outfile.write(' nasRouteIdentifier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nasRouteIdentifier), input_name='nasRouteIdentifier')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasAdaptedRouteType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nasRouteAlphanumeric', node)
        if value is not None and 'nasRouteAlphanumeric' not in already_processed:
            already_processed.add('nasRouteAlphanumeric')
            self.nasRouteAlphanumeric = value
            self.validate_FreeTextType(self.nasRouteAlphanumeric)    # validate type FreeTextType
        value = find_attr_value_('nasRouteIdentifier', node)
        if value is not None and 'nasRouteIdentifier' not in already_processed:
            already_processed.add('nasRouteIdentifier')
            self.nasRouteIdentifier = value
            self.validate_FreeTextType(self.nasRouteIdentifier)    # validate type FreeTextType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NasAdaptedRouteType


class NasExpandedRouteType(ExpandedRouteType):
    """Extends Expanded Route with a Route Impact List
    .Route Impact List: Current traffic flow management prediction of en route
    Air Traffic
    Control units (centres), sectors and airspace elements along the trajectory
    of a
    flight."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ExpandedRouteType
    def __init__(self, routePoint=None, routeImpactList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasExpandedRouteType, self).__init__(routePoint,  **kwargs_)
        self.routeImpactList = routeImpactList
        self.routeImpactList_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasExpandedRouteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasExpandedRouteType.subclass:
            return NasExpandedRouteType.subclass(*args_, **kwargs_)
        else:
            return NasExpandedRouteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_routeImpactList(self):
        return self.routeImpactList
    def set_routeImpactList(self, routeImpactList):
        self.routeImpactList = routeImpactList
    def hasContent_(self):
        if (
            self.routeImpactList is not None or
            super(NasExpandedRouteType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasExpandedRouteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasExpandedRouteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasExpandedRouteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasExpandedRouteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasExpandedRouteType'):
        super(NasExpandedRouteType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasExpandedRouteType')
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasExpandedRouteType', fromsubclass_=False, pretty_print=True):
        super(NasExpandedRouteType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routeImpactList is not None:
            namespaceprefix_ = self.routeImpactList_nsprefix_ + ':' if (UseCapturedNS_ and self.routeImpactList_nsprefix_) else ''
            self.routeImpactList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='routeImpactList', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NasExpandedRouteType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'routeImpactList':
            obj_ = RouteImpactListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.routeImpactList = obj_
            obj_.original_tagname_ = 'routeImpactList'
        super(NasExpandedRouteType, self).buildChildren(child_, node, nodeName_, True)
# end class NasExpandedRouteType


class NasRouteType(RouteType):
    """Extends the core route type to replace ICAO fields with equivalent NAS-
    specific elements.
    .NAS Route: This element is the filed route. It only includes acknowledged
    auto routes.
    Once the flight is active, this element shows the currently cleared route
    the airplane
    will fly from the departure airport to the arrival airport.
    .ATC Intended Route: The current cleared flight plan route with any
    unacknowledged
    auto routes (preferential routes, transition fixes and A-line fixes)
    already applied.
    .Local Intended Route: The flight plan route that is coordinated to
    penetrated facilities.
    It consists of the filed route (CMS field 10a) merged with any expected-to-
    be-applied-by-the-controlling-center
    Adapted Departure Routes (ADRs), Adapted Departure Arrival Routes (ADARs)
    or Adapted
    Arrival Routes (AARs) applied.
    .Flight Plan Route: This element is the filed route. It only includes
    acknowledged
    auto routes. Once the flight is active, this element shows the currently
    cleared
    route the airplane will fly from the departure airport to the arrival
    airport."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RouteType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, airfileRouteStartTime=None, flightDuration=None, initialFlightRules=None, routeText=None, climbSchedule=None, descentSchedule=None, estimatedElapsedTime=None, expandedRoute=None, initialCruisingSpeed=None, requestedAltitude=None, segment=None, atcIntendedRoute=None, localIntendedRoute=None, nasRouteText=None, adaptedArrivalDepartureRoute=None, adaptedDepartureRoute=None, holdFix=None, nasadaptedArrivalRoute=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasRouteType, self).__init__(centre, source, system, timestamp, airfileRouteStartTime, flightDuration, initialFlightRules, routeText, climbSchedule, descentSchedule, estimatedElapsedTime, expandedRoute, initialCruisingSpeed, requestedAltitude, segment,  **kwargs_)
        self.atcIntendedRoute = _cast(None, atcIntendedRoute)
        self.atcIntendedRoute_nsprefix_ = None
        self.localIntendedRoute = _cast(None, localIntendedRoute)
        self.localIntendedRoute_nsprefix_ = None
        self.nasRouteText = _cast(None, nasRouteText)
        self.nasRouteText_nsprefix_ = None
        self.adaptedArrivalDepartureRoute = adaptedArrivalDepartureRoute
        self.adaptedArrivalDepartureRoute_nsprefix_ = None
        self.adaptedDepartureRoute = adaptedDepartureRoute
        self.adaptedDepartureRoute_nsprefix_ = None
        self.holdFix = holdFix
        self.holdFix_nsprefix_ = None
        self.nasadaptedArrivalRoute = nasadaptedArrivalRoute
        self.nasadaptedArrivalRoute_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasRouteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasRouteType.subclass:
            return NasRouteType.subclass(*args_, **kwargs_)
        else:
            return NasRouteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_adaptedArrivalDepartureRoute(self):
        return self.adaptedArrivalDepartureRoute
    def set_adaptedArrivalDepartureRoute(self, adaptedArrivalDepartureRoute):
        self.adaptedArrivalDepartureRoute = adaptedArrivalDepartureRoute
    def get_adaptedDepartureRoute(self):
        return self.adaptedDepartureRoute
    def set_adaptedDepartureRoute(self, adaptedDepartureRoute):
        self.adaptedDepartureRoute = adaptedDepartureRoute
    def get_holdFix(self):
        return self.holdFix
    def set_holdFix(self, holdFix):
        self.holdFix = holdFix
    def set_holdFix_with_type(self, value):
        self.holdFix = value
        value.original_tagname_ = 'holdFix'
        value.extensiontype_ = value.__class__.__name__
    def get_nasadaptedArrivalRoute(self):
        return self.nasadaptedArrivalRoute
    def set_nasadaptedArrivalRoute(self, nasadaptedArrivalRoute):
        self.nasadaptedArrivalRoute = nasadaptedArrivalRoute
    def get_atcIntendedRoute(self):
        return self.atcIntendedRoute
    def set_atcIntendedRoute(self, atcIntendedRoute):
        self.atcIntendedRoute = atcIntendedRoute
    def get_localIntendedRoute(self):
        return self.localIntendedRoute
    def set_localIntendedRoute(self, localIntendedRoute):
        self.localIntendedRoute = localIntendedRoute
    def get_nasRouteText(self):
        return self.nasRouteText
    def set_nasRouteText(self, nasRouteText):
        self.nasRouteText = nasRouteText
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.adaptedArrivalDepartureRoute is not None or
            self.adaptedDepartureRoute is not None or
            self.holdFix is not None or
            self.nasadaptedArrivalRoute is not None or
            super(NasRouteType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='NasRouteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasRouteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasRouteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasRouteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasRouteType'):
        super(NasRouteType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasRouteType')
        if self.atcIntendedRoute is not None and 'atcIntendedRoute' not in already_processed:
            already_processed.add('atcIntendedRoute')
            outfile.write(' atcIntendedRoute=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.atcIntendedRoute), input_name='atcIntendedRoute')), ))
        if self.localIntendedRoute is not None and 'localIntendedRoute' not in already_processed:
            already_processed.add('localIntendedRoute')
            outfile.write(' localIntendedRoute=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.localIntendedRoute), input_name='localIntendedRoute')), ))
        if self.nasRouteText is not None and 'nasRouteText' not in already_processed:
            already_processed.add('nasRouteText')
            outfile.write(' nasRouteText=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nasRouteText), input_name='nasRouteText')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0"  xmlns:fb="http://www.fixm.aero/base/3.0" ', name_='NasRouteType', fromsubclass_=False, pretty_print=True):
        super(NasRouteType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.adaptedArrivalDepartureRoute is not None:
            namespaceprefix_ = self.adaptedArrivalDepartureRoute_nsprefix_ + ':' if (UseCapturedNS_ and self.adaptedArrivalDepartureRoute_nsprefix_) else ''
            self.adaptedArrivalDepartureRoute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='adaptedArrivalDepartureRoute', pretty_print=pretty_print)
        if self.adaptedDepartureRoute is not None:
            namespaceprefix_ = self.adaptedDepartureRoute_nsprefix_ + ':' if (UseCapturedNS_ and self.adaptedDepartureRoute_nsprefix_) else ''
            self.adaptedDepartureRoute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='adaptedDepartureRoute', pretty_print=pretty_print)
        if self.holdFix is not None:
            self.holdFix.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.nasadaptedArrivalRoute is not None:
            namespaceprefix_ = self.nasadaptedArrivalRoute_nsprefix_ + ':' if (UseCapturedNS_ and self.nasadaptedArrivalRoute_nsprefix_) else ''
            self.nasadaptedArrivalRoute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nasadaptedArrivalRoute', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('atcIntendedRoute', node)
        if value is not None and 'atcIntendedRoute' not in already_processed:
            already_processed.add('atcIntendedRoute')
            self.atcIntendedRoute = value
            self.validate_FreeTextType(self.atcIntendedRoute)    # validate type FreeTextType
        value = find_attr_value_('localIntendedRoute', node)
        if value is not None and 'localIntendedRoute' not in already_processed:
            already_processed.add('localIntendedRoute')
            self.localIntendedRoute = value
            self.validate_FreeTextType(self.localIntendedRoute)    # validate type FreeTextType
        value = find_attr_value_('nasRouteText', node)
        if value is not None and 'nasRouteText' not in already_processed:
            already_processed.add('nasRouteText')
            self.nasRouteText = value
            self.validate_FreeTextType(self.nasRouteText)    # validate type FreeTextType
        super(NasRouteType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'adaptedArrivalDepartureRoute':
            class_obj_ = self.get_class_obj_(child_, NasAdaptedRouteType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.adaptedArrivalDepartureRoute = obj_
            obj_.original_tagname_ = 'adaptedArrivalDepartureRoute'
        elif nodeName_ == 'adaptedDepartureRoute':
            class_obj_ = self.get_class_obj_(child_, NasAdaptedRouteType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.adaptedDepartureRoute = obj_
            obj_.original_tagname_ = 'adaptedDepartureRoute'
        elif nodeName_ == 'holdFix':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <holdFix> element')
            self.holdFix = obj_
            obj_.original_tagname_ = 'holdFix'
        elif nodeName_ == 'nasadaptedArrivalRoute':
            obj_ = NasAdaptedArrivalRouteType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nasadaptedArrivalRoute = obj_
            obj_.original_tagname_ = 'nasadaptedArrivalRoute'
        super(NasRouteType, self).buildChildren(child_, node, nodeName_, True)
# end class NasRouteType


class NasRoutePointType(AbstractRoutePointType):
    """Contains NAS Route Point with additional NAS Flight Rules.
    .Flight Rules - NAS: The regulation, or combination of regulations, that
    governs
    all aspects of operations under which the pilot plans to fly in the NAS."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AbstractRoutePointType
    def __init__(self, airTrafficType=None, clearanceLimit=None, delayAtPoint=None, flightRules=None, point=None, nasFlightRules=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasRoutePointType, self).__init__(airTrafficType, clearanceLimit, delayAtPoint, flightRules, point,  **kwargs_)
        self.nasFlightRules = _cast(None, nasFlightRules)
        self.nasFlightRules_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasRoutePointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasRoutePointType.subclass:
            return NasRoutePointType.subclass(*args_, **kwargs_)
        else:
            return NasRoutePointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nasFlightRules(self):
        return self.nasFlightRules
    def set_nasFlightRules(self, nasFlightRules):
        self.nasFlightRules = nasFlightRules
    def validate_NasFlightRulesType(self, value):
        # Validate type nas:NasFlightRulesType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['IFR', 'VFR', 'DVFR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NasFlightRulesType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(NasRoutePointType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasRoutePointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasRoutePointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasRoutePointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasRoutePointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasRoutePointType'):
        super(NasRoutePointType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasRoutePointType')
        if self.nasFlightRules is not None and 'nasFlightRules' not in already_processed:
            already_processed.add('nasFlightRules')
            outfile.write(' nasFlightRules=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nasFlightRules), input_name='nasFlightRules')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasRoutePointType', fromsubclass_=False, pretty_print=True):
        super(NasRoutePointType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nasFlightRules', node)
        if value is not None and 'nasFlightRules' not in already_processed:
            already_processed.add('nasFlightRules')
            self.nasFlightRules = value
            self.validate_NasFlightRulesType(self.nasFlightRules)    # validate type NasFlightRulesType
        super(NasRoutePointType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(NasRoutePointType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NasRoutePointType


class NasRouteSegmentType(RouteSegmentType):
    """Extends the core ICAO flight segment information to add NAS extensions:
    1. planned delay at fix,
    2. number of planned re-entries into the segment,
    3. number of special re-entries into the segment.
    .NAS Route - Reentry for Military Route: An indication that a portion of a
    Military
    Route is to be flown more than once. The element includes an indication of
    which
    adapted portion of the route as well as the number of times the fixes are
    to be flown.
    It is filed in a NAS Route string and associated with a Military Route.
    There can
    be up to two of these per Military Route in the NAS route string.
    Count of the reentry Special route."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RouteSegmentType
    def __init__(self, airway=None, routePoint=None, reEntryCount=None, reEntrySpecial=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasRouteSegmentType, self).__init__(airway, routePoint,  **kwargs_)
        self.reEntryCount = _cast(None, reEntryCount)
        self.reEntryCount_nsprefix_ = None
        self.reEntrySpecial = _cast(None, reEntrySpecial)
        self.reEntrySpecial_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasRouteSegmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasRouteSegmentType.subclass:
            return NasRouteSegmentType.subclass(*args_, **kwargs_)
        else:
            return NasRouteSegmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reEntryCount(self):
        return self.reEntryCount
    def set_reEntryCount(self, reEntryCount):
        self.reEntryCount = reEntryCount
    def get_reEntrySpecial(self):
        return self.reEntrySpecial
    def set_reEntrySpecial(self, reEntrySpecial):
        self.reEntrySpecial = reEntrySpecial
    def validate_CountType(self, value):
        # Validate type fb:CountType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on CountType' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(NasRouteSegmentType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasRouteSegmentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasRouteSegmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasRouteSegmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasRouteSegmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasRouteSegmentType'):
        super(NasRouteSegmentType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasRouteSegmentType')
        if self.reEntryCount is not None and 'reEntryCount' not in already_processed:
            already_processed.add('reEntryCount')
            outfile.write(' reEntryCount="%s"' % self.gds_format_integer(self.reEntryCount, input_name='reEntryCount'))
        if self.reEntrySpecial is not None and 'reEntrySpecial' not in already_processed:
            already_processed.add('reEntrySpecial')
            outfile.write(' reEntrySpecial="%s"' % self.gds_format_integer(self.reEntrySpecial, input_name='reEntrySpecial'))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasRouteSegmentType', fromsubclass_=False, pretty_print=True):
        super(NasRouteSegmentType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reEntryCount', node)
        if value is not None and 'reEntryCount' not in already_processed:
            already_processed.add('reEntryCount')
            self.reEntryCount = self.gds_parse_integer(value, node, 'reEntryCount')
            self.validate_CountType(self.reEntryCount)    # validate type CountType
        value = find_attr_value_('reEntrySpecial', node)
        if value is not None and 'reEntrySpecial' not in already_processed:
            already_processed.add('reEntrySpecial')
            self.reEntrySpecial = self.gds_parse_integer(value, node, 'reEntrySpecial')
            self.validate_CountType(self.reEntrySpecial)    # validate type CountType
        super(NasRouteSegmentType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(NasRouteSegmentType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NasRouteSegmentType


class RouteImpactListType(GeneratedsSuper):
    """.Route Impact List: Current traffic flow management prediction of en
    route Air Traffic
    Control units (centres), sectors and airspace elements along the trajectory
    of a
    flight."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, predictedAirway=None, predictedFix=None, predictedSector=None, predictedUnit=None, predictedWaypoint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.predictedAirway = predictedAirway
        self.validate_predictedAirwayType(self.predictedAirway)
        self.predictedAirway_nsprefix_ = None
        if predictedFix is None:
            self.predictedFix = []
        else:
            self.predictedFix = predictedFix
        self.predictedFix_nsprefix_ = None
        if predictedSector is None:
            self.predictedSector = []
        else:
            self.predictedSector = predictedSector
        self.predictedSector_nsprefix_ = None
        if predictedUnit is None:
            self.predictedUnit = []
        else:
            self.predictedUnit = predictedUnit
        self.predictedUnit_nsprefix_ = None
        if predictedWaypoint is None:
            self.predictedWaypoint = []
        else:
            self.predictedWaypoint = predictedWaypoint
        self.predictedWaypoint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RouteImpactListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RouteImpactListType.subclass:
            return RouteImpactListType.subclass(*args_, **kwargs_)
        else:
            return RouteImpactListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_predictedAirway(self):
        return self.predictedAirway
    def set_predictedAirway(self, predictedAirway):
        self.predictedAirway = predictedAirway
    def get_predictedFix(self):
        return self.predictedFix
    def set_predictedFix(self, predictedFix):
        self.predictedFix = predictedFix
    def set_predictedFix_with_type(self, value):
        self.predictedFix = value
        value.original_tagname_ = 'predictedFix'
        value.extensiontype_ = value.__class__.__name__
    def add_predictedFix(self, value):
        self.predictedFix.append(value)
    def add_predictedFix_with_type(self, value):
        self.predictedFix.append(value)
        value.original_tagname_ = 'predictedFix'
        value.extensiontype_ = value.__class__.__name__
    def insert_predictedFix_at(self, index, value):
        self.predictedFix.insert(index, value)
    def replace_predictedFix_at(self, index, value):
        self.predictedFix[index] = value
    def get_predictedSector(self):
        return self.predictedSector
    def set_predictedSector(self, predictedSector):
        self.predictedSector = predictedSector
    def add_predictedSector(self, value):
        self.predictedSector.append(value)
    def insert_predictedSector_at(self, index, value):
        self.predictedSector.insert(index, value)
    def replace_predictedSector_at(self, index, value):
        self.predictedSector[index] = value
    def get_predictedUnit(self):
        return self.predictedUnit
    def set_predictedUnit(self, predictedUnit):
        self.predictedUnit = predictedUnit
    def add_predictedUnit(self, value):
        self.predictedUnit.append(value)
    def insert_predictedUnit_at(self, index, value):
        self.predictedUnit.insert(index, value)
    def replace_predictedUnit_at(self, index, value):
        self.predictedUnit[index] = value
    def get_predictedWaypoint(self):
        return self.predictedWaypoint
    def set_predictedWaypoint(self, predictedWaypoint):
        self.predictedWaypoint = predictedWaypoint
    def set_predictedWaypoint_with_type(self, value):
        self.predictedWaypoint = value
        value.original_tagname_ = 'predictedWaypoint'
        value.extensiontype_ = value.__class__.__name__
    def add_predictedWaypoint(self, value):
        self.predictedWaypoint.append(value)
    def add_predictedWaypoint_with_type(self, value):
        self.predictedWaypoint.append(value)
        value.original_tagname_ = 'predictedWaypoint'
        value.extensiontype_ = value.__class__.__name__
    def insert_predictedWaypoint_at(self, index, value):
        self.predictedWaypoint.insert(index, value)
    def replace_predictedWaypoint_at(self, index, value):
        self.predictedWaypoint[index] = value
    def validate_predictedAirwayType(self, value):
        result = True
        # Validate type predictedAirwayType, a restriction on ff:AtsRouteType.
        pass
        return result
    def hasContent_(self):
        if (
            self.predictedAirway is not None or
            self.predictedFix or
            self.predictedSector or
            self.predictedUnit or
            self.predictedWaypoint
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='RouteImpactListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RouteImpactListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RouteImpactListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RouteImpactListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='RouteImpactListType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:fb="http://www.fixm.aero/base/3.0"  xmlns:ff="http://www.fixm.aero/foundation/3.0"  xmlns:nas="http://www.faa.aero/nas/3.0"', name_='RouteImpactListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.predictedAirway is not None:
            namespaceprefix_ = self.predictedAirway_nsprefix_ + ':' if (UseCapturedNS_ and self.predictedAirway_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spredictedAirway>%s</%spredictedAirway>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(' '.join(self.predictedAirway)), input_name='predictedAirway')), namespaceprefix_ , eol_))
        for predictedFix_ in self.predictedFix:
            predictedFix_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        for predictedSector_ in self.predictedSector:
            namespaceprefix_ = self.predictedSector_nsprefix_ + ':' if (UseCapturedNS_ and self.predictedSector_nsprefix_) else ''
            predictedSector_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='predictedSector', pretty_print=pretty_print)
        for predictedUnit_ in self.predictedUnit:
            namespaceprefix_ = self.predictedUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.predictedUnit_nsprefix_) else ''
            predictedUnit_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='predictedUnit', pretty_print=pretty_print)
        for predictedWaypoint_ in self.predictedWaypoint:
            predictedWaypoint_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'predictedAirway':
            value_ = child_.text
            self.predictedAirway = value_
            self.predictedAirway_nsprefix_ = child_.prefix
            # validate type predictedAirwayType
            self.validate_predictedAirwayType(self.predictedAirway)
        elif nodeName_ == 'predictedFix':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <predictedFix> element')
            self.predictedFix.append(obj_)
            obj_.original_tagname_ = 'predictedFix'
        elif nodeName_ == 'predictedSector':
            obj_ = UnitSectorAirspaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.predictedSector.append(obj_)
            obj_.original_tagname_ = 'predictedSector'
        elif nodeName_ == 'predictedUnit':
            obj_ = UnitSectorAirspaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.predictedUnit.append(obj_)
            obj_.original_tagname_ = 'predictedUnit'
        elif nodeName_ == 'predictedWaypoint':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <predictedWaypoint> element')
            self.predictedWaypoint.append(obj_)
            obj_.original_tagname_ = 'predictedWaypoint'
# end class RouteImpactListType


class NasFlightStatusType(FlightStatusType):
    """Extends core: Flight Status: Identifies the aspect of the flight life
    cycle. this
    allows for NAS specific handling.
    Represents the current status of the flight as specified by the SWIM SFDPS.
    .SFDPS Flight Status: Identification of the current aspect of the flight
    life cycle
    as determined by the SWIM Flight Data Publication Service (SFDPS).
    .Traffic Flow Management System Flight Status: Indicates the current status
    of the
    flight, as determined by Traffic Flow Management System (TFMS)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FlightStatusType
    def __init__(self, centre=None, source=None, system=None, timestamp=None, accepted=None, airborneHold=None, airfile=None, flightCycle=None, missedApproach=None, suspended=None, fdpsFlightStatus=None, tfmsStatus=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasFlightStatusType, self).__init__(centre, source, system, timestamp, accepted, airborneHold, airfile, flightCycle, missedApproach, suspended,  **kwargs_)
        self.fdpsFlightStatus = _cast(None, fdpsFlightStatus)
        self.fdpsFlightStatus_nsprefix_ = None
        self.tfmsStatus = _cast(None, tfmsStatus)
        self.tfmsStatus_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasFlightStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasFlightStatusType.subclass:
            return NasFlightStatusType.subclass(*args_, **kwargs_)
        else:
            return NasFlightStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fdpsFlightStatus(self):
        return self.fdpsFlightStatus
    def set_fdpsFlightStatus(self, fdpsFlightStatus):
        self.fdpsFlightStatus = fdpsFlightStatus
    def get_tfmsStatus(self):
        return self.tfmsStatus
    def set_tfmsStatus(self, tfmsStatus):
        self.tfmsStatus = tfmsStatus
    def validate_SfdpsFlightStatusType(self, value):
        # Validate type nas:SfdpsFlightStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PROPOSED', 'ACTIVE', 'COMPLETED', 'CANCELLED', 'DROPPED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SfdpsFlightStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_TfmsFlightStatusType(self, value):
        # Validate type nas:TfmsFlightStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SCHEDULED', 'CONTROLLED', 'FILED', 'ACTIVE', 'ASCENDING', 'CRUISING', 'DESCENDING', 'COMPLETED', 'CANCELLED', 'DECONTROLLED', 'UNKNOWN', 'NONE', 'ERROR', 'OTHER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TfmsFlightStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(NasFlightStatusType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasFlightStatusType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasFlightStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasFlightStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasFlightStatusType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasFlightStatusType'):
        super(NasFlightStatusType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasFlightStatusType')
        if self.fdpsFlightStatus is not None and 'fdpsFlightStatus' not in already_processed:
            already_processed.add('fdpsFlightStatus')
            outfile.write(' fdpsFlightStatus=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fdpsFlightStatus), input_name='fdpsFlightStatus')), ))
        if self.tfmsStatus is not None and 'tfmsStatus' not in already_processed:
            already_processed.add('tfmsStatus')
            outfile.write(' tfmsStatus=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tfmsStatus), input_name='tfmsStatus')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasFlightStatusType', fromsubclass_=False, pretty_print=True):
        super(NasFlightStatusType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fdpsFlightStatus', node)
        if value is not None and 'fdpsFlightStatus' not in already_processed:
            already_processed.add('fdpsFlightStatus')
            self.fdpsFlightStatus = value
            self.validate_SfdpsFlightStatusType(self.fdpsFlightStatus)    # validate type SfdpsFlightStatusType
        value = find_attr_value_('tfmsStatus', node)
        if value is not None and 'tfmsStatus' not in already_processed:
            already_processed.add('tfmsStatus')
            self.tfmsStatus = value
            self.validate_TfmsFlightStatusType(self.tfmsStatus)    # validate type TfmsFlightStatusType
        super(NasFlightStatusType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(NasFlightStatusType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NasFlightStatusType


class ConstrainedAirspaceEntryType(GeneratedsSuper):
    """Container for NAS Trajectory Option Constraints.
    .Airspace Entry Time - Earliest: The earliest time the flight could enter
    the constrained
    airspace.
    Contains:
    .Airspace Identifier: Unique Identifier for the constrained airspace to be
    traversed
    by the trajectory option.
    .Trajectory Airspace Impact: Container for the list of constrained airspace
    areas
    to be traversed by the trajectory option."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, earliestAirspaceEntryTime=None, impactFca=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.earliestAirspaceEntryTime = _cast(None, earliestAirspaceEntryTime)
        self.earliestAirspaceEntryTime_nsprefix_ = None
        self.impactFca = _cast(None, impactFca)
        self.impactFca_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConstrainedAirspaceEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConstrainedAirspaceEntryType.subclass:
            return ConstrainedAirspaceEntryType.subclass(*args_, **kwargs_)
        else:
            return ConstrainedAirspaceEntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_earliestAirspaceEntryTime(self):
        return self.earliestAirspaceEntryTime
    def set_earliestAirspaceEntryTime(self, earliestAirspaceEntryTime):
        self.earliestAirspaceEntryTime = earliestAirspaceEntryTime
    def get_impactFca(self):
        return self.impactFca
    def set_impactFca(self, impactFca):
        self.impactFca = impactFca
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_ConstrainedAirspaceType(self, value):
        # Validate type fb:ConstrainedAirspaceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='ConstrainedAirspaceEntryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConstrainedAirspaceEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConstrainedAirspaceEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConstrainedAirspaceEntryType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='ConstrainedAirspaceEntryType'):
        if self.earliestAirspaceEntryTime is not None and 'earliestAirspaceEntryTime' not in already_processed:
            already_processed.add('earliestAirspaceEntryTime')
            outfile.write(' earliestAirspaceEntryTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.earliestAirspaceEntryTime), input_name='earliestAirspaceEntryTime')), ))
        if self.impactFca is not None and 'impactFca' not in already_processed:
            already_processed.add('impactFca')
            outfile.write(' impactFca=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.impactFca), input_name='impactFca')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='ConstrainedAirspaceEntryType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('earliestAirspaceEntryTime', node)
        if value is not None and 'earliestAirspaceEntryTime' not in already_processed:
            already_processed.add('earliestAirspaceEntryTime')
            try:
                self.earliestAirspaceEntryTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (earliestAirspaceEntryTime): %s' % exp)
            self.validate_TimeType(self.earliestAirspaceEntryTime)    # validate type TimeType
        value = find_attr_value_('impactFca', node)
        if value is not None and 'impactFca' not in already_processed:
            already_processed.add('impactFca')
            self.impactFca = value
            self.validate_ConstrainedAirspaceType(self.impactFca)    # validate type ConstrainedAirspaceType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ConstrainedAirspaceEntryType


class NasTrajectoryOptionType(RankedTrajectoryType):
    """.Traffic Flow Management Collaborative Trajectory Options Program
    Information: A
    container for a Traffic Flow Management Collaborative Trajectory Options
    Program
    pertinent information for a flight.
    .Trajectory Option Set: A container for information pertinent to a single
    trajectory
    option for a flight.
    .Collaborative Trajectory Options Program Name: The name for the
    Collaborative Trajectory
    Options Program as defined by the traffic manager.
    .Collaborative Trajectory Options Program Identifier: The Traffic Flow
    Management
    System generated unique identifier for the Collaborative Trajectory Options
    Program.
    .Collaborative Trajectory Options Program Name: The name for the
    Collaborative Trajectory
    Options Program as defined by the traffic manager.
    .Collaborative Trajectory Options Program Identifier: The Traffic Flow
    Management
    System generated unique identifier for the Collaborative Trajectory Options
    Program.
    .Trajectory Manual Override Status: An indication whether a trajectory was
    either
    selected manually by a traffic manager from the available trajectory
    options or was
    entered manually by a traffic manager.
    .Trajectory Minimum Notification Time: The minimum notification time,
    relative to
    off block departure time, the airspace user needs for a trajectory option
    to be assigned.
    .Trajectory Relative Cost: The relative cost of the trajectory option as
    compared
    to another trajectory option.
    .Trajectory Total Cost: The total cost the flight would incur if this were
    the assigned
    trajectory option. It includes the Trajectory Relative Cost and the Traffic
    Flow
    Management assigned delay for this trajectory option.
    .Trajectory Valid End Time: The latest runway departure time for which this
    trajectory
    can be used by this flight.
    .Trajectory Valid Start Time: The earliest runway departure time for which
    this trajectory
    can be used by this flight."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RankedTrajectoryType
    def __init__(self, assignedIndicator=None, identifier=None, maximumAcceptableDelay=None, routeTrajectoryPair=None, ctopIdentifier=None, ctopName=None, manualOverride=None, minimumNotificationMinutes=None, relativeCost=None, totalCost=None, validEndTime=None, validStartTime=None, constrainedAirspaceEntry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasTrajectoryOptionType, self).__init__(assignedIndicator, identifier, maximumAcceptableDelay, routeTrajectoryPair,  **kwargs_)
        self.ctopIdentifier = _cast(None, ctopIdentifier)
        self.ctopIdentifier_nsprefix_ = None
        self.ctopName = _cast(None, ctopName)
        self.ctopName_nsprefix_ = None
        self.manualOverride = _cast(None, manualOverride)
        self.manualOverride_nsprefix_ = None
        self.minimumNotificationMinutes = _cast(None, minimumNotificationMinutes)
        self.minimumNotificationMinutes_nsprefix_ = None
        self.relativeCost = _cast(None, relativeCost)
        self.relativeCost_nsprefix_ = None
        self.totalCost = _cast(None, totalCost)
        self.totalCost_nsprefix_ = None
        self.validEndTime = _cast(None, validEndTime)
        self.validEndTime_nsprefix_ = None
        self.validStartTime = _cast(None, validStartTime)
        self.validStartTime_nsprefix_ = None
        if constrainedAirspaceEntry is None:
            self.constrainedAirspaceEntry = []
        else:
            self.constrainedAirspaceEntry = constrainedAirspaceEntry
        self.constrainedAirspaceEntry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasTrajectoryOptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasTrajectoryOptionType.subclass:
            return NasTrajectoryOptionType.subclass(*args_, **kwargs_)
        else:
            return NasTrajectoryOptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_constrainedAirspaceEntry(self):
        return self.constrainedAirspaceEntry
    def set_constrainedAirspaceEntry(self, constrainedAirspaceEntry):
        self.constrainedAirspaceEntry = constrainedAirspaceEntry
    def add_constrainedAirspaceEntry(self, value):
        self.constrainedAirspaceEntry.append(value)
    def insert_constrainedAirspaceEntry_at(self, index, value):
        self.constrainedAirspaceEntry.insert(index, value)
    def replace_constrainedAirspaceEntry_at(self, index, value):
        self.constrainedAirspaceEntry[index] = value
    def get_ctopIdentifier(self):
        return self.ctopIdentifier
    def set_ctopIdentifier(self, ctopIdentifier):
        self.ctopIdentifier = ctopIdentifier
    def get_ctopName(self):
        return self.ctopName
    def set_ctopName(self, ctopName):
        self.ctopName = ctopName
    def get_manualOverride(self):
        return self.manualOverride
    def set_manualOverride(self, manualOverride):
        self.manualOverride = manualOverride
    def get_minimumNotificationMinutes(self):
        return self.minimumNotificationMinutes
    def set_minimumNotificationMinutes(self, minimumNotificationMinutes):
        self.minimumNotificationMinutes = minimumNotificationMinutes
    def get_relativeCost(self):
        return self.relativeCost
    def set_relativeCost(self, relativeCost):
        self.relativeCost = relativeCost
    def get_totalCost(self):
        return self.totalCost
    def set_totalCost(self, totalCost):
        self.totalCost = totalCost
    def get_validEndTime(self):
        return self.validEndTime
    def set_validEndTime(self, validEndTime):
        self.validEndTime = validEndTime
    def get_validStartTime(self):
        return self.validStartTime
    def set_validStartTime(self, validStartTime):
        self.validStartTime = validStartTime
    def validate_FreeTextType(self, value):
        # Validate type fb:FreeTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeTextType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ManualOverrideIndicatorType(self, value):
        # Validate type nas:ManualOverrideIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MANUAL_OVERRRIDE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ManualOverrideIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_CountType(self, value):
        # Validate type fb:CountType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on CountType' % {"value": value, "lineno": lineno} )
                result = False
    def validate_TimeType(self, value):
        # Validate type ff:TimeType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.constrainedAirspaceEntry or
            super(NasTrajectoryOptionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasTrajectoryOptionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasTrajectoryOptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasTrajectoryOptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasTrajectoryOptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasTrajectoryOptionType'):
        super(NasTrajectoryOptionType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasTrajectoryOptionType')
        if self.ctopIdentifier is not None and 'ctopIdentifier' not in already_processed:
            already_processed.add('ctopIdentifier')
            outfile.write(' ctopIdentifier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ctopIdentifier), input_name='ctopIdentifier')), ))
        if self.ctopName is not None and 'ctopName' not in already_processed:
            already_processed.add('ctopName')
            outfile.write(' ctopName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ctopName), input_name='ctopName')), ))
        if self.manualOverride is not None and 'manualOverride' not in already_processed:
            already_processed.add('manualOverride')
            outfile.write(' manualOverride=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.manualOverride), input_name='manualOverride')), ))
        if self.minimumNotificationMinutes is not None and 'minimumNotificationMinutes' not in already_processed:
            already_processed.add('minimumNotificationMinutes')
            outfile.write(' minimumNotificationMinutes="%s"' % self.gds_format_integer(self.minimumNotificationMinutes, input_name='minimumNotificationMinutes'))
        if self.relativeCost is not None and 'relativeCost' not in already_processed:
            already_processed.add('relativeCost')
            outfile.write(' relativeCost="%s"' % self.gds_format_integer(self.relativeCost, input_name='relativeCost'))
        if self.totalCost is not None and 'totalCost' not in already_processed:
            already_processed.add('totalCost')
            outfile.write(' totalCost="%s"' % self.gds_format_integer(self.totalCost, input_name='totalCost'))
        if self.validEndTime is not None and 'validEndTime' not in already_processed:
            already_processed.add('validEndTime')
            outfile.write(' validEndTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.validEndTime), input_name='validEndTime')), ))
        if self.validStartTime is not None and 'validStartTime' not in already_processed:
            already_processed.add('validStartTime')
            outfile.write(' validStartTime=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.validStartTime), input_name='validStartTime')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_=' xmlns:nas="http://www.faa.aero/nas/3.0" ', name_='NasTrajectoryOptionType', fromsubclass_=False, pretty_print=True):
        super(NasTrajectoryOptionType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for constrainedAirspaceEntry_ in self.constrainedAirspaceEntry:
            namespaceprefix_ = self.constrainedAirspaceEntry_nsprefix_ + ':' if (UseCapturedNS_ and self.constrainedAirspaceEntry_nsprefix_) else ''
            constrainedAirspaceEntry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='constrainedAirspaceEntry', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ctopIdentifier', node)
        if value is not None and 'ctopIdentifier' not in already_processed:
            already_processed.add('ctopIdentifier')
            self.ctopIdentifier = value
            self.validate_FreeTextType(self.ctopIdentifier)    # validate type FreeTextType
        value = find_attr_value_('ctopName', node)
        if value is not None and 'ctopName' not in already_processed:
            already_processed.add('ctopName')
            self.ctopName = value
            self.validate_FreeTextType(self.ctopName)    # validate type FreeTextType
        value = find_attr_value_('manualOverride', node)
        if value is not None and 'manualOverride' not in already_processed:
            already_processed.add('manualOverride')
            self.manualOverride = value
            self.validate_ManualOverrideIndicatorType(self.manualOverride)    # validate type ManualOverrideIndicatorType
        value = find_attr_value_('minimumNotificationMinutes', node)
        if value is not None and 'minimumNotificationMinutes' not in already_processed:
            already_processed.add('minimumNotificationMinutes')
            self.minimumNotificationMinutes = self.gds_parse_integer(value, node, 'minimumNotificationMinutes')
            self.validate_CountType(self.minimumNotificationMinutes)    # validate type CountType
        value = find_attr_value_('relativeCost', node)
        if value is not None and 'relativeCost' not in already_processed:
            already_processed.add('relativeCost')
            self.relativeCost = self.gds_parse_integer(value, node, 'relativeCost')
            self.validate_CountType(self.relativeCost)    # validate type CountType
        value = find_attr_value_('totalCost', node)
        if value is not None and 'totalCost' not in already_processed:
            already_processed.add('totalCost')
            self.totalCost = self.gds_parse_integer(value, node, 'totalCost')
            self.validate_CountType(self.totalCost)    # validate type CountType
        value = find_attr_value_('validEndTime', node)
        if value is not None and 'validEndTime' not in already_processed:
            already_processed.add('validEndTime')
            try:
                self.validEndTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (validEndTime): %s' % exp)
            self.validate_TimeType(self.validEndTime)    # validate type TimeType
        value = find_attr_value_('validStartTime', node)
        if value is not None and 'validStartTime' not in already_processed:
            already_processed.add('validStartTime')
            try:
                self.validStartTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (validStartTime): %s' % exp)
            self.validate_TimeType(self.validStartTime)    # validate type TimeType
        super(NasTrajectoryOptionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'constrainedAirspaceEntry':
            obj_ = ConstrainedAirspaceEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.constrainedAirspaceEntry.append(obj_)
            obj_.original_tagname_ = 'constrainedAirspaceEntry'
        super(NasTrajectoryOptionType, self).buildChildren(child_, node, nodeName_, True)
# end class NasTrajectoryOptionType


class NasAdaptedArrivalRouteType(NasAdaptedRouteType):
    """Adapted Route Extension for Adapted Arrival Route
    .Fixed Airspace Volume Number Containing First Adapted Arrival Route Fix:
    Contains
    the uncombined Fixed Airspace Volume (FAV) number containing the first
    Adapted Arrival
    Route (AAR) fix."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NasAdaptedRouteType
    def __init__(self, nasRouteAlphanumeric=None, nasRouteIdentifier=None, nasFavNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NasAdaptedArrivalRouteType, self).__init__(nasRouteAlphanumeric, nasRouteIdentifier,  **kwargs_)
        self.nasFavNumber = nasFavNumber
        self.validate_nasFavNumberType(self.nasFavNumber)
        self.nasFavNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NasAdaptedArrivalRouteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NasAdaptedArrivalRouteType.subclass:
            return NasAdaptedArrivalRouteType.subclass(*args_, **kwargs_)
        else:
            return NasAdaptedArrivalRouteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nasFavNumber(self):
        return self.nasFavNumber
    def set_nasFavNumber(self, nasFavNumber):
        self.nasFavNumber = nasFavNumber
    def validate_nasFavNumberType(self, value):
        result = True
        # Validate type nasFavNumberType, a restriction on fb:FreeTextType.
        pass
        return result
    def hasContent_(self):
        if (
            self.nasFavNumber is not None or
            super(NasAdaptedArrivalRouteType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasAdaptedArrivalRouteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NasAdaptedArrivalRouteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasAdaptedArrivalRouteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NasAdaptedArrivalRouteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='nas:', name_='NasAdaptedArrivalRouteType'):
        super(NasAdaptedArrivalRouteType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NasAdaptedArrivalRouteType')
    def exportChildren(self, outfile, level, namespaceprefix_='nas:', namespacedef_='', name_='NasAdaptedArrivalRouteType', fromsubclass_=False, pretty_print=True):
        super(NasAdaptedArrivalRouteType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nasFavNumber is not None:
            namespaceprefix_ = self.nasFavNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.nasFavNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snasFavNumber>%s</%snasFavNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(' '.join(self.nasFavNumber)), input_name='nasFavNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NasAdaptedArrivalRouteType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nasFavNumber':
            value_ = child_.text
            self.nasFavNumber = value_
            self.nasFavNumber_nsprefix_ = child_.prefix
            # validate type nasFavNumberType
            self.validate_nasFavNumberType(self.nasFavNumber)
        super(NasAdaptedArrivalRouteType, self).buildChildren(child_, node, nodeName_, True)
# end class NasAdaptedArrivalRouteType


class LevelConstraintType(RouteConstraintOrPreferenceType):
    """.Route-Change Speed and Altitude: The planned speed and altitude the
    aircraft will
    change to either prior to, or after reaching, the associated Significant
    Point along
    its Route.
    .Change Speed and Altitude: The planned speed and altitude that the
    aircraft will
    change to upon reaching the associated Significant Point along its Route.
    Qualifies the position associated with the level constraint."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RouteConstraintOrPreferenceType
    def __init__(self, constraintType=None, positionQualification=None, level=None, timeConstraint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LevelConstraintType, self).__init__(constraintType,  **kwargs_)
        self.positionQualification = _cast(None, positionQualification)
        self.positionQualification_nsprefix_ = None
        self.level = level
        self.level_nsprefix_ = None
        self.timeConstraint = timeConstraint
        self.timeConstraint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LevelConstraintType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LevelConstraintType.subclass:
            return LevelConstraintType.subclass(*args_, **kwargs_)
        else:
            return LevelConstraintType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_timeConstraint(self):
        return self.timeConstraint
    def set_timeConstraint(self, timeConstraint):
        self.timeConstraint = timeConstraint
    def get_positionQualification(self):
        return self.positionQualification
    def set_positionQualification(self, positionQualification):
        self.positionQualification = positionQualification
    def validate_PositionQualifierType(self, value):
        # Validate type fx:PositionQualifierType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AT_OR_BEFORE_POINT', 'AT_POINT', 'AT_OR_AFTER_POINT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PositionQualifierType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.level is not None or
            self.timeConstraint is not None or
            super(LevelConstraintType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='LevelConstraintType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LevelConstraintType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LevelConstraintType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LevelConstraintType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='LevelConstraintType'):
        super(LevelConstraintType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LevelConstraintType')
        if self.positionQualification is not None and 'positionQualification' not in already_processed:
            already_processed.add('positionQualification')
            outfile.write(' positionQualification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.positionQualification), input_name='positionQualification')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='LevelConstraintType', fromsubclass_=False, pretty_print=True):
        super(LevelConstraintType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.level is not None:
            namespaceprefix_ = self.level_nsprefix_ + ':' if (UseCapturedNS_ and self.level_nsprefix_) else ''
            self.level.export(outfile, level, namespaceprefix_, namespacedef_='', name_='level', pretty_print=pretty_print)
        if self.timeConstraint is not None:
            namespaceprefix_ = self.timeConstraint_nsprefix_ + ':' if (UseCapturedNS_ and self.timeConstraint_nsprefix_) else ''
            self.timeConstraint.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timeConstraint', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('positionQualification', node)
        if value is not None and 'positionQualification' not in already_processed:
            already_processed.add('positionQualification')
            self.positionQualification = value
            self.validate_PositionQualifierType(self.positionQualification)    # validate type PositionQualifierType
        super(LevelConstraintType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'level':
            class_obj_ = self.get_class_obj_(child_, AltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.level = obj_
            obj_.original_tagname_ = 'level'
        elif nodeName_ == 'timeConstraint':
            obj_ = TimeConstraintType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeConstraint = obj_
            obj_.original_tagname_ = 'timeConstraint'
        super(LevelConstraintType, self).buildChildren(child_, node, nodeName_, True)
# end class LevelConstraintType


class ClimbToLevelConstraintType(RouteConstraintOrPreferenceType):
    """.Change Cruise Climb: The parameters of a cruise climb executed at the
    associated
    significant point. It contains the following parameters: 1. the speed to be
    maintained
    during cruise climb; 2. either the minimum and maximum levels defining the
    layer
    to be occupied during cruise climb, or the level above which cruise climb
    is planned.
    .Route-Change Cruise Climb: The parameters of a cruise climb executed at
    the associated
    significant point.
    Specifies that the altitude specified in the ClimbToLevelConstraint is not
    a maximum
    altitude, and aircraft may climb to a higher level."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RouteConstraintOrPreferenceType
    def __init__(self, constraintType=None, altitudeQualification=None, climbToLevel=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ClimbToLevelConstraintType, self).__init__(constraintType,  **kwargs_)
        self.altitudeQualification = _cast(None, altitudeQualification)
        self.altitudeQualification_nsprefix_ = None
        self.climbToLevel = climbToLevel
        self.climbToLevel_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClimbToLevelConstraintType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClimbToLevelConstraintType.subclass:
            return ClimbToLevelConstraintType.subclass(*args_, **kwargs_)
        else:
            return ClimbToLevelConstraintType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_climbToLevel(self):
        return self.climbToLevel
    def set_climbToLevel(self, climbToLevel):
        self.climbToLevel = climbToLevel
    def get_altitudeQualification(self):
        return self.altitudeQualification
    def set_altitudeQualification(self, altitudeQualification):
        self.altitudeQualification = altitudeQualification
    def validate_AltitudeQualifierType(self, value):
        # Validate type fx:AltitudeQualifierType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AT_OR_ABOVE_ALTITUDE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AltitudeQualifierType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.climbToLevel is not None or
            super(ClimbToLevelConstraintType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='ClimbToLevelConstraintType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClimbToLevelConstraintType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClimbToLevelConstraintType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClimbToLevelConstraintType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fx:', name_='ClimbToLevelConstraintType'):
        super(ClimbToLevelConstraintType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClimbToLevelConstraintType')
        if self.altitudeQualification is not None and 'altitudeQualification' not in already_processed:
            already_processed.add('altitudeQualification')
            outfile.write(' altitudeQualification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altitudeQualification), input_name='altitudeQualification')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fx:', namespacedef_='', name_='ClimbToLevelConstraintType', fromsubclass_=False, pretty_print=True):
        super(ClimbToLevelConstraintType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.climbToLevel is not None:
            namespaceprefix_ = self.climbToLevel_nsprefix_ + ':' if (UseCapturedNS_ and self.climbToLevel_nsprefix_) else ''
            self.climbToLevel.export(outfile, level, namespaceprefix_, namespacedef_='', name_='climbToLevel', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('altitudeQualification', node)
        if value is not None and 'altitudeQualification' not in already_processed:
            already_processed.add('altitudeQualification')
            self.altitudeQualification = value
            self.validate_AltitudeQualifierType(self.altitudeQualification)    # validate type AltitudeQualifierType
        super(ClimbToLevelConstraintType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'climbToLevel':
            class_obj_ = self.get_class_obj_(child_, AltitudeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.climbToLevel = obj_
            obj_.original_tagname_ = 'climbToLevel'
        super(ClimbToLevelConstraintType, self).buildChildren(child_, node, nodeName_, True)
# end class ClimbToLevelConstraintType


class ExtendedMultiTimeType(TargetMultiTimeType):
    """ExpandedMultiTime is an extension of TargetMultiTime and hence MultiTime
    that includes
    additional attributes of initial and controlled time for data that requires
    those
    additional time fields."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TargetMultiTimeType
    def __init__(self, actual=None, estimated=None, target=None, controlled=None, initial=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ExtendedMultiTimeType, self).__init__(actual, estimated, target,  **kwargs_)
        self.controlled = controlled
        self.controlled_nsprefix_ = None
        self.initial = initial
        self.initial_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExtendedMultiTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExtendedMultiTimeType.subclass:
            return ExtendedMultiTimeType.subclass(*args_, **kwargs_)
        else:
            return ExtendedMultiTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_controlled(self):
        return self.controlled
    def set_controlled(self, controlled):
        self.controlled = controlled
    def get_initial(self):
        return self.initial
    def set_initial(self, initial):
        self.initial = initial
    def hasContent_(self):
        if (
            self.controlled is not None or
            self.initial is not None or
            super(ExtendedMultiTimeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='ExtendedMultiTimeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExtendedMultiTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExtendedMultiTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExtendedMultiTimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='ExtendedMultiTimeType'):
        super(ExtendedMultiTimeType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExtendedMultiTimeType')
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='ExtendedMultiTimeType', fromsubclass_=False, pretty_print=True):
        super(ExtendedMultiTimeType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.controlled is not None:
            namespaceprefix_ = self.controlled_nsprefix_ + ':' if (UseCapturedNS_ and self.controlled_nsprefix_) else ''
            self.controlled.export(outfile, level, namespaceprefix_, namespacedef_='', name_='controlled', pretty_print=pretty_print)
        if self.initial is not None:
            namespaceprefix_ = self.initial_nsprefix_ + ':' if (UseCapturedNS_ and self.initial_nsprefix_) else ''
            self.initial.export(outfile, level, namespaceprefix_, namespacedef_='', name_='initial', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExtendedMultiTimeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'controlled':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.controlled = obj_
            obj_.original_tagname_ = 'controlled'
        elif nodeName_ == 'initial':
            obj_ = ReportedTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.initial = obj_
            obj_.original_tagname_ = 'initial'
        super(ExtendedMultiTimeType, self).buildChildren(child_, node, nodeName_, True)
# end class ExtendedMultiTimeType


class LocationPointType(SignificantPointType):
    """Significant point described by a geographic location."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SignificantPointType
    def __init__(self, location=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LocationPointType, self).__init__( **kwargs_)
        self.location = location
        self.location_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocationPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocationPointType.subclass:
            return LocationPointType.subclass(*args_, **kwargs_)
        else:
            return LocationPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def hasContent_(self):
        if (
            self.location is not None or
            super(LocationPointType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='LocationPointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocationPointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocationPointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LocationPointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='LocationPointType'):
        super(LocationPointType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocationPointType')
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='LocationPointType', fromsubclass_=False, pretty_print=True):
        super(LocationPointType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.location is not None:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            self.location.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LocationPointType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'location':
            class_obj_ = self.get_class_obj_(child_, GeographicLocationType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
        super(LocationPointType, self).buildChildren(child_, node, nodeName_, True)
# end class LocationPointType


class FixPointType(SignificantPointType):
    """Significant point described by a fix.
    One of three possibilities, "fix" provides the lat/lon of this Significant
    Point."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SignificantPointType
    def __init__(self, fix=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FixPointType, self).__init__(extensiontype_,  **kwargs_)
        self.fix = _cast(None, fix)
        self.fix_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FixPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FixPointType.subclass:
            return FixPointType.subclass(*args_, **kwargs_)
        else:
            return FixPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fix(self):
        return self.fix
    def set_fix(self, fix):
        self.fix = fix
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_FixType(self, value):
        # Validate type ff:FixType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_FixType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_FixType_patterns_, ))
    validate_FixType_patterns_ = [['^([A-Z0-9]{2,5})$']]
    def hasContent_(self):
        if (
            super(FixPointType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='FixPointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FixPointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FixPointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FixPointType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='FixPointType'):
        super(FixPointType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FixPointType')
        if self.fix is not None and 'fix' not in already_processed:
            already_processed.add('fix')
            outfile.write(' fix=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fix), input_name='fix')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='FixPointType', fromsubclass_=False, pretty_print=True):
        super(FixPointType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fix', node)
        if value is not None and 'fix' not in already_processed:
            already_processed.add('fix')
            self.fix = value
            self.validate_FixType(self.fix)    # validate type FixType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(FixPointType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(FixPointType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FixPointType


class DirectionType(AngleType):
    """Represents a compass bearing as an angle in the range [0,360].
    Optional reference to DirectionReference."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AngleType
    def __init__(self, uom=None, ref=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DirectionType, self).__init__(uom, valueOf_,  **kwargs_)
        self.ref = _cast(None, ref)
        self.ref_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DirectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DirectionType.subclass:
            return DirectionType.subclass(*args_, **kwargs_)
        else:
            return DirectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DirectionReferenceType(self, value):
        # Validate type fb:DirectionReferenceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['TRUE', 'MAGNETIC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DirectionReferenceType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DirectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='DirectionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DirectionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DirectionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DirectionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='DirectionType'):
        super(DirectionType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DirectionType')
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='DirectionType', fromsubclass_=False, pretty_print=True):
        super(DirectionType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
            self.validate_DirectionReferenceType(self.ref)    # validate type DirectionReferenceType
        super(DirectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DirectionType


class RelativePointType(FixPointType):
    """Significant point described by a relative (fix radial distance)
    location."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FixPointType
    def __init__(self, fix=None, distance=None, radial=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RelativePointType, self).__init__(fix,  **kwargs_)
        self.distance = distance
        self.distance_nsprefix_ = None
        self.radial = radial
        self.radial_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelativePointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelativePointType.subclass:
            return RelativePointType.subclass(*args_, **kwargs_)
        else:
            return RelativePointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_distance(self):
        return self.distance
    def set_distance(self, distance):
        self.distance = distance
    def get_radial(self):
        return self.radial
    def set_radial(self, radial):
        self.radial = radial
    def hasContent_(self):
        if (
            self.distance is not None or
            self.radial is not None or
            super(RelativePointType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='RelativePointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RelativePointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RelativePointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RelativePointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='fb:', name_='RelativePointType'):
        super(RelativePointType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RelativePointType')
    def exportChildren(self, outfile, level, namespaceprefix_='fb:', namespacedef_='', name_='RelativePointType', fromsubclass_=False, pretty_print=True):
        super(RelativePointType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.distance is not None:
            namespaceprefix_ = self.distance_nsprefix_ + ':' if (UseCapturedNS_ and self.distance_nsprefix_) else ''
            self.distance.export(outfile, level, namespaceprefix_, namespacedef_='', name_='distance', pretty_print=pretty_print)
        if self.radial is not None:
            namespaceprefix_ = self.radial_nsprefix_ + ':' if (UseCapturedNS_ and self.radial_nsprefix_) else ''
            self.radial.export(outfile, level, namespaceprefix_, namespacedef_='', name_='radial', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RelativePointType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'distance':
            class_obj_ = self.get_class_obj_(child_, DistanceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.distance = obj_
            obj_.original_tagname_ = 'distance'
        elif nodeName_ == 'radial':
            obj_ = DirectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.radial = obj_
            obj_.original_tagname_ = 'radial'
        super(RelativePointType, self).buildChildren(child_, node, nodeName_, True)
# end class RelativePointType


GDSClassesMapping = {
    'AbstractMessage': AbstractMessageType,
    'AbstractRoutePoint': AbstractRoutePointType,
    'ActualSpeed': ActualSpeedType,
    'AdditionalHandlingInformation': AdditionalHandlingInformationType,
    'AerodromeReference': AerodromeReferenceType,
    'Aircraft': AircraftType,
    'AircraftCapabilities': AircraftCapabilitiesType,
    'AircraftOperator': AircraftOperatorType,
    'AircraftPosition': AircraftPositionType,
    'AircraftType': AircraftTypeType,
    'AirspaceAcceptableSlotSubstitution': AirspaceAcceptableSlotSubstitutionType,
    'AirspaceConstraint': AirspaceConstraintType,
    'AirspaceEntryTime': AirspaceEntryTimeType,
    'AirspaceExitTime': AirspaceExitTimeType,
    'AirspeedChoice': AirspeedChoiceType,
    'AirspeedRange': AirspeedRangeType,
    'AllPackedInOne': AllPackedInOneType,
    'AltFixAltAltitude': AltFixAltAltitudeType,
    'AltitudeChoice': AltitudeChoiceType,
    'ArrivalMovementAreaHoldInformation': ArrivalMovementAreaHoldInformationType,
    'AtcUnitReference': AtcUnitReferenceType,
    'BeaconCodeAssignment': BeaconCodeAssignmentType,
    'BlockAltitude': BlockAltitudeType,
    'BoundaryCrossing': BoundaryCrossingType,
    'ClearedFlightInformation': ClearedFlightInformationType,
    'ClimbToLevelConstraint': ClimbToLevelConstraintType,
    'CommunicationCapabilities': CommunicationCapabilitiesType,
    'ConstrainedAirspaceEntry': ConstrainedAirspaceEntryType,
    'ContactInformation': ContactInformationType,
    'ControlElement': ControlElementType,
    'CoordinationStatus': CoordinationStatusType,
    'CpdlcConnection': CpdlcConnectionType,
    'DangerousGoods': DangerousGoodsType,
    'DangerousGoodsDimensions': DangerousGoodsDimensionsType,
    'DangerousGoodsPackage': DangerousGoodsPackageType,
    'DangerousGoodsPackageGroup': DangerousGoodsPackageGroupType,
    'DeclarationText': DeclarationTextType,
    'DeicingInformation': DeicingInformationType,
    'DepartureActivityTimes': DepartureActivityTimesType,
    'DepartureMovementAreaHoldInformation': DepartureMovementAreaHoldInformationType,
    'Dimensions': DimensionsType,
    'Dinghy': DinghyType,
    'DinghyColour': DinghyColourType,
    'DirectRouting': DirectRoutingType,
    'ElapsedTimeLocation': ElapsedTimeLocationType,
    'EnRoute': EnRouteType,
    'EnRouteDiversion': EnRouteDiversionType,
    'EstimatedElapsedTime': EstimatedElapsedTimeType,
    'ExpandedRoute': ExpandedRouteType,
    'ExpandedRoutePoint': ExpandedRoutePointType,
    'ExtendedMultiTime': ExtendedMultiTimeType,
    'Extension': ExtensionType,
    'Feature': FeatureType,
    'FeatureMessage': FeatureMessageType,
    'FixPoint': FixPointType,
    'Flight': FlightType,
    'FlightArrival': FlightArrivalType,
    'FlightDeparture': FlightDepartureType,
    'FlightEmergency': FlightEmergencyType,
    'FlightIdentification': FlightIdentificationType,
    'FlightIntent': FlightIntentType,
    'FlightMessage': FlightMessageType,
    'FlightStatus': FlightStatusType,
    'GeographicLocation': GeographicLocationType,
    'GroundspeedChoice': GroundspeedChoiceType,
    'GroundspeedRange': GroundspeedRangeType,
    'Handoff': HandoffType,
    'IcaoAerodromeReference': IcaoAerodromeReferenceType,
    'IdentifiedUnitReference': IdentifiedUnitReferenceType,
    'LastContact': LastContactType,
    'LastPositionReport': LastPositionReportType,
    'LateralOfftrack': LateralOfftrackType,
    'LevelConstraint': LevelConstraintType,
    'LocationPoint': LocationPointType,
    'MessageCollection': MessageCollectionType,
    'MessageMetadata': MessageMetadataType,
    'MeteorologicalData': MeteorologicalDataType,
    'MultiTime': MultiTimeType,
    'NameValueList': NameValueListType,
    'NameValuePair': NameValuePairType,
    'NasAdaptedArrivalRoute': NasAdaptedArrivalRouteType,
    'NasAdaptedRoute': NasAdaptedRouteType,
    'NasAdvisory': NasAdvisoryType,
    'NasAircraft': NasAircraftType,
    'NasAircraftPosition': NasAircraftPositionType,
    'NasAirspaceConstraint': NasAirspaceConstraintType,
    'NasAirspeedChoice': NasAirspeedChoiceType,
    'NasAltitude': NasAltitudeType,
    'NasArrival': NasArrivalType,
    'NasClearedFlightInformation': NasClearedFlightInformationType,
    'NasCoordination': NasCoordinationType,
    'NasDeparture': NasDepartureType,
    'NasEnRoute': NasEnRouteType,
    'NasExpandedRoute': NasExpandedRouteType,
    'NasFlight': NasFlightType,
    'NasFlightIdentification': NasFlightIdentificationType,
    'NasFlightPlan': NasFlightPlanType,
    'NasFlightStatus': NasFlightStatusType,
    'NasHandoff': NasHandoffType,
    'NasPerformanceBasedAccuracy': NasPerformanceBasedAccuracyType,
    'NasReroute': NasRerouteType,
    'NasRoute': NasRouteType,
    'NasRoutePoint': NasRoutePointType,
    'NasRouteSegment': NasRouteSegmentType,
    'NasSupplementalData': NasSupplementalDataType,
    'NasTmi': NasTmiType,
    'NasTrajectoryOption': NasTrajectoryOptionType,
    'NasUnitBoundary': NasUnitBoundaryType,
    'NasVelocity': NasVelocityType,
    'NavigationCapabilities': NavigationCapabilitiesType,
    'OfftrackDistance': OfftrackDistanceType,
    'OnlineContact': OnlineContactType,
    'Organization': OrganizationType,
    'Originator': OriginatorType,
    'Person': PersonType,
    'PersonOrOrganization': PersonOrOrganizationType,
    'PlannedReportingPosition': PlannedReportingPositionType,
    'Point4D': Point4DType,
    'PointRange': PointRangeType,
    'Pointout': PointoutType,
    'PostalAddress': PostalAddressType,
    'RadioCommunicationFailure': RadioCommunicationFailureType,
    'RadioactiveMaterial': RadioactiveMaterialType,
    'Radionuclide': RadionuclideType,
    'RankedTrajectory': RankedTrajectoryType,
    'RelativePoint': RelativePointType,
    'ReportedTime': ReportedTimeType,
    'Route': RouteType,
    'RouteConstraintOrPreference': RouteConstraintOrPreferenceType,
    'RouteImpactList': RouteImpactListType,
    'RoutePoint': RoutePointType,
    'RouteSegment': RouteSegmentType,
    'RunwayAcceptableSlotSubstitution': RunwayAcceptableSlotSubstitutionType,
    'RunwayArrivalTime': RunwayArrivalTimeType,
    'RunwayDepartureTime': RunwayDepartureTimeType,
    'RunwayPositionAndTime': RunwayPositionAndTimeType,
    'ShippingInformation': ShippingInformationType,
    'SignificantPoint': SignificantPointType,
    'SpeedConstraint': SpeedConstraintType,
    'SpeedSchedule': SpeedScheduleType,
    'StandPositionAndTime': StandPositionAndTimeType,
    'StructuredPostalAddress': StructuredPostalAddressType,
    'SupplementalData': SupplementalDataType,
    'SurveillanceCapabilities': SurveillanceCapabilitiesType,
    'SurvivalCapabilities': SurvivalCapabilitiesType,
    'TargetMultiTime': TargetMultiTimeType,
    'TelephoneContact': TelephoneContactType,
    'Temperatures': TemperaturesType,
    'TemporalRange': TemporalRangeType,
    'TimeConstraint': TimeConstraintType,
    'TimeSequence': TimeSequenceType,
    'TimeSpan': TimeSpanType,
    'Trajectory': TrajectoryType,
    'TrajectoryChange': TrajectoryChangeType,
    'TrajectoryPoint': TrajectoryPointType,
    'TrajectoryRoutePair': TrajectoryRoutePairType,
    'UnitBoundary': UnitBoundaryType,
    'UnknownUnitReference': UnknownUnitReferenceType,
    'UnlistedAerodromeReference': UnlistedAerodromeReferenceType,
    'VerticalRange': VerticalRangeType,
    'VfrAltitude': VfrAltitudeType,
    'VfrOnTopAltitude': VfrOnTopAltitudeType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AerodromeReferenceType'
        rootClass = AerodromeReferenceType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AerodromeReferenceType'
        rootClass = AerodromeReferenceType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AerodromeReferenceType'
        rootClass = AerodromeReferenceType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AerodromeReferenceType'
        rootClass = AerodromeReferenceType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from __init__ import *\n\n')
        sys.stdout.write('import __init__ as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

__all__ = [
    "AboveAltitudeType",
    "AbstractMessageType",
    "AbstractRoutePointType",
    "ActualSpeedType",
    "AdditionalHandlingInformationType",
    "AerodromeReferenceType",
    "AirWaybillType",
    "AircraftCapabilitiesType",
    "AircraftOperatorType",
    "AircraftPositionType",
    "AircraftType",
    "AircraftTypeType",
    "AirspaceAcceptableSlotSubstitutionType",
    "AirspaceConstraintType",
    "AirspaceEntryTimeType",
    "AirspaceExitTimeType",
    "AirspeedChoiceType",
    "AirspeedInIasOrMachType",
    "AirspeedRangeType",
    "AllPackedInOneType",
    "AltFixAltAltitudeType",
    "AltitudeChoiceType",
    "AltitudeInTransitionType",
    "AltitudeType",
    "AngleType",
    "ArrivalMovementAreaHoldInformationType",
    "AtcUnitReferenceType",
    "BeaconCodeAssignmentType",
    "BeaconCodeType",
    "BlockAltitudeType",
    "BoundaryCrossingType",
    "ClearedFlightInformationType",
    "ClimbToLevelConstraintType",
    "CmsAccuracyType",
    "CommunicationCapabilitiesType",
    "ConstrainedAirspaceEntryType",
    "ContactInformationType",
    "ControlElementType",
    "CoordinationStatusType",
    "CpdlcConnectionType",
    "DangerousGoodsDimensionsType",
    "DangerousGoodsPackageGroupType",
    "DangerousGoodsPackageType",
    "DangerousGoodsType",
    "DeclarationTextType",
    "DeicingInformationType",
    "DepartureActivityTimesType",
    "DepartureMovementAreaHoldInformationType",
    "DimensionsType",
    "DinghyColourType",
    "DinghyType",
    "DirectRoutingType",
    "DirectionType",
    "DistanceType",
    "ElapsedTimeLocationType",
    "EnRouteDiversionType",
    "EnRouteType",
    "EstimatedElapsedTimeType",
    "ExpandedRoutePointType",
    "ExpandedRouteType",
    "ExtendedMultiTimeType",
    "ExtensionType",
    "FeatureMessageType",
    "FeatureType",
    "FixPointType",
    "FlightArrivalType",
    "FlightDepartureType",
    "FlightEmergencyType",
    "FlightIdentificationType",
    "FlightIntentType",
    "FlightMessageType",
    "FlightStatusType",
    "FlightType",
    "GeographicLocationType",
    "GloballyUniqueFlightIdentifierType",
    "GroundspeedChoiceType",
    "GroundspeedRangeType",
    "GroundspeedType",
    "HandoffType",
    "HazardClassType",
    "IcaoAerodromeReferenceType",
    "IdentifiedUnitReferenceType",
    "LastContactType",
    "LastPositionReportType",
    "LateralOfftrackType",
    "LengthType",
    "LevelConstraintType",
    "LocationPointType",
    "MessageCollectionType",
    "MessageMetadataType",
    "MeteorologicalDataType",
    "MultiTimeType",
    "NameValueListType",
    "NameValuePairType",
    "NasAdaptedArrivalRouteType",
    "NasAdaptedRouteType",
    "NasAdvisoryType",
    "NasAircraftPositionType",
    "NasAircraftType",
    "NasAirspaceConstraintType",
    "NasAirspeedChoiceType",
    "NasAltitudeType",
    "NasArrivalType",
    "NasClearedFlightInformationType",
    "NasCoordinationType",
    "NasDepartureType",
    "NasEnRouteType",
    "NasExpandedRouteType",
    "NasFlightIdentificationType",
    "NasFlightPlanType",
    "NasFlightStatusType",
    "NasFlightType",
    "NasHandoffType",
    "NasPerformanceBasedAccuracyType",
    "NasPositionAltitudeType",
    "NasRerouteType",
    "NasRoutePointType",
    "NasRouteSegmentType",
    "NasRouteType",
    "NasSupplementalDataType",
    "NasTmiType",
    "NasTrajectoryOptionType",
    "NasUnitBoundaryType",
    "NasVelocityType",
    "NavigationCapabilitiesType",
    "OfftrackDistanceType",
    "OnlineContactType",
    "OrganizationType",
    "OriginatorType",
    "PersonOrOrganizationType",
    "PersonType",
    "PlannedReportingPositionType",
    "Point4DType",
    "PointRangeType",
    "PointoutType",
    "PostalAddressType",
    "PressureType",
    "RadioCommunicationFailureType",
    "RadioFrequencyType",
    "RadioactiveMaterialActivityType",
    "RadioactiveMaterialType",
    "RadionuclideType",
    "RankedTrajectoryType",
    "RelativePointType",
    "ReportedTimeType",
    "RouteConstraintOrPreferenceType",
    "RouteImpactListType",
    "RoutePointType",
    "RouteSegmentType",
    "RouteType",
    "RunwayAcceptableSlotSubstitutionType",
    "RunwayArrivalTimeType",
    "RunwayDepartureTimeType",
    "RunwayPositionAndTimeType",
    "ShippingInformationType",
    "SignificantPointType",
    "SimpleAltitudeType",
    "SpeedConstraintType",
    "SpeedScheduleType",
    "SpeedType",
    "StandPositionAndTimeType",
    "StructuredPostalAddressType",
    "SupplementalDataType",
    "SurveillanceCapabilitiesType",
    "SurvivalCapabilitiesType",
    "TargetMultiTimeType",
    "TelephoneContactType",
    "TemperatureType",
    "TemperaturesType",
    "TemporalRangeType",
    "TimeConstraintType",
    "TimeSequenceType",
    "TimeSpanType",
    "TrajectoryChangeType",
    "TrajectoryPointType",
    "TrajectoryRoutePairType",
    "TrajectoryType",
    "TrueAirspeedOrMachType",
    "UnitBoundaryType",
    "UnitSectorAirspaceType",
    "UnknownUnitReferenceType",
    "UnlistedAerodromeReferenceType",
    "VerticalRangeType",
    "VerticalRateType",
    "VfrAltitudeType",
    "VfrOnTopAltitudeType",
    "VfrOnTopPlusAltitudeType",
    "VfrPlusAltitudeType",
    "VolumeType",
    "WeightType",
    "WindDirectionType",
    "WindspeedType"
]
