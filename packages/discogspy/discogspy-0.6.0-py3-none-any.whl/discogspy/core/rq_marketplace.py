# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_core.rq_marketplace.ipynb (unless otherwise specified).

__all__ = ['get_inventory', 'get_listing', 'update_listing', 'delete_listing', 'add_new_listing', 'get_order',
           'update_order_status', 'update_order_shipping', 'get_orders', 'get_order_messages', 'post_message_on_order',
           'get_discogs_fee_for_given_price', 'get_price_suggestions']

# Cell
import requests
from typing import Union
from . import *

# Cell


def get_inventory(user: Union[UserWithoutAuthentication,
                              UserWithUserTokenBasedAuthentication],
                  username: str,
                  status: Union[StatusInventory, None] = None,
                  page: Union[int, None] = None,
                  per_page: Union[int, None] = None,
                  sort: Union[SortOptionsInventory, None] = None,
                  sort_order: Union[SortOrder, None] = None
                  ) -> requests.models.Response:
    """
    Get a list of listings of a given user inventory.

    If you are not authenticated as the inventory owner,
    only items that have a status of "For Sale" will be visible.

    No user Authentication needed.

    Parameters:

    user: user object (required)

    username: string (required)
        -> The username for whose inventory you are fetching

    status: string (optional)
        -> Only show items with this status.

    page: number (optional)
        -> The page you want to request.

    per_page: number (optional)
        -> The number of items per page.

    sort: string (optional)
        -> Sort items by this field.

    sort_order: string (optional)
        -> Sort items in a particular order (one of asc, desc)

    """
    url = f"{USERS_URL}/{username}/inventory"
    headers = user.headers
    params = user.params
    if status:
        if type(user) is UserWithoutAuthentication:
            params["status"] = StatusInventory.for_sale.value
        else:
            params["status"] = status.value
    if page:
        params["page"] = max(1, page)
    if per_page:
        params["per_page"] = max(1, per_page)
    if sort:
        if type(user) is UserWithoutAuthentication and (sort is not SortOptionsInventory.status and
                                                        sort is not SortOptionsInventory.location):
            params["sort"] = sort.name
        else:
            params["sort"] = sort.name
    if sort_order:
        params["sort_order"] = sort_order.name

    return requests.get(url, headers=headers, params=params)

# Cell


def get_listing(user: Union[UserWithoutAuthentication,
                            UserWithUserTokenBasedAuthentication],
                listing_id: int,
                curr_abbr: Union[CurrAbbr, None] = None
                ) -> requests.models.Response:
    """
    Get all the information about the requested listing from the given user inventory.

    No user Authentication needed.

    Parameters:

    user: user object (required)

    listing_id: number (required)
        -> The username for whose inventory you are fetching

    curr_abbr: string (optional)
        -> Currency for marketplace data. Defaults to the authenticated users currency.
    """
    url = f"{LISTINGS_URL}/{listing_id}"
    headers = user.headers
    params = user.params
    if curr_abbr:
        params["curr_abbr"] = curr_abbr.value

    return requests.get(url, headers=headers, params=params)

# Cell


def update_listing(user: UserWithUserTokenBasedAuthentication,
                   listing_id: int,
                   release_id: int,
                   condition: ReleaseCondition,
                   price: float,
                   sleeve_condition: Union[SleeveCondition, None] = None,
                   status: Union[StatusInventory, None] = None,
                   comments: Union[str, None] = None,
                   allow_offers: Union[bool, None] = None,
                   external_id: Union[str, None] = None,
                   location: Union[str, None] = None,
                   weight: Union[int, None] = None,
                   format_quantity: Union[int, None] = None,
                   curr_abbr: Union[CurrAbbr, None] = None
                   ) -> requests.models.Response:
    """
    Update the data associated with a listing.

    User Authentication needed.

    Parameters:

    user: user object (required)

    listing_id: number (required)
        -> The username for whose inventory you are fetching

    release_id: number (required)
        -> The ID of the release you are posting

    condition: string (required)
        -> The condition of the release you are posting.

    price: number (required)
        -> The price of the item (in the seller’s currency).

    status: string (required)
        -> The status of the listing. Defaults to For Sale.

    sleeve_condition: string (optional)
        -> The condition of the sleeve of the item you are posting.

    comments: string (optional)
        -> Any remarks about the item that will be displayed to buyers.

    allow_offers: boolean (optional)
        -> Whether or not to allow buyers to make offers on the item. Defaults to false.

    external_id: string (optional)
        -> A freeform field that can be used for the seller’s own reference.
        -> Information stored here will not be displayed to anyone other than the seller.
        -> This field is called “Private Comments” on the Discogs website.

    location: string (optional)
        -> A freeform field that is intended to help identify an item’s physical storage location.
        -> Information stored here will not be displayed to anyone other than the seller.
        -> This field will be visible on the inventory management page and will be available in inventory exports via the website.

    weight: number (optional)
        -> The weight, in grams, of this listing, for the purpose of calculating shipping.
        -> Set this field to auto to have the weight automatically estimated for you.

    format_quantity: number (optional)
        -> The number of items this listing counts as, for the purpose of calculating shipping.
        -> This field is called “Counts As” on the Discogs website.
        -> Set this field to auto to have the quantity automatically estimated for you.

    curr_abbr: string (optional)
        -> Currency for marketplace data. Defaults to the authenticated users currency.
    """

    url = f"{LISTINGS_URL}/{listing_id}"

    params = user.params
    if curr_abbr:
        params["curr_abbr"] = curr_abbr.value

    data = {
        "release_id": release_id,
        "condition": condition.value,
        "price": price,
        "status": status.value,
    }

    if sleeve_condition:
        data["sleeve_condition"] = sleeve_condition.value
    if comments:
        data["comments"] = comments
    if allow_offers is not None:
        data["allow_offers"] = allow_offers
    if external_id:
        data["external_id"] = external_id
    if location:
        data["location"] = location
    if weight:
        data["weight"] = weight
    if format_quantity:
        data["format_quantity"] = format_quantity

    return requests.post(url, params=params, json=data)

# Cell


def delete_listing(user: UserWithUserTokenBasedAuthentication,
                   listing_id: int
                   ) -> requests.models.Response:
    """
    Delete a given listing from the inventory.

    User Authentication needed.

    Parameters:

    user: user object (required)

    listing_id: number (required)
        -> The username for whose inventory you are fetching.
    """

    url = f"{LISTINGS_URL}/{listing_id}"
    headers = user.headers
    params = user.params

    return requests.delete(url, headers=headers, params=params)

# Cell


def add_new_listing(user: UserWithUserTokenBasedAuthentication,
                    release_id: int,
                    condition: ReleaseCondition,
                    price: float,
                    status: StatusNewListing,
                    sleeve_condition: Union[SleeveCondition, None] = None,
                    comments: Union[str, None] = None,
                    allow_offers: Union[bool, None] = None,
                    external_id: Union[str, None] = None,
                    location: Union[str, None] = None,
                    weight: Union[int, None] = None,
                    format_quantity: Union[int, None] = None
                    ) -> requests.models.Response:
    """
    Add a new listing to the given user inventory.

    User Authentication needed.

    Parameters:

    user: user object (required)

    release_id: number (required)
        -> The ID of the release you are posting

    condition: string (required)
        -> The condition of the release you are posting.

    price: number (required)
        -> The price of the item (in the seller’s currency).

    status: string (required)
        -> The status of the listing. Defaults to For Sale.

    sleeve_condition: string (optional)
        -> The condition of the sleeve of the item you are posting.

    comments: string (optional)
        -> Any remarks about the item that will be displayed to buyers.

    allow_offers: boolean (optional)
        -> Whether or not to allow buyers to make offers on the item. Defaults to false.

    external_id: string (optional)
        -> A freeform field that can be used for the seller’s own reference.
        -> Information stored here will not be displayed to anyone other than the seller.
        -> This field is called “Private Comments” on the Discogs website.

    location: string (optional)
        -> A freeform field that is intended to help identify an item’s physical storage location.
        -> Information stored here will not be displayed to anyone other than the seller.
        -> This field will be visible on the inventory management page and will be available in inventory exports via the website.

    weight: number (optional)
        -> The weight, in grams, of this listing, for the purpose of calculating shipping.
        -> Set this field to auto to have the weight automatically estimated for you.

    format_quantity: number (optional)
        -> The number of items this listing counts as, for the purpose of calculating shipping.
        -> This field is called “Counts As” on the Discogs website.
        -> Set this field to auto to have the quantity automatically estimated for you.
    """

    url = f"{LISTINGS_URL}"
    headers = user.headers

    params = user.params

    data = {
        "release_id": release_id,
        "condition": condition.value,
        "price": price,
        "status": status.value,
    }

    if sleeve_condition:
        data["sleeve_condition"] = sleeve_condition.value
    if comments:
        data["comments"] = comments
    if allow_offers is not None:
        data["allow_offers"] = allow_offers
    if external_id:
        data["external_id"] = external_id
    if location:
        data["location"] = location
    if weight:
        data["weight"] = weight
    if format_quantity:
        data["format_quantity"] = format_quantity

    return requests.post(url, headers=headers, params=params, json=data)

# Cell


def get_order(user: UserWithUserTokenBasedAuthentication,
              order_id: str
              ) -> requests.models.Response:
    """
    Get the data associated with the given order.

    User Authentication needed.

    Parameters:

    user: user object (required)

    order_id: string (required)
        -> The ID of the order you are fetching
    """
    url = f"{ORDERS_URL}/{order_id}"
    headers = user.headers
    params = user.params

    return requests.get(url, headers=headers, params=params)

# Cell


def update_order_status(user: UserWithUserTokenBasedAuthentication,
                        order_id: str,
                        status: StatusOrder
                        ) -> requests.models.Response:
    """
    Update the status associated with the given order.

    Note: Use get_order to get the next_status key.
          The next_status key is an array of valid next statuses for this order.

    User Authentication needed.

    Parameters:

    user: user object (required)

    order_id: string (required)
        -> The ID of the order you are fetching

    status: string (required)
        -> The status of the Order you are updating.
    """
    url = f"{ORDERS_URL}/{order_id}"
    headers = user.headers
    params = user.params

    data = {"status": status.value}

    return requests.post(url, headers=headers, params=params, json=data)

# Cell


def update_order_shipping(user: UserWithUserTokenBasedAuthentication,
                          order_id: str,
                          shipping_cost: float
                          ) -> requests.models.Response:
    """
    Update the shipping costs associated with the given order.

    Note: If the order status is neither cancelled, Payment Received, nor Shipped, you can change the shipping.
          Doing so will send an invoice to the buyer and set the order status to Invoice Sent.

    User Authentication needed.

    Parameters:

    user: user object (required)

    order_id: string (required)
        -> The ID of the order you are fetching

    shipping_cost: number (required)
        -> The order shipping amount.
    """
    url = f"{ORDERS_URL}/{order_id}"
    headers = user.headers
    params = user.params

    data = {"shipping": shipping_cost}

    return requests.post(url, headers=headers, params=params, json=data)

# Cell


def get_orders(user: UserWithUserTokenBasedAuthentication,
               status: Union[StatusOrders, None] = None,
               page: Union[int, None] = None,
               per_page: Union[int, None] = None,
               sort: Union[SortOptionsOrders, None] = None,
               sort_order: Union[SortOrder, None] = None
               ) -> requests.models.Response:
    """
    Get a list of orders associated with the given user.

    Note: In the Discogs API is an optional parameter called "archived".
          I did not implement it because it always caused a server-sided crash.

    User Authentication needed.

    Parameters:

    user: user object (required)

    status: string (optional)
        -> Only show items with this status.

    page: number (optional)
        -> The page you want to request.

    per_page: number (optional)
        -> The number of items per page.

    sort: string (optional)
        -> Sort items by this field.

    sort_order: string (optional)
        -> Sort items in a particular order (one of asc, desc)
    """
    url = f"{ORDERS_URL}"
    headers = user.headers
    params = user.params

    if status:
        params["status"] = status.value
    if page:
        params["page"] = max(1, page)
    if per_page:
        params["per_page"] = max(1, per_page)
    if sort:
        params["sort"] = sort.name
    if sort_order:
        params["sort_order"] = sort_order.name

    return requests.get(url, headers=headers, params=params)

# Cell


def get_order_messages(user: UserWithUserTokenBasedAuthentication,
                       order_id: str,
                       page: Union[int, None] = None,
                       per_page: Union[int, None] = None
                       ) -> requests.models.Response:
    """
    Get a list of messages associated with the given order, with the most recent first.

    User Authentication needed.

    Parameters:

    user: user object (required)

    order_id: string (required)
        -> The ID of the order you are fetching

    page: number (optional)
        -> The page you want to request.

    per_page: number (optional)
        -> The number of items per page.
    """
    url = f"{ORDERS_URL}/{order_id}/messages"
    headers = user.headers
    params = user.params

    if page:
        params["page"] = max(1, page)
    if per_page:
        params["per_page"] = max(1, per_page)

    return requests.get(url, headers=headers, params=params)

# Cell


def post_message_on_order(user: UserWithUserTokenBasedAuthentication,
                          order_id: str,
                          message: str,
                          ) -> requests.models.Response:
    """
    Post a new message to the given order.

    User Authentication needed.

    Parameters:

    user: user object (required)

    order_id: string (required)
        -> The ID of the order you are fetching

    message: string (required)
    """
    url = f"{ORDERS_URL}/{order_id}/messages"
    headers = user.headers
    params = user.params

    data = {
        "message": message
    }

    return requests.post(url, headers=headers, params=params, json=data)

# Cell


def get_discogs_fee_for_given_price(user: Union[UserWithoutAuthentication,
                                                UserWithUserTokenBasedAuthentication],
                                    price: float
                                    ) -> requests.models.Response:
    """
    Calculate the fee for selling an item on the Marketplace in USD

    Note: According to the Discogs API, it should be possible to change the currency.
          However, this feature seems to be broken at this point.
          That's why I did remove this optional argument.

    No user Authentication needed.

    Parameters:

    user: user object (required)

    price: number (required)
        -> The price to calculate a fee from
    """

    url = f"{FEE_URL}/{price}"
    headers = user.headers
    params = user.params

    return requests.get(url, headers=headers, params=params)

# Cell


def get_price_suggestions(user: UserWithUserTokenBasedAuthentication,
                          release_id: int
                          ) -> requests.models.Response:
    """
    Get a price suggestions for the given release id.

    Note: Suggested prices will be denominated in the user’s selling currency.
          If no suggestions are available, an empty object will be returned.

    User Authentication needed.

    Parameters:

    user: user object (required)

    release_id: number (required)
        -> The release ID to calculate a price from.
    """

    url = f"{PRICE_SUGGESTIONS_URL}/{release_id}"
    headers = user.headers
    params = user.params

    return requests.get(url, headers=headers, params=params)