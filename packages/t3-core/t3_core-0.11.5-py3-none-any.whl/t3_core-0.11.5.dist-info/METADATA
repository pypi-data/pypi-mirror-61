Metadata-Version: 2.1
Name: t3-core
Version: 0.11.5
Summary: Boilerplate to quickly setup a Django Rest Framework Microservice for T3
Home-page: https://www.t-3.com/
Author: Travis Krause
Author-email: travis.krause@t-3.com
License: UNKNOWN
Keywords: t3 t3-python-core
Platform: UNKNOWN
Classifier: Development Status :: 2 - Pre-Alpha
Classifier: Intended Audience :: Developers
Classifier: Operating System :: OS Independent
Classifier: Natural Language :: English
Classifier: Programming Language :: Python :: 3.6
Requires-Dist: Django (==2.2.4)
Requires-Dist: gunicorn (==19.9.0)
Requires-Dist: psycopg2-binary (==2.7.5)
Requires-Dist: djangorestframework (==3.9.0)
Requires-Dist: django-filter (==2.0.0)
Requires-Dist: markdown (==2.6.11)
Requires-Dist: coreapi (==2.3.3)
Requires-Dist: django-crispy-forms (==1.7.2)
Requires-Dist: drf-yasg[validation] (==1.11.0)
Requires-Dist: django-extensions (==2.1.2)
Requires-Dist: django-log-request-id (==1.3.2)
Requires-Dist: django-cors-headers (==2.4.0)
Requires-Dist: djangorestframework-camel-case (==0.2.0)
Requires-Dist: drf-nested-routers (==0.91)
Requires-Dist: boto3 (==1.9.6)
Requires-Dist: django-storages (==1.7.1)
Requires-Dist: watchtower (==0.5.3)
Requires-Dist: django-prometheus (==1.0.15)
Requires-Dist: requests (==2.19.1)
Requires-Dist: requests-oauthlib (==1.0.0)
Requires-Dist: python-dotenv[cli] (==0.9.1)
Requires-Dist: pygments (==2.2.0)
Requires-Dist: ipython[notebook] (==7.0.1)
Requires-Dist: PyYAML (==3.13)
Requires-Dist: PyJWT (==1.6.4)
Requires-Dist: coverage (==4.5.1)
Requires-Dist: pytest (==3.8.0)
Requires-Dist: pytest-cov (==2.6.0)
Requires-Dist: pytest-django (==3.4.3)
Requires-Dist: pytest-dotenv (==0.2.0)
Requires-Dist: pylint (==2.1.1)
Requires-Dist: pylint-django (==2.0.2)
Requires-Dist: pep8 (==1.7.1)
Requires-Dist: autopep8 (==1.4.1)
Requires-Dist: pylama (==7.6.5)
Requires-Dist: pylama-pylint (==3.1.1)
Requires-Dist: astroid (==2.0.4)
Requires-Dist: m2r (==0.2.0)
Requires-Dist: redis (==2.10.6)
Requires-Dist: cachecontrol (==0.12.6)
Requires-Dist: urllib3 (==1.23)
Requires-Dist: pika (==0.12.0)
Requires-Dist: click (==6.7)


T3 Python Core Library
======================


.. image:: https://gitlab.t-3.com/t3-core/t3-core-python/badges/master/pipeline.svg
   :target: https://gitlab.t-3.com/sunoco/t3-python-core/commits/master
   :alt: pipeline status


.. image:: https://gitlab.t-3.com/t3-core/t3-core-python/badges/master/coverage.svg
   :target: https://gitlab.t-3.com/sunoco/t3-python-core/commits/master
   :alt: coverage report


.. image:: https://badge.fury.io/py/t3-core.svg
   :target: https://badge.fury.io/py/t3-core
   :alt: PyPI version


Install
-------

Setup Virtualenv (optional)
^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sh

   python -m venv .venv
   source .venv/bin/activate

   # There is a bug in pip 9.x  go ahead and upgrade to make sure that you're pip 10.x
   pip install --upgrade pip

Install
^^^^^^^

.. code-block:: sh

   # Install from pypi
   pip install t3-core

   # Install in the `src` dir of your python environment
   pip install -e git+ssh://git@gitlab.t-3.com:t3-core/t3-core-python.git

   # Choose where the clone lives
   git clone git@gitlab.t-3.com:t3-core/t3-core-python.git
   pip install -e ./t3-python-core

Testing & Linting
-----------------

Test & Coverage Report
^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sh

   pytest

Lint
^^^^

.. code-block:: sh

   pylama

T3 Events
---------

In *t3-core*\ , we've a sub-module which is an event queue system used to connect microservices together, in an asynchronous manner, with built-in fault tolerance. It uses *RabbitMQ* as a messaging bus to accomplish this. Event queue system consists of 2 main parts, *consumer*\ , and *publisher*. 

A Consumer, as the name suggests, consumes the messages, by invoking a callback upon receiving the specified message, which is published by the Publisher. Separately running processes, commonly known as workers can consume messages, whereas, any process including web process can publish messages. If any process is unable to finish consuming the message, it gets requed in the system and is sent to a different consumer or stored until the consumer is available again. 

In *T3 Events*. *T3 Events*\ , is configured by setting up 2 key environment variables, ``T3_EVENTS``\ , and ``T3_EVENTS_AMQP_URL``\ , the first one is a boolean value of *true* or *false* on whether to use events or not, and the second one is a connection string for *rabbit-mq*. This env vars can be inserted into any system, and as long as different systems have same value for those env vars, they are part of the same message queue system. There are two main types of consumers and publishers, details below:

Task
^^^^

Task consumer/publisher are dedicated to consuming or publishing Tasks, which by definition are consumed one at a time, for a given task, which means, the first available consumer will pick up the task and process it, then the next task in the list will go to the next available consumer, and so on. Below is an example of a sample task.

**Consumer:**

.. code-block:: python

   from t3.events.consumers imoprt TaskConsumer

   def message_callback(payload):
       print(f'message callback task consumer: payload: {payload}')

   # Start consumer
   test = TaskConsumer()
   test.set_task_name('test_task')
   test.set_callback(message_callback)
   test.run()

**Publisher:**

.. code-block:: python

   from t3.events.publishers import TaskPublisher

   # Use publisher
   test = TaskPublisher()
   test.set_task_name('test_task')
   test.set_message('test message, could be in json too')
   test.run()

For the above example, the given example task name is ``test_task``\ , which is the same for a consumer and a publisher, which connects them together. Since this is a ``TaskConsumer``\ , and a ``TaskPublisher``\ , if you run more than 1 *Consumer*\ , and *Publish* several times, it'll be processed in a round-robin manner with the running *Consumers*\ , one at a time. Once 1 message is processed, then the system moves on to the next one, and so on.

Topic
^^^^^

Topic consumer/publisher are dedicated to consuming or publishing *Topics*\ , which by definition are broadcasted to all subscribed *Consumers*\ , for a given *Topic*\ , which means, when a topic is published, all consumers signed up for this topic will receive the message. Below is an example of a sample topic.

**Consumer:**

.. code-block:: python

   from t3.events.consumers import TopicConsumer

   def message_callback(payload):
       print(f'message callback topic consumer: payload: {payload}')

   # Start consumer
   test = TopicConsumer()
   test.set_topic_name('test_topic')
   test.set_callback(message_callback)
   test.run()

**Publisher:**

.. code-block:: python

   from t3.events.publishers import TopicPublisher
   import json

   # Use publisher
   test = TopicPublisher()
   test.set_topic_name('test_topic')
   test.set_message(json.dumps({'json': 'object'}))
   test.run()

For the above example, the given topic name is ``test_topic``\ , which is the same for a consumer and a publisher, which connects them together. Since this is a ``TopicConsumer``\ , and a ``TopicPublisher``\ , if you run more than 1 *Consumer*\ , and *Publish*\ , it'll be processed by all running *Consumers*\ , at once.

Running T3 Events
^^^^^^^^^^^^^^^^^

T3 events is composed of *Consumers*\ , and *Publishers*. 

Consumers must be run in a separate process, as they are independent of anything else that is going on in the system, for local development, you can run ``python name_of_consumer_file.py``\ , however in production environments, use ``nohup python name_of_consumer_file.py``\ , for fault tolerance purposes.

Pubishers on the other hand, can be run as part of a process, as their main job is to publish an event to the message queue system. To use a *Publisher*\ , you can run the lines below ``# Use publisher`` from the above examples, provided the 2 required environment variables are present.


