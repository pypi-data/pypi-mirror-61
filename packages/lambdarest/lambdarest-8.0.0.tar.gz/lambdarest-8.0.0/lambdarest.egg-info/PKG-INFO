Metadata-Version: 2.1
Name: lambdarest
Version: 8.0.0
Summary: mature micro web framework for AWS Lambda
Home-page: https://github.com/trustpilot/python-lambdarest
Author: sloev
Author-email: johannes.valbjorn@gmail.com
License: UNKNOWN
Description: # lambdarest
        
        [![Build Status](https://travis-ci.org/trustpilot/python-lambdarest.svg?branch=master)](https://travis-ci.org/trustpilot/python-lambdarest) [![Latest Version](https://img.shields.io/pypi/v/lambdarest.svg)](https://pypi.python.org/pypi/lambdarest) [![Python Support](https://img.shields.io/pypi/pyversions/lambdarest.svg)](https://pypi.python.org/pypi/lambdarest) [![Examples tested with pytest-readme](http://img.shields.io/badge/readme-tested-brightgreen.svg)](https://github.com/boxed/pytest-readme)
        
        
        Python routing mini-framework for [AWS Lambda](https://aws.amazon.com/lambda/) with optional JSON-schema validation.
        
        ### Features
        
        * `lambda_handler` function constructor with built-in dispatcher
        * Decorator to register functions to handle HTTP methods
        * Optional JSON-schema input validation using same decorator
        
        ### External articles / tutorials
        
        * [devgrok.com: Create a Private Microservice Using an Application Load Balancer](http://www.devgrok.com/2019/03/create-private-microservice-using.html)
        
          Article about how to use **lambdarest** with **AWS Application Load Balancer**
        
        * [rockset.com: Building a Serverless Microservice Using Rockset and AWS Lambda](https://rockset.com/blog/building-a-serverless-microservice-using-rockset-and-aws-lambda/)
        
          Article about how to set up **lambdarest** in AWS infrastructure
        
        **Other articles? add them [here](https://github.com/trustpilot/python-lambdarest/issues/55)**
        
        ## Installation
        
        Install the package from [PyPI](http://pypi.python.org/pypi/) using [pip](https://pip.pypa.io/):
        
        ```bash
        pip install lambdarest
        ```
        
        ## Getting Started
        
        This module helps you to handle different HTTP methods in your AWS Lambda.
        
        ```python
        from lambdarest import lambda_handler
        
        @lambda_handler.handle("get")
        def my_own_get(event):
            return {"this": "will be json dumped"}
        
        
        ##### TEST #####
        
        
        input_event = {
            "body": '{}',
            "httpMethod": "GET",
            "resource": "/"
        }
        result = lambda_handler(event=input_event)
        assert result == {"body": '{"this": "will be json dumped"}', "statusCode": 200, "headers":{}}
        ```
        
        ## Advanced Usage
        
        Optionally you can validate an incoming JSON body against a JSON schema:
        
        ```python
        from lambdarest import lambda_handler
        
        my_schema = {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "type": "object",
            "properties": {
                "body":{
                    "type": "object",
                    "properties": {
                        "foo": {
                            "type": "string"
                        }
                    }
                }
            }
        }
        
        @lambda_handler.handle("get", path="/with-schema/", schema=my_schema)
        def my_own_get(event):
            return {"this": "will be json dumped"}
        
        
        ##### TEST #####
        
        
        valid_input_event = {
            "body": '{"foo":"bar"}',
            "httpMethod": "GET",
            "resource": "/with-schema/"
        }
        result = lambda_handler(event=valid_input_event)
        assert result == {"body": '{"this": "will be json dumped"}', "statusCode": 200, "headers":{}}
        
        
        invalid_input_event = {
            "body": '{"foo":666}',
            "httpMethod": "GET",
            "resource": "/with-schema/"
        }
        result = lambda_handler(event=invalid_input_event)
        assert result == {"body": 'Validation Error', "statusCode": 400, "headers":{}}
        ```
        
        ### Query Params
        
        Query parameters are also analyzed and validatable with JSON schemas.
        Query arrays are expected to be comma separated, all numbers are converted to floats.
        
        ```python
        from lambdarest import lambda_handler
        
        my_schema = {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "type": "object",
            "properties": {
                "query":{
                    "type": "object",
                    "properties": {
                        "foo": {
                            "type": "array",
                            "items": {
                                "type": "number"
                            }
                        }
                    }
                }
            }
        }
        
        @lambda_handler.handle("get", path="/with-params/", schema=my_schema)
        def my_own_get(event):
            return event["json"]["query"]
        
        
        ##### TEST #####
        
        
        valid_input_event = {
            "queryStringParameters": {
                "foo": "1, 2.2, 3"
            },
            "httpMethod": "GET",
            "resource": "/with-params/"
        }
        result = lambda_handler(event=valid_input_event)
        assert result == {"body": '{"foo": [1.0, 2.2, 3.0]}', "statusCode": 200, "headers":{}}
        ```
        
        ### Routing
        
        You can also specify which path to react on for individual handlers using the `path` param:
        
        ```python
        from lambdarest import lambda_handler
        
        @lambda_handler.handle("get", path="/foo/bar/baz")
        def my_own_get(event):
            return {"this": "will be json dumped"}
        
        
        ##### TEST #####
        
        
        input_event = {
            "body": '{}',
            "httpMethod": "GET",
            "resource": "/foo/bar/baz"
        }
        result = lambda_handler(event=input_event)
        assert result == {"body": '{"this": "will be json dumped"}', "statusCode": 200, "headers":{}}
        ```
        
        And you can specify path parameters as well, which will be passed as keyword arguments:
        
        ```python
        from lambdarest import lambda_handler
        
        @lambda_handler.handle("get", path="/foo/<int:id>/")
        def my_own_get(event, id):
            return {"my-id": id}
        
        
        ##### TEST #####
        
        
        input_event = {
            "body": '{}',
            "httpMethod": "GET",
            "resource": "/foo/1234/"
        }
        result = lambda_handler(event=input_event)
        assert result == {"body": '{"my-id": 1234}', "statusCode": 200, "headers":{}}
        ```
        
        Or you can specify more complex parametrized resource path and get parameteres as arguments:
        ```python
        from lambdarest import lambda_handler
        
        @lambda_handler.handle("get", path="/object/<int:object_id>/props/<string:foo>/get")
        def my_own_get(event, object_id, foo):
            return [{"object_id": int(object_id)}, {"foo": foo}]
        
        
        ##### TEST #####
        
        input_event = {
            "body": '{}',
            "httpMethod": "GET",
            "path": "/v1/object/777/props/bar/get",
            "resource": "/object/{object_id}/props/{foo}/get",
            "pathParameters": {
              "object_id": "777",
              "foo":"bar"
            }
        }
        result = lambda_handler(event=input_event)
        assert result == {"body": '[{"object_id": 777}, {"foo": "bar"}]', "statusCode": 200, "headers":{}}
        
        ```
        Or use the Proxy APIGateway magic endpoint:
        ```python
        from lambdarest import lambda_handler
        
        @lambda_handler.handle("get", path="/bar/<path:path>")
        def my_own_get(event, path):
            return {"path": path}
        
        
        ##### TEST #####
        
        input_event = {
            "body": '{}',
            "httpMethod": "GET",
            "path": "/v1/bar/baz",
            "resource": "/bar/{proxy+}",
            "pathParameters": {
              "proxy": "bar/baz"
            }
        }
        result = lambda_handler(event=input_event)
        assert result == {"body": '{"path": "bar/baz"}', "statusCode": 200, "headers":{}}
        ```
        
        ## Use it with AWS Application Load Balancer
        
        In order to use it with Application Load Balancer you need to create your own lambda_handler and not use the singleton:
        
        ```python
        from lambdarest import create_lambda_handler
        
        lambda_handler = create_lambda_handler(application_load_balancer=True)
        
        @lambda_handler.handle("get", path="/foo/<int:id>/")
        def my_own_get(event, id):
            return {"my-id": id}
        
        
        ##### TEST #####
        
        
        input_event = {
            "body": '{}',
            "httpMethod": "GET",
            "resource": "/foo/1234/"
        }
        result = lambda_handler(event=input_event)
        assert result == {"body": '{"my-id": 1234}', "statusCode": 200, "headers":{}, "statusDescription": "HTTP OK", "isBase64Encoded": False}
        ```
        
        ## Anormal unittest behaviour with `lambda_handler` singleton
        
        Because of python unittests leaky test-cases it seems like you shall beware of [this issue](https://github.com/trustpilot/python-lambdarest/issues/16) when using the singleton `lambda_handler` in a multiple test-case scenario.
        
        ## Tests
        
        This package uses Make to install requirements and run tests.
        
        Use the following commands to install requirements and run test-suite:
        
        ```
        
        $ make setup test
        ```
        
        For more info see [Contributing...](./CONTRIBUTING.md)
        
        ## Contributors
        
        @nabrosimoff, @elviejokike, @eduardomourar, @devgrok, @AlbertoTrindade, @paddie, @svdgraaf, @simongarnier, @martinbuberl, @adamelmore, @sloev
        
        [Wanna contribute?](./CONTRIBUTING.md)
        
        And by the way, we have a [Code Of Friendlyhood!](./CODE_OF_CONDUCT.md)
        
        
        ## Release History
        
        ### 1.0.1 (2017-02-24)
        
        **This is not a backwards compatible change.**
        
        First OSS release
        
        **features** 
        
        - dispatching handler for individual HTTP methods - (optional) jsonschema validation for endpoints
        - automatic wrapping of responses
        
        ### 2.0.0 (2017-03-04)
        
        **This is not a backwards compatible change.**
        
        **features** 
        
        - now json is divided into \[\"json\"\]\[\"body\"\] for post body and \[\"json\"\]\[\"query\"\] for json loaded query params 
        - jsonschema validation gets whole \[\"json\"\] object so remember to change your schemas/code!!!
        
        ### 2.1.0 (2017-03-06)
        
        **bugfixes** 
        
        - empty body and queryStringParameters are tolerated
        
        **features** 
        
        - query parameters arrays are now supported 
        - array items are tried casted to numbers, defaulted to strings (see last README example) 
        - more tests
        
        ### 2.2.1 (2017-10-03)
        
        **features** 
        
        - builds and deploys automatically using travis to pypi and github releases
        
        ### 2.2.6 (2017-12-13)
        
        **features** 
        
        - An error handler can now be passed when creating a handler. Any unhandled error will be re-raise when None is passed
        
        ### 4.0.0 (2018-04-06)
        
        **features** 
        
        - added Werkzeug path parameters
        
        ### 4.1.0 (2018-04-12)
        
        **features** 
        
        - added support for custom domains
        
        ### 5.0.0 (2018-06-07)
        
        **This is not a backwards compatible change.**
        
        **features** 
        
        - removed support for python 3.3
        
        ### 5.0.1 (2018-06-13)
        
        **features** 
        
        - Fixed issue with custom domains and path variables
        
        ### 5.1.0 (2018-11-01)
        
        **features** 
        
        - Return None only if the value of the variable is None. This will allow to return empty strings.
        
        ### 5.2.0 (2019-03-06)
        
        **features** 
        
        - you can override the json encoder with your own
        
        ### 5.3.0 (2019-03-06)
        
        **features** 
        
        - Add support for Application Load Balancer
        
        ### 5.4.0 (2019-03-06)
        
        **features** 
        
        - Add application\_load\_balancer arg to create\_lambda\_handler to create lambda\_handlers specifically for Application Load Balancer
        
        ### 5.4.0 (2019-08-17)
        
        **features** 
        
        - Support of resource path {placeholders} in the middle
        
        ### 5.6.0 (2020-01-27)
        
        **features** 
        
        - Add functools.wraps 
        - use black for lint
        
        ### 6.0.0 (2020-01-27)
        
        **features** 
        
        **This is not a backwards compatible change.**
        
        - drop python 3.4 and 2.7 support
        
        ### 6.0.1 (2020-01-28)
        
        **features** 
        
        - remember HISTORY.md in manifest file
        
        ### 7.0.0 (2020-02-12)
        
        **This is not a backwards compatible change.**
        
        - don't json.dumps the body if it's already a str (pr #58)
        
        ### 8.0.0 (2020-02-14)
        
        **This is not a backwards compatible change.**
        
        - minimally process standard lambda (dict) responses (pr #59)
Keywords: lambda aws rest json schema jsonschema
Platform: UNKNOWN
Classifier: Development Status :: 6 - Mature
Classifier: Intended Audience :: Developers
Classifier: Natural Language :: English
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Description-Content-Type: text/markdown
Provides-Extra: test
